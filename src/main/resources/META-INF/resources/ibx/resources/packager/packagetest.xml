Console was cleared
<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright 1996-2016 Information Builders, Inc. All rights reserved.
$Revision: 1.123 $:-->
<ibx-res-bundle name="ibx_resourece_bundle.xml" loadContext="ibx">

	<ibx-boot-resources>
		<ibx-boot-files>
			<!-- <style-file src="./css/base.ibx.css"/>
			<script-file src="./etc/jquery/jquery.js"/>
			<script-file src="./etc/jquery/jquery-ui-1.12.1/jquery-ui.js"/>
			<script-file src="./js/util.ibx.js"/>
			<script-file src="./js/preload.ibx.js"/>
			<script-file src="./js/resources.ibx.js"/> -->
		</ibx-boot-files>
	</ibx-boot-resources>

	<!--strings-->
	<strings>
	</strings>

	<!--markup-->
	<markup>
	</markup>

	<!--styles-->
	<styles>
	</styles>

	<!--scripts-->
	<scripts>
	<script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./etc/resizepolyfill/ResizeSensor.js"><![CDATA[/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */
;
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.ResizeSensor = factory();
    }
}(this, function () {

    // Make sure it does not throw in a SSR (Server Side Rendering) situation
    if (typeof window === "undefined") {
        return null;
    }
    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.
    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and
    // would generate too many unnecessary events.
    var requestAnimationFrame = window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        function (fn) {
            return window.setTimeout(fn, 20);
        };

    /**
     * Iterate over each of the provided element(s).
     *
     * @param {HTMLElement|HTMLElement[]} elements
     * @param {Function}                  callback
     */
    function forEachElement(elements, callback){
        var elementsType = Object.prototype.toString.call(elements);
        var isCollectionTyped = ('[object Array]' === elementsType
            || ('[object NodeList]' === elementsType)
            || ('[object HTMLCollection]' === elementsType)
            || ('[object Object]' === elementsType)
            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery
            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools
        );
        var i = 0, j = elements.length;
        if (isCollectionTyped) {
            for (; i < j; i++) {
                callback(elements[i]);
            }
        } else {
            callback(elements);
        }
    }

    /**
     * Class for dimension change detection.
     *
     * @param {Element|Element[]|Elements|jQuery} element
     * @param {Function} callback
     *
     * @constructor
     */
    var ResizeSensor = function(element, callback) {
        /**
         *
         * @constructor
         */
        function EventQueue() {
            var q = [];
            this.add = function(ev) {
                q.push(ev);
            };

            var i, j;
            this.call = function() {
                for (i = 0, j = q.length; i < j; i++) {
                    q[i].call();
                }
            };

            this.remove = function(ev) {
                var newQueue = [];
                for(i = 0, j = q.length; i < j; i++) {
                    if(q[i] !== ev) newQueue.push(q[i]);
                }
                q = newQueue;
            }

            this.length = function() {
                return q.length;
            }
        }

        /**
         * @param {HTMLElement} element
         * @param {String}      prop
         * @returns {String|Number}
         */
        function getComputedStyle(element, prop) {
            if (element.currentStyle) {
                return element.currentStyle[prop];
            }
            if (window.getComputedStyle) {
                return window.getComputedStyle(element, null).getPropertyValue(prop);
            }

            return element.style[prop];
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {Function}    resized
         */
        function attachResizeEvent(element, resized) {
            if (!element) return;
            if (element.resizedAttached) {
                element.resizedAttached.add(resized);
                return;
            }

            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);

            element.resizeSensor = document.createElement('div');
            element.resizeSensor.className = 'resize-sensor';
            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';

            element.resizeSensor.style.cssText = style;
            element.resizeSensor.innerHTML =
                '<div class="resize-sensor-expand" style="' + style + '">' +
                    '<div style="' + styleChild + '"></div>' +
                '</div>' +
                '<div class="resize-sensor-shrink" style="' + style + '">' +
                    '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' +
                '</div>';
            element.appendChild(element.resizeSensor);

            if (getComputedStyle(element, 'position') == 'static') {
                element.style.position = 'relative';
            }

            var expand = element.resizeSensor.childNodes[0];
            var expandChild = expand.childNodes[0];
            var shrink = element.resizeSensor.childNodes[1];
            var dirty, rafId, newWidth, newHeight;
            var lastWidth = element.offsetWidth;
            var lastHeight = element.offsetHeight;

            var reset = function() {
                expandChild.style.width = '100000px';
                expandChild.style.height = '100000px';

                expand.scrollLeft = 100000;
                expand.scrollTop = 100000;

                shrink.scrollLeft = 100000;
                shrink.scrollTop = 100000;
            };

            reset();

            var onResized = function() {
                rafId = 0;

                if (!dirty) return;

                lastWidth = newWidth;
                lastHeight = newHeight;

                if (element.resizedAttached) {
                    element.resizedAttached.call();
                }
            };

            var onScroll = function() {
                newWidth = element.offsetWidth;
                newHeight = element.offsetHeight;
                dirty = newWidth != lastWidth || newHeight != lastHeight;

                if (dirty && !rafId) {
                    rafId = requestAnimationFrame(onResized);
                }

                reset();
            };

            var addEvent = function(el, name, cb) {
                if (el.attachEvent) {
                    el.attachEvent('on' + name, cb);
                } else {
                    el.addEventListener(name, cb);
                }
            };

            addEvent(expand, 'scroll', onScroll);
            addEvent(shrink, 'scroll', onScroll);
        }

        forEachElement(element, function(elem){
            attachResizeEvent(elem, callback);
        });

        this.detach = function(ev) {
            ResizeSensor.detach(element, ev);
        };
    };

    ResizeSensor.detach = function(element, ev) {
        forEachElement(element, function(elem){
            if (!elem) return
            if(elem.resizedAttached && typeof ev == "function"){
                elem.resizedAttached.remove(ev);
                if(elem.resizedAttached.length()) return;
            }
            if (elem.resizeSensor) {
                if (elem.contains(elem.resizeSensor)) {
                    elem.removeChild(elem.resizeSensor);
                }
                delete elem.resizeSensor;
                delete elem.resizedAttached;
            }
        });
    };

    return ResizeSensor;

}));
//# sourceURL=ResizeSensor.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./etc/scrollwidthpolyfill/scrollwidthpolyfill.js"><![CDATA[// Scroll Width Polyfill version 1.1
// Github: https://github.com/gregwhitworth/scrollWidthPolyfill
// License: MIT License (http://opensource.org/licenses/MIT)
var polyScrollWidth = (function (document, window) {
       
    var polyScrollWidth = window.polyScrollWidth || {
        "needsPoly": false,
        "usedPoly": false,
        "version": 1.1
    };
    
    var origScrollWidth = Object.getOwnPropertyDescriptor(Element.prototype, 'scrollWidth').get;
    
    init();
    
    // Init
    // ---------------------------------------------
    // This initializes the polyfill and checks to see
    // if the scrollWidth method is producing a reasonable
    // result, if so then no need to polyfill.
    function init() {
       var needsPoly = featureDetect();
       if(!needsPoly) {
           polyScrollWidth.needsPoly = false;
           return polyScrollWidth;
       } else {
           polyScrollWidth.needsPoly = true;
       }
       
       // Create new polyfill for scrollWidth since we need to polyfill it
       Object.defineProperty(Element.prototype, "scrollWidth", { configurable: true, enumerable: true, get: getScrollWidth });
    }
    
    // Feature Detect
    // ---------------------------------------------
    // Unfortunately we're making this polyfill for interop reasons, so we
    // need to do a quick test to ensure that it is implemented correctly.
    // Because of this we will create two ghost elements and then match them
    // to see if they return reasonable results for scrollWidth
    function featureDetect() {
       var needsPoly = false;
       var overrideStyles = [
             {
                   "name":"float",
                   "value":"left"
             },
             {
                   "name":"paddingLeft",
                   "value":"0px"
             },
             {
                   "name":"paddingRight",
                   "value":"0px"
             },
             {
                   "name":"position",
                   "value":"absolute"
             },
             {
                 "name":"width",
                 "value":"0px"
             },
             {
                 "name":"borderRightWidth",
                 "value":"0px"
             },
             {
                 "name":"borderLeftWidth",
                 "value":"0px"
             },
             {
                 "name":"visibility",
                 "value":"hidden"
             }      
       ];
       
       var ghostMeasureInput = createGhostElement("input", null, overrideStyles, "Test", true);   
       
       // Check within +/- 2 pixels for reasonable results of scrollWidth in comparison to clientWidth [both should include padding]
       if(ghostMeasureInput.scrollWidth == 0) {
             needsPoly = true;
       }
       
       return needsPoly;
    }
    
    // Create Ghost Element
    // ---------------------------------------------
    // This will create the ghost items and then return the measured results. It also
    // deletes the node and removes the HTML after it's done.
    // <param name="elType"" type="string">This is the type of element you want to create, for example a div</param>
    // <param name="computedStyles" type="CSSStyleDeclaration">These are the computed styles of the element you're wanting your ghost element to match</param>
    // <param name="overrideStyles" type="[{name, value}]">These are the styles you want to override on the new element (eg: [{"name":"visibility", "value":"hidden"}])</param>
    // <param name="content" type="string">This is the content that you want to be included in the element for measurement</param>
    // <param name="callScrollWidth" type="bool">Do you want to call scrollWidth, if you set this to true and the polyfill has been set you'll end up in a loop</param>
    // <return name="ghostMeasure" type="{"scrollWidth", "clientWidth"}">These are the two widths that we care about and will pass these back to the methods that want to do something with them</param>
    function createGhostElement(elType, computedStyles, /* [{ name, value }] */ overrideStyles,  content, callScrollWidth) {
          var id, el, ghostMeasure;
          elType = elType.toLowerCase();
          
          id = "swMeasure-" + Date.now();
          el = document.createElement(elType);
          el.id = id;   
          
          var initStyle = el.style;      
          
          if(computedStyles !== null) {
              var csKeys = Object.keys(computedStyles.__proto__);
              csKeys.forEach(function(prop) {
                  initStyle[prop] = computedStyles[prop];
              });
              el.style = initStyle;
          }
          
          overrideStyles.forEach(function(overrideStyle) {
                el.style[overrideStyle.name] = overrideStyle.value;
          });
          
          if(elType == "input" || elType == "textarea") {
                el.value = content;
          }
          else {
            el.textContent = content;
          }
          
          document.getElementsByTagName('body')[0].appendChild(el);
          
          el = document.getElementById(id);
          
          ghostMeasure = {
                "scrollWidth": (callScrollWidth) ? el.scrollWidth : 0,
                "clientWidth": parseInt(el.clientWidth, 10)
          };
          
          el.outerHTML = "";
          delete el;
          
          return ghostMeasure;
    }

    // Get Scroll Width
    // --------------------------------------------------------
    // Will get all necessary information from the input to
    // completely polyfill el.scrollWidth
    // <return type="int">The max of the element width or the clientWidth</return>
    function getScrollWidth() {
      if(this.nodeName != "INPUT" && this.nodeName != "TEXTAREA") return origScrollWidth.call(this);
      
      polyScrollWidth.usedPoly = true;
      var width = "auto";
      var computedStyles = window.getComputedStyle(this, null);
      
      // We only want to set the width of the container if it is a textarea since
      // that will need accurate wrapping. For any other input we just want the
      // length of the text as one long string so width should be ""
      if(this.nodeName == "TEXTAREA") width = computedStyles.width;
       
      var overrideStyles = [
        {
            "name": "position",
            "value": "absolute"
        },
        {
           "name": "float",
           "value": "left"
        },
        {
           "name":"visibility",
           "value":"hidden"
        },
        // We don't want the width set
        {
            "name":"width",
            "value": width
        }
      ];     
      
      var ghost = createGhostElement("div", computedStyles, overrideStyles, this.value, false);
      
      return Math.max(parseInt(computedStyles.width, 10), ghost.clientWidth); //scrollWidth returns the max of content or element width
    }
    
    return polyScrollWidth;
})(document, window);
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./etc/gridstack/underscore.js"><![CDATA[//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function () { function n(n) { function t(t, r, e, u, i, o) { for (; i >= 0 && o > i; i += n) { var a = u ? u[i] : i; e = r(e, t[a], a, t) } return e } return function (r, e, u, i) { e = b(e, i, 4); var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1; return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a) } } function t(n) { return function (t, r, e) { r = x(r, e); for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i; return -1 } } function r(n, t, r) { return function (e, u, i) { var o = 0, a = O(e); if ("number" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a) return i = r(e, u), e[i] === u ? i : -1; if (u !== u) return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1; for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i; return -1 } } function e(n, t) { var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = "constructor"; for (m.has(n, i) && !m.contains(t, i) && t.push(i) ; r--;) i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i) } var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice, s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create, d = function () { }, m = function (n) { return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n) }; "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), exports._ = m) : u._ = m, m.VERSION = "1.8.3"; var b = function (n, t, r) { if (t === void 0) return n; switch (null == r ? 3 : r) { case 1: return function (r) { return n.call(t, r) }; case 2: return function (r, e) { return n.call(t, r, e) }; case 3: return function (r, e, u) { return n.call(t, r, e, u) }; case 4: return function (r, e, u, i) { return n.call(t, r, e, u, i) } } return function () { return n.apply(t, arguments) } }, x = function (n, t, r) { return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n) }; m.iteratee = function (n, t) { return x(n, t, 1 / 0) }; var _ = function (n, t) { return function (r) { var e = arguments.length; if (2 > e || null == r) return r; for (var u = 1; e > u; u++) for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) { var f = o[c]; t && r[f] !== void 0 || (r[f] = i[f]) } return r } }, j = function (n) { if (!m.isObject(n)) return {}; if (y) return y(n); d.prototype = n; var t = new d; return d.prototype = null, t }, w = function (n) { return function (t) { return null == t ? void 0 : t[n] } }, A = Math.pow(2, 53) - 1, O = w("length"), k = function (n) { var t = O(n); return "number" == typeof t && t >= 0 && A >= t }; m.each = m.forEach = function (n, t, r) { t = b(t, r); var e, u; if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n); else { var i = m.keys(n); for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n) } return n }, m.map = m.collect = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) { var a = e ? e[o] : o; i[o] = t(n[a], a, n) } return i }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function (n, t, r) { var e; return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0 }, m.filter = m.select = function (n, t, r) { var e = []; return t = x(t, r), m.each(n, function (n, r, u) { t(n, r, u) && e.push(n) }), e }, m.reject = function (n, t, r) { return m.filter(n, m.negate(x(t)), r) }, m.every = m.all = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) { var o = e ? e[i] : i; if (!t(n[o], o, n)) return !1 } return !0 }, m.some = m.any = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) { var o = e ? e[i] : i; if (t(n[o], o, n)) return !0 } return !1 }, m.contains = m.includes = m.include = function (n, t, r, e) { return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0 }, m.invoke = function (n, t) { var r = l.call(arguments, 2), e = m.isFunction(t); return m.map(n, function (n) { var u = e ? t : n[t]; return null == u ? u : u.apply(n, r) }) }, m.pluck = function (n, t) { return m.map(n, m.property(t)) }, m.where = function (n, t) { return m.filter(n, m.matcher(t)) }, m.findWhere = function (n, t) { return m.find(n, m.matcher(t)) }, m.max = function (n, t, r) { var e, u, i = -1 / 0, o = -1 / 0; if (null == t && null != n) { n = k(n) ? n : m.values(n); for (var a = 0, c = n.length; c > a; a++) e = n[a], e > i && (i = e) } else t = x(t, r), m.each(n, function (n, r, e) { u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u) }); return i }, m.min = function (n, t, r) { var e, u, i = 1 / 0, o = 1 / 0; if (null == t && null != n) { n = k(n) ? n : m.values(n); for (var a = 0, c = n.length; c > a; a++) e = n[a], i > e && (i = e) } else t = x(t, r), m.each(n, function (n, r, e) { u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u) }); return i }, m.shuffle = function (n) { for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++) t = m.random(0, i), t !== i && (u[i] = u[t]), u[t] = r[i]; return u }, m.sample = function (n, t, r) { return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t)) }, m.sortBy = function (n, t, r) { return t = x(t, r), m.pluck(m.map(n, function (n, r, e) { return { value: n, index: r, criteria: t(n, r, e) } }).sort(function (n, t) { var r = n.criteria, e = t.criteria; if (r !== e) { if (r > e || r === void 0) return 1; if (e > r || e === void 0) return -1 } return n.index - t.index }), "value") }; var F = function (n) { return function (t, r, e) { var u = {}; return r = x(r, e), m.each(t, function (e, i) { var o = r(e, i, t); n(u, e, o) }), u } }; m.groupBy = F(function (n, t, r) { m.has(n, r) ? n[r].push(t) : n[r] = [t] }), m.indexBy = F(function (n, t, r) { n[r] = t }), m.countBy = F(function (n, t, r) { m.has(n, r) ? n[r]++ : n[r] = 1 }), m.toArray = function (n) { return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : [] }, m.size = function (n) { return null == n ? 0 : k(n) ? n.length : m.keys(n).length }, m.partition = function (n, t, r) { t = x(t, r); var e = [], u = []; return m.each(n, function (n, r, i) { (t(n, r, i) ? e : u).push(n) }), [e, u] }, m.first = m.head = m.take = function (n, t, r) { return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t) }, m.initial = function (n, t, r) { return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t))) }, m.last = function (n, t, r) { return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t)) }, m.rest = m.tail = m.drop = function (n, t, r) { return l.call(n, null == t || r ? 1 : t) }, m.compact = function (n) { return m.filter(n, m.identity) }; var S = function (n, t, r, e) { for (var u = [], i = 0, o = e || 0, a = O(n) ; a > o; o++) { var c = n[o]; if (k(c) && (m.isArray(c) || m.isArguments(c))) { t || (c = S(c, t, r)); var f = 0, l = c.length; for (u.length += l; l > f;) u[i++] = c[f++] } else r || (u[i++] = c) } return u }; m.flatten = function (n, t) { return S(n, t, !1) }, m.without = function (n) { return m.difference(n, l.call(arguments, 1)) }, m.uniq = m.unique = function (n, t, r, e) { m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e)); for (var u = [], i = [], o = 0, a = O(n) ; a > o; o++) { var c = n[o], f = r ? r(c, o, n) : c; t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c) } return u }, m.union = function () { return m.uniq(S(arguments, !0, !0)) }, m.intersection = function (n) { for (var t = [], r = arguments.length, e = 0, u = O(n) ; u > e; e++) { var i = n[e]; if (!m.contains(t, i)) { for (var o = 1; r > o && m.contains(arguments[o], i) ; o++); o === r && t.push(i) } } return t }, m.difference = function (n) { var t = S(arguments, !0, !0, 1); return m.filter(n, function (n) { return !m.contains(t, n) }) }, m.zip = function () { return m.unzip(arguments) }, m.unzip = function (n) { for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e); return r }, m.object = function (n, t) { for (var r = {}, e = 0, u = O(n) ; u > e; e++) t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1]; return r }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function (n, t, r, e) { r = x(r, e, 1); for (var u = r(t), i = 0, o = O(n) ; o > i;) { var a = Math.floor((i + o) / 2); r(n[a]) < u ? i = a + 1 : o = a } return i }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), m.range = function (n, t, r) { null == t && (t = n || 0, n = 0), r = r || 1; for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r) u[i] = n; return u }; var E = function (n, t, r, e, u) { if (!(e instanceof t)) return n.apply(r, u); var i = j(n.prototype), o = n.apply(i, u); return m.isObject(o) ? o : i }; m.bind = function (n, t) { if (g && n.bind === g) return g.apply(n, l.call(arguments, 1)); if (!m.isFunction(n)) throw new TypeError("Bind must be called on a function"); var r = l.call(arguments, 2), e = function () { return E(n, e, t, this, r.concat(l.call(arguments))) }; return e }, m.partial = function (n) { var t = l.call(arguments, 1), r = function () { for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o]; for (; e < arguments.length;) i.push(arguments[e++]); return E(n, r, this, this, i) }; return r }, m.bindAll = function (n) { var t, r, e = arguments.length; if (1 >= e) throw new Error("bindAll must be passed function names"); for (t = 1; e > t; t++) r = arguments[t], n[r] = m.bind(n[r], n); return n }, m.memoize = function (n, t) { var r = function (e) { var u = r.cache, i = "" + (t ? t.apply(this, arguments) : e); return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i] }; return r.cache = {}, r }, m.delay = function (n, t) { var r = l.call(arguments, 2); return setTimeout(function () { return n.apply(null, r) }, t) }, m.defer = m.partial(m.delay, m, 1), m.throttle = function (n, t, r) { var e, u, i, o = null, a = 0; r || (r = {}); var c = function () { a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null) }; return function () { var f = m.now(); a || r.leading !== !1 || (a = f); var l = t - (f - a); return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), i } }, m.debounce = function (n, t, r) { var e, u, i, o, a, c = function () { var f = m.now() - o; t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), e || (i = u = null))) }; return function () { i = this, u = arguments, o = m.now(); var f = r && !e; return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a } }, m.wrap = function (n, t) { return m.partial(t, n) }, m.negate = function (n) { return function () { return !n.apply(this, arguments) } }, m.compose = function () { var n = arguments, t = n.length - 1; return function () { for (var r = t, e = n[t].apply(this, arguments) ; r--;) e = n[r].call(this, e); return e } }, m.after = function (n, t) { return function () { return --n < 1 ? t.apply(this, arguments) : void 0 } }, m.before = function (n, t) { var r; return function () { return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r } }, m.once = m.partial(m.before, 2); var M = !{ toString: null }.propertyIsEnumerable("toString"), I = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"]; m.keys = function (n) { if (!m.isObject(n)) return []; if (v) return v(n); var t = []; for (var r in n) m.has(n, r) && t.push(r); return M && e(n, t), t }, m.allKeys = function (n) { if (!m.isObject(n)) return []; var t = []; for (var r in n) t.push(r); return M && e(n, t), t }, m.values = function (n) { for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]]; return e }, m.mapObject = function (n, t, r) { t = x(t, r); for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) e = u[a], o[e] = t(n[e], e, n); return o }, m.pairs = function (n) { for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]]; return e }, m.invert = function (n) { for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e]; return t }, m.functions = m.methods = function (n) { var t = []; for (var r in n) m.isFunction(n[r]) && t.push(r); return t.sort() }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function (n, t, r) { t = x(t, r); for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (e = u[i], t(n[e], e, n)) return e }, m.pick = function (n, t, r) { var e, u, i = {}, o = n; if (null == o) return i; m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), e = function (n, t, r) { return t in r }, o = Object(o)); for (var a = 0, c = u.length; c > a; a++) { var f = u[a], l = o[f]; e(l, f, o) && (i[f] = l) } return i }, m.omit = function (n, t, r) { if (m.isFunction(t)) t = m.negate(t); else { var e = m.map(S(arguments, !1, !1, 1), String); t = function (n, t) { return !m.contains(e, t) } } return m.pick(n, t, r) }, m.defaults = _(m.allKeys, !0), m.create = function (n, t) { var r = j(n); return t && m.extendOwn(r, t), r }, m.clone = function (n) { return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n }, m.tap = function (n, t) { return t(n), n }, m.isMatch = function (n, t) { var r = m.keys(t), e = r.length; if (null == n) return !e; for (var u = Object(n), i = 0; e > i; i++) { var o = r[i]; if (t[o] !== u[o] || !(o in u)) return !1 } return !0 }; var N = function (n, t, r, e) { if (n === t) return 0 !== n || 1 / n === 1 / t; if (null == n || null == t) return n === t; n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped); var u = s.call(n); if (u !== s.call(t)) return !1; switch (u) { case "[object RegExp]": case "[object String]": return "" + n == "" + t; case "[object Number]": return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t; case "[object Date]": case "[object Boolean]": return +n === +t } var i = "[object Array]" === u; if (!i) { if ("object" != typeof n || "object" != typeof t) return !1; var o = n.constructor, a = t.constructor; if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in t) return !1 } r = r || [], e = e || []; for (var c = r.length; c--;) if (r[c] === n) return e[c] === t; if (r.push(n), e.push(t), i) { if (c = n.length, c !== t.length) return !1; for (; c--;) if (!N(n[c], t[c], r, e)) return !1 } else { var f, l = m.keys(n); if (c = l.length, m.keys(t).length !== c) return !1; for (; c--;) if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e)) return !1 } return r.pop(), e.pop(), !0 }; m.isEqual = function (n, t) { return N(n, t) }, m.isEmpty = function (n) { return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length }, m.isElement = function (n) { return !(!n || 1 !== n.nodeType) }, m.isArray = h || function (n) { return "[object Array]" === s.call(n) }, m.isObject = function (n) { var t = typeof n; return "function" === t || "object" === t && !!n }, m.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function (n) { m["is" + n] = function (t) { return s.call(t) === "[object " + n + "]" } }), m.isArguments(arguments) || (m.isArguments = function (n) { return m.has(n, "callee") }), "function" != typeof /./ && "object" != typeof Int8Array && (m.isFunction = function (n) { return "function" == typeof n || !1 }), m.isFinite = function (n) { return isFinite(n) && !isNaN(parseFloat(n)) }, m.isNaN = function (n) { return m.isNumber(n) && n !== +n }, m.isBoolean = function (n) { return n === !0 || n === !1 || "[object Boolean]" === s.call(n) }, m.isNull = function (n) { return null === n }, m.isUndefined = function (n) { return n === void 0 }, m.has = function (n, t) { return null != n && p.call(n, t) }, m.noConflict = function () { return u._ = i, this }, m.identity = function (n) { return n }, m.constant = function (n) { return function () { return n } }, m.noop = function () { }, m.property = w, m.propertyOf = function (n) { return null == n ? function () { } : function (t) { return n[t] } }, m.matcher = m.matches = function (n) { return n = m.extendOwn({}, n), function (t) { return m.isMatch(t, n) } }, m.times = function (n, t, r) { var e = Array(Math.max(0, n)); t = b(t, r, 1); for (var u = 0; n > u; u++) e[u] = t(u); return e }, m.random = function (n, t) { return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1)) }, m.now = Date.now || function () { return (new Date).getTime() }; var B = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" }, T = m.invert(B), R = function (n) { var t = function (t) { return n[t] }, r = "(?:" + m.keys(n).join("|") + ")", e = RegExp(r), u = RegExp(r, "g"); return function (n) { return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n } }; m.escape = R(B), m.unescape = R(T), m.result = function (n, t, r) { var e = null == n ? void 0 : n[t]; return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e }; var q = 0; m.uniqueId = function (n) { var t = ++q + ""; return n ? n + t : t }, m.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; var K = /(.)^/, z = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" }, D = /\\|'|\r|\n|\u2028|\u2029/g, L = function (n) { return "\\" + z[n] }; m.template = function (n, t, r) { !t && r && (t = r), t = m.defaults({}, t, m.templateSettings); var e = RegExp([(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join("|") + "|$", "g"), u = 0, i = "__p+='"; n.replace(e, function (t, r, e, o, a) { return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : e ? i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : o && (i += "';\n" + o + "\n__p+='"), t }), i += "';\n", t.variable || (i = "with(obj||{}){\n" + i + "}\n"), i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n"; try { var o = new Function(t.variable || "obj", "_", i) } catch (a) { throw a.source = i, a } var c = function (n) { return o.call(this, n, m) }, f = t.variable || "obj"; return c.source = "function(" + f + "){\n" + i + "}", c }, m.chain = function (n) { var t = m(n); return t._chain = !0, t }; var P = function (n, t) { return n._chain ? m(t).chain() : t }; m.mixin = function (n) { m.each(m.functions(n), function (t) { var r = m[t] = n[t]; m.prototype[t] = function () { var n = [this._wrapped]; return f.apply(n, arguments), P(this, r.apply(m, n)) } }) }, m.mixin(m), m.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (n) { var t = o[n]; m.prototype[n] = function () { var r = this._wrapped; return t.apply(r, arguments), "shift" !== n && "splice" !== n || 0 !== r.length || delete r[0], P(this, r) } }), m.each(["concat", "join", "slice"], function (n) { var t = o[n]; m.prototype[n] = function () { return P(this, t.apply(this._wrapped, arguments)) } }), m.prototype.value = function () { return this._wrapped }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function () { return "" + this._wrapped }, "function" == typeof define && define.amd && define("underscore", [], function () { return m }) }).call(this);
//# sourceURL=underscore.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./etc/gridstack/gridstack.js"><![CDATA[/**
 * gridstack.js 0.2.6
 * http://troolee.github.io/gridstack.js/
 * (c) 2014-2016 Pavel Reznikov
 * gridstack.js may be freely distributed under the MIT license.
 * @preserve
*/
(function (factory)
{
	if (typeof define === 'function' && define.amd)
	{
		define(['jquery', 'lodash', 'jquery-ui/data', 'jquery-ui/disable-selection', 'jquery-ui/focusable',
            'jquery-ui/form', 'jquery-ui/ie', 'jquery-ui/keycode', 'jquery-ui/labels', 'jquery-ui/jquery-1-7',
            'jquery-ui/plugin', 'jquery-ui/safe-active-element', 'jquery-ui/safe-blur', 'jquery-ui/scroll-parent',
            'jquery-ui/tabbable', 'jquery-ui/unique-id', 'jquery-ui/version', 'jquery-ui/widget',
            'jquery-ui/widgets/mouse', 'jquery-ui/widgets/draggable', 'jquery-ui/widgets/droppable',
            'jquery-ui/widgets/resizable'], factory);
	} else if (typeof exports !== 'undefined')
	{
		try { jQuery = require('jquery'); } catch (e) { }
		try { _ = require('lodash'); } catch (e) { }
		factory(jQuery, _);
	} else
	{
		factory(jQuery, _);
	}
})(function ($, _)
{

	var scope = window;

	var obsolete = function (f, oldName, newName)
	{
		var wrapper = function ()
		{
			console.warn('gridstack.js: Function `' + oldName + '` is deprecated as of v0.2.5 and has been replaced ' +
            'with `' + newName + '`. It will be **completely** removed in v1.0.');
			return f.apply(this, arguments);
		};
		wrapper.prototype = f.prototype;

		return wrapper;
	};

	var obsoleteOpts = function (oldName, newName)
	{
		console.warn('gridstack.js: Option `' + oldName + '` is deprecated as of v0.2.5 and has been replaced with `' +
            newName + '`. It will be **completely** removed in v1.0.');
	};

	var Utils = {
		isIntercepted: function (a, b)
		{
			return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);
		},

		sort: function (nodes, dir, width)
		{
			width = width || _.chain(nodes).map(function (node) { return node.x + node.width; }).max().value();
			dir = dir != -1 ? 1 : -1;
			return _.sortBy(nodes, function (n) { return dir * (n.x + n.y * width); });
		},

		createStylesheet: function (id)
		{
			var style = document.createElement('style');
			style.setAttribute('type', 'text/css');
			style.setAttribute('data-gs-style-id', id);
			if (style.styleSheet)
			{
				style.styleSheet.cssText = '';
			} else
			{
				style.appendChild(document.createTextNode(''));
			}
			document.getElementsByTagName('head')[0].appendChild(style);
			return style.sheet;
		},

		removeStylesheet: function (id)
		{
			$('STYLE[data-gs-style-id=' + id + ']').remove();
		},

		insertCSSRule: function (sheet, selector, rules, index)
		{
			if (typeof sheet.insertRule === 'function')
			{
				sheet.insertRule(selector + '{' + rules + '}', index);
			} else if (typeof sheet.addRule === 'function')
			{
				sheet.addRule(selector, rules, index);
			}
		},

		toBool: function (v)
		{
			if (typeof v == 'boolean')
			{
				return v;
			}
			if (typeof v == 'string')
			{
				v = v.toLowerCase();
				return !(v === '' || v == 'no' || v == 'false' || v == '0');
			}
			return Boolean(v);
		},

		_collisionNodeCheck: function (n)
		{
			return n != this.node && Utils.isIntercepted(n, this.nn);
		},

		_didCollide: function (bn)
		{
			return Utils.isIntercepted({ x: this.n.x, y: this.newY, width: this.n.width, height: this.n.height }, bn);
		},

		_isAddNodeIntercepted: function (n)
		{
			return Utils.isIntercepted({ x: this.x, y: this.y, width: this.node.width, height: this.node.height }, n);
		},

		parseHeight: function (val)
		{
			var height = val;
			var heightUnit = 'px';
			if (height && _.isString(height))
			{
				var match = height.match(/^(-[0-9]+\.[0-9]+|[0-9]*\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw)?$/);
				if (!match)
				{
					throw new Error('Invalid height');
				}
				heightUnit = match[2] || 'px';
				height = parseFloat(match[1]);
			}
			return { height: height, unit: heightUnit };
		}
	};

	// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
	Utils.is_intercepted = obsolete(Utils.isIntercepted, 'is_intercepted', 'isIntercepted');

	Utils.create_stylesheet = obsolete(Utils.createStylesheet, 'create_stylesheet', 'createStylesheet');

	Utils.remove_stylesheet = obsolete(Utils.removeStylesheet, 'remove_stylesheet', 'removeStylesheet');

	Utils.insert_css_rule = obsolete(Utils.insertCSSRule, 'insert_css_rule', 'insertCSSRule');
	// jscs:enable requireCamelCaseOrUpperCaseIdentifiers

	var idSeq = 0;

	var GridStackEngine = function (width, onchange, floatMode, height, items)
	{
		this.width = width;
		this.float = floatMode || false;
		this.height = height || 0;

		this.nodes = items || [];
		this.onchange = onchange || function () { };

		this._updateCounter = 0;
		this._float = this.float;

		this._addedNodes = [];
		this._removedNodes = [];
	};

	GridStackEngine.prototype.batchUpdate = function ()
	{
		this._updateCounter = 1;
		this.float = true;
	};

	GridStackEngine.prototype.commit = function ()
	{
		if (this._updateCounter !== 0)
		{
			this._updateCounter = 0;
			this.float = this._float;
			this._packNodes();
			this._notify();
		}
	};

	// For Meteor support: https://github.com/troolee/gridstack.js/pull/272
	GridStackEngine.prototype.getNodeDataByDOMEl = function (el)
	{
		return _.find(this.nodes, function (n) { return el.get(0) === n.el.get(0); });
	};

	GridStackEngine.prototype._fixCollisions = function (node)
	{
		var self = this;
		this._sortNodes(-1);

		var nn = node;
		var hasLocked = Boolean(_.find(this.nodes, function (n) { return n.locked; }));
		if (!this.float && !hasLocked)
		{
			nn = { x: 0, y: node.y, width: this.width, height: node.height };
		}
		while (true)
		{
			var collisionNode = _.find(this.nodes, _.bind(Utils._collisionNodeCheck, { node: node, nn: nn }));
			if (typeof collisionNode == 'undefined')
			{
				return;
			}
			this.moveNode(collisionNode, collisionNode.x, node.y + node.height,
                collisionNode.width, collisionNode.height, true);
		}
	};

	GridStackEngine.prototype.isAreaEmpty = function (x, y, width, height)
	{
		var nn = { x: x || 0, y: y || 0, width: width || 1, height: height || 1 };
		var collisionNode = _.find(this.nodes, _.bind(function (n)
		{
			return Utils.isIntercepted(n, nn);
		}, this));
		return collisionNode === null || typeof collisionNode === 'undefined';
	};

	GridStackEngine.prototype._sortNodes = function (dir)
	{
		this.nodes = Utils.sort(this.nodes, dir, this.width);
	};

	GridStackEngine.prototype._packNodes = function ()
	{
		this._sortNodes();

		if (this.float)
		{
			_.each(this.nodes, _.bind(function (n, i)
			{
				if (n._updating || typeof n._origY == 'undefined' || n.y == n._origY)
				{
					return;
				}

				var newY = n.y;
				while (newY >= n._origY)
				{
					var collisionNode = _.chain(this.nodes)
                        .find(_.bind(Utils._didCollide, { n: n, newY: newY }))
                        .value();

					if (!collisionNode)
					{
						n._dirty = true;
						n.y = newY;
					}
					--newY;
				}
			}, this));
		} else
		{
			_.each(this.nodes, _.bind(function (n, i)
			{
				if (n.locked)
				{
					return;
				}
				while (n.y > 0)
				{
					var newY = n.y - 1;
					var canBeMoved = i === 0;

					if (i > 0)
					{
						var collisionNode = _.chain(this.nodes)
                            .take(i)
                            .find(_.bind(Utils._didCollide, { n: n, newY: newY }))
                            .value();
						canBeMoved = typeof collisionNode == 'undefined';
					}

					if (!canBeMoved)
					{
						break;
					}
					n._dirty = n.y != newY;
					n.y = newY;
				}
			}, this));
		}
	};

	GridStackEngine.prototype._prepareNode = function (node, resizing)
	{
		node = _.defaults(node || {}, { width: 1, height: 1, x: 0, y: 0 });

		node.x = parseInt('' + node.x);
		node.y = parseInt('' + node.y);
		node.width = parseInt('' + node.width);
		node.height = parseInt('' + node.height);
		node.autoPosition = node.autoPosition || false;
		node.noResize = node.noResize || false;
		node.noMove = node.noMove || false;

		if (node.width > this.width)
		{
			node.width = this.width;
		} else if (node.width < 1)
		{
			node.width = 1;
		}

		if (node.height < 1)
		{
			node.height = 1;
		}

		if (node.x < 0)
		{
			node.x = 0;
		}

		if (node.x + node.width > this.width)
		{
			if (resizing)
			{
				node.width = this.width - node.x;
			} else
			{
				node.x = this.width - node.width;
			}
		}

		if (node.y < 0)
		{
			node.y = 0;
		}

		return node;
	};

	GridStackEngine.prototype._notify = function ()
	{
		var args = Array.prototype.slice.call(arguments, 0);
		args[0] = typeof args[0] === 'undefined' ? [] : [args[0]];
		args[1] = typeof args[1] === 'undefined' ? true : args[1];
		if (this._updateCounter)
		{
			return;
		}
		var deletedNodes = args[0].concat(this.getDirtyNodes());
		this.onchange(deletedNodes, args[1]);
	};

	GridStackEngine.prototype.cleanNodes = function ()
	{
		if (this._updateCounter)
		{
			return;
		}
		_.each(this.nodes, function (n) { n._dirty = false; });
	};

	GridStackEngine.prototype.getDirtyNodes = function ()
	{
		return _.filter(this.nodes, function (n) { return n._dirty; });
	};

	GridStackEngine.prototype.addNode = function (node, triggerAddEvent)
	{
		node = this._prepareNode(node);

		if (typeof node.maxWidth != 'undefined') { node.width = Math.min(node.width, node.maxWidth); }
		if (typeof node.maxHeight != 'undefined') { node.height = Math.min(node.height, node.maxHeight); }
		if (typeof node.minWidth != 'undefined') { node.width = Math.max(node.width, node.minWidth); }
		if (typeof node.minHeight != 'undefined') { node.height = Math.max(node.height, node.minHeight); }

		node._id = ++idSeq;
		node._dirty = true;

		if (node.autoPosition)
		{
			this._sortNodes();

			for (var i = 0; ; ++i)
			{
				var x = i % this.width;
				var y = Math.floor(i / this.width);
				if (x + node.width > this.width)
				{
					continue;
				}
				if (!_.find(this.nodes, _.bind(Utils._isAddNodeIntercepted, { x: x, y: y, node: node })))
				{
					node.x = x;
					node.y = y;
					break;
				}
			}
		}

		this.nodes.push(node);
		if (typeof triggerAddEvent != 'undefined' && triggerAddEvent)
		{
			this._addedNodes.push(_.clone(node));
		}

		this._fixCollisions(node);
		this._packNodes();
		this._notify();
		return node;
	};

	GridStackEngine.prototype.removeNode = function (node, detachNode)
	{
		detachNode = typeof detachNode === 'undefined' ? true : detachNode;
		this._removedNodes.push(_.clone(node));
		node._id = null;
		this.nodes = _.without(this.nodes, node);
		this._packNodes();
		this._notify(node, detachNode);
	};

	GridStackEngine.prototype.canMoveNode = function (node, x, y, width, height)
	{
		var hasLocked = Boolean(_.find(this.nodes, function (n) { return n.locked; }));

		if (!this.height && !hasLocked)
		{
			return true;
		}

		var clonedNode;
		var clone = new GridStackEngine(
            this.width,
            null,
            this.float,
            0,
            _.map(this.nodes, function (n)
            {
            	if (n == node)
            	{
            		clonedNode = $.extend({}, n);
            		return clonedNode;
            	}
            	return $.extend({}, n);
            }));

		if (typeof clonedNode === 'undefined')
		{
			return true;
		}

		clone.moveNode(clonedNode, x, y, width, height);

		var res = true;

		if (hasLocked)
		{
			res &= !Boolean(_.find(clone.nodes, function (n)
			{
				return n != clonedNode && Boolean(n.locked) && Boolean(n._dirty);
			}));
		}
		if (this.height)
		{
			res &= clone.getGridHeight() <= this.height;
		}

		return res;
	};

	GridStackEngine.prototype.canBePlacedWithRespectToHeight = function (node)
	{
		if (!this.height)
		{
			return true;
		}

		var clone = new GridStackEngine(
            this.width,
            null,
            this.float,
            0,
            _.map(this.nodes, function (n) { return $.extend({}, n); }));
		clone.addNode(node);
		return clone.getGridHeight() <= this.height;
	};

	GridStackEngine.prototype.moveNode = function (node, x, y, width, height, noPack)
	{
		if (typeof x != 'number') { x = node.x; }
		if (typeof y != 'number') { y = node.y; }
		if (typeof width != 'number') { width = node.width; }
		if (typeof height != 'number') { height = node.height; }

		if (typeof node.maxWidth != 'undefined') { width = Math.min(width, node.maxWidth); }
		if (typeof node.maxHeight != 'undefined') { height = Math.min(height, node.maxHeight); }
		if (typeof node.minWidth != 'undefined') { width = Math.max(width, node.minWidth); }
		if (typeof node.minHeight != 'undefined') { height = Math.max(height, node.minHeight); }

		if (node.x == x && node.y == y && node.width == width && node.height == height)
		{
			return node;
		}

		var resizing = node.width != width;
		node._dirty = true;

		node.x = x;
		node.y = y;
		node.width = width;
		node.height = height;

		node = this._prepareNode(node, resizing);

		this._fixCollisions(node);
		if (!noPack)
		{
			this._packNodes();
			this._notify();
		}
		return node;
	};

	GridStackEngine.prototype.getGridHeight = function ()
	{
		return _.reduce(this.nodes, function (memo, n) { return Math.max(memo, n.y + n.height); }, 0);
	};

	GridStackEngine.prototype.beginUpdate = function (node)
	{
		_.each(this.nodes, function (n)
		{
			n._origY = n.y;
		});
		node._updating = true;
	};

	GridStackEngine.prototype.endUpdate = function ()
	{
		_.each(this.nodes, function (n)
		{
			n._origY = n.y;
		});
		var n = _.find(this.nodes, function (n) { return n._updating; });
		if (n)
		{
			n._updating = false;
		}
	};

	var GridStack = function (el, opts)
	{
		var self = this;
		var oneColumnMode, isAutoCellHeight;

		opts = opts || {};

		this.container = $(el);

		// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
		if (typeof opts.handle_class !== 'undefined')
		{
			opts.handleClass = opts.handle_class;
			obsoleteOpts('handle_class', 'handleClass');
		}
		if (typeof opts.item_class !== 'undefined')
		{
			opts.itemClass = opts.item_class;
			obsoleteOpts('item_class', 'itemClass');
		}
		if (typeof opts.placeholder_class !== 'undefined')
		{
			opts.placeholderClass = opts.placeholder_class;
			obsoleteOpts('placeholder_class', 'placeholderClass');
		}
		if (typeof opts.placeholder_text !== 'undefined')
		{
			opts.placeholderText = opts.placeholder_text;
			obsoleteOpts('placeholder_text', 'placeholderText');
		}
		if (typeof opts.cell_height !== 'undefined')
		{
			opts.cellHeight = opts.cell_height;
			obsoleteOpts('cell_height', 'cellHeight');
		}
		if (typeof opts.vertical_margin !== 'undefined')
		{
			opts.verticalMargin = opts.vertical_margin;
			obsoleteOpts('vertical_margin', 'verticalMargin');
		}
		if (typeof opts.min_width !== 'undefined')
		{
			opts.minWidth = opts.min_width;
			obsoleteOpts('min_width', 'minWidth');
		}
		if (typeof opts.static_grid !== 'undefined')
		{
			opts.staticGrid = opts.static_grid;
			obsoleteOpts('static_grid', 'staticGrid');
		}
		if (typeof opts.is_nested !== 'undefined')
		{
			opts.isNested = opts.is_nested;
			obsoleteOpts('is_nested', 'isNested');
		}
		if (typeof opts.always_show_resize_handle !== 'undefined')
		{
			opts.alwaysShowResizeHandle = opts.always_show_resize_handle;
			obsoleteOpts('always_show_resize_handle', 'alwaysShowResizeHandle');
		}
		// jscs:enable requireCamelCaseOrUpperCaseIdentifiers

		opts.itemClass = opts.itemClass || 'grid-stack-item';
		var isNested = this.container.closest('.' + opts.itemClass).length > 0;

		this.opts = _.defaults(opts || {}, {
			width: parseInt(this.container.attr('data-gs-width')) || 12,
			height: parseInt(this.container.attr('data-gs-height')) || 0,
			itemClass: 'grid-stack-item',
			placeholderClass: 'grid-stack-placeholder',
			placeholderText: '',
			handle: '.grid-stack-item-content',
			handleClass: null,
			cellHeight: 60,
			verticalMargin: 20,
			auto: true,
			minWidth: 768,
			float: false,
			staticGrid: false,
			_class: 'grid-stack-instance-' + (Math.random() * 10000).toFixed(0),
			animate: Boolean(this.container.attr('data-gs-animate')) || false,
			alwaysShowResizeHandle: opts.alwaysShowResizeHandle || false,
			resizable: _.defaults(opts.resizable || {}, {
				autoHide: !(opts.alwaysShowResizeHandle || false),
				handles: 'se'
			}),
			draggable: _.defaults(opts.draggable || {}, {
				handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) ||
                    '.grid-stack-item-content',
				scroll: false,
				appendTo: 'body'
			}),
			disableDrag: opts.disableDrag || false,
			disableResize: opts.disableResize || false,
			rtl: 'auto',
			removable: false,
			removeTimeout: 2000,
			verticalMarginUnit: 'px',
			cellHeightUnit: 'px'
		});

		if (this.opts.rtl === 'auto')
		{
			this.opts.rtl = this.container.css('direction') === 'rtl';
		}

		if (this.opts.rtl)
		{
			this.container.addClass('grid-stack-rtl');
		}

		this.opts.isNested = isNested;

		isAutoCellHeight = this.opts.cellHeight === 'auto';
		if (isAutoCellHeight)
		{
			self.cellHeight(self.cellWidth(), true);
		} else
		{
			this.cellHeight(this.opts.cellHeight, true);
		}
		this.verticalMargin(this.opts.verticalMargin, true);

		this.container.addClass(this.opts._class);

		this._setStaticClass();

		if (isNested)
		{
			this.container.addClass('grid-stack-nested');
		}

		this._initStyles();

		this.grid = new GridStackEngine(this.opts.width, function (nodes, detachNode)
		{
			detachNode = typeof detachNode === 'undefined' ? true : detachNode;
			var maxHeight = 0;
			_.each(nodes, function (n)
			{
				if (detachNode && n._id === null)
				{
					if (n.el)
					{
						n.el.remove();
					}
				} else
				{
					n.el
                        .attr('data-gs-x', n.x)
                        .attr('data-gs-y', n.y)
                        .attr('data-gs-width', n.width)
                        .attr('data-gs-height', n.height);
					maxHeight = Math.max(maxHeight, n.y + n.height);
				}
			});
			self._updateStyles(maxHeight + 10);
		}, this.opts.float, this.opts.height);

		if (this.opts.auto)
		{
			var elements = [];
			var _this = this;
			this.container.children('.' + this.opts.itemClass + ':not(.' + this.opts.placeholderClass + ')')
                .each(function (index, el)
                {
                	el = $(el);
                	elements.push({
                		el: el,
                		i: parseInt(el.attr('data-gs-x')) + parseInt(el.attr('data-gs-y')) * _this.opts.width
                	});
                });
			_.chain(elements).sortBy(function (x) { return x.i; }).each(function (i)
			{
				self._prepareElement(i.el);
			}).value();
		}

		this.setAnimation(this.opts.animate);

		this.placeholder = $(
            '<div class="' + this.opts.placeholderClass + ' ' + this.opts.itemClass + '">' +
            '<div class="placeholder-content">' + this.opts.placeholderText + '</div></div>').hide();

		this._updateContainerHeight();

		this._updateHeightsOnResize = _.throttle(function ()
		{
			self.cellHeight(self.cellWidth(), false);
		}, 100);

		this.onResizeHandler = function ()
		{
			if (isAutoCellHeight)
			{
				self._updateHeightsOnResize();
			}

			if (self._isOneColumnMode())
			{
				if (oneColumnMode)
				{
					return;
				}

				oneColumnMode = true;

				self.grid._sortNodes();
				_.each(self.grid.nodes, function (node)
				{
					self.container.append(node.el);

					if (self.opts.staticGrid)
					{
						return;
					}
					if (node.noMove || self.opts.disableDrag)
					{
						node.el.draggable('disable');
					}
					if (node.noResize || self.opts.disableResize)
					{
						node.el.resizable('disable');
					}

					node.el.trigger('resize');
				});
			} else
			{
				if (!oneColumnMode)
				{
					return;
				}

				oneColumnMode = false;

				if (self.opts.staticGrid)
				{
					return;
				}

				_.each(self.grid.nodes, function (node)
				{
					if (!node.noMove && !self.opts.disableDrag)
					{
						node.el.draggable('enable');
					}
					if (!node.noResize && !self.opts.disableResize)
					{
						node.el.resizable('enable');
					}

					node.el.trigger('resize');
				});
			}
		};

		$(window).resize(this.onResizeHandler);
		this.onResizeHandler();

		if (!self.opts.staticGrid && typeof self.opts.removable === 'string')
		{
			var trashZone = $(self.opts.removable);
			if (!trashZone.data('droppable'))
			{
				trashZone.droppable({
					accept: '.' + self.opts.itemClass
				});
			}
			trashZone
                .on('dropover', function (event, ui)
                {
                	var el = $(ui.draggable);
                	var node = el.data('_gridstack_node');
                	if (node._grid !== self)
                	{
                		return;
                	}
                	self._setupRemovingTimeout(el);
                })
                .on('dropout', function (event, ui)
                {
                	var el = $(ui.draggable);
                	var node = el.data('_gridstack_node');
                	if (node._grid !== self)
                	{
                		return;
                	}
                	self._clearRemovingTimeout(el);
                });
		}

		if (!self.opts.staticGrid && self.opts.acceptWidgets)
		{
			var draggingElement = null;

			var onDrag = function (event, ui)
			{
				var el = draggingElement;
				var node = el.data('_gridstack_node');
				var pos = self.getCellFromPixel(ui.offset, true);
				var x = Math.max(0, pos.x);
				var y = Math.max(0, pos.y);
				if (!node._added)
				{
					node._added = true;

					node.el = el;
					node.x = x;
					node.y = y;
					self.grid.cleanNodes();
					self.grid.beginUpdate(node);
					self.grid.addNode(node);

					self.container.append(self.placeholder);
					self.placeholder
                        .attr('data-gs-x', node.x)
                        .attr('data-gs-y', node.y)
                        .attr('data-gs-width', node.width)
                        .attr('data-gs-height', node.height)
                        .show();
					node.el = self.placeholder;
					node._beforeDragX = node.x;
					node._beforeDragY = node.y;

					self._updateContainerHeight();
				} else
				{
					if (!self.grid.canMoveNode(node, x, y))
					{
						return;
					}
					self.grid.moveNode(node, x, y);
					self._updateContainerHeight();
				}
			};

			$(self.container).droppable({
				accept: function (el)
				{
					el = $(el);
					var node = el.data('_gridstack_node');
					if (node && node._grid === self)
					{
						return false;
					}
					return el.is(self.opts.acceptWidgets === true ? '.grid-stack-item' : self.opts.acceptWidgets);
				},
				over: function (event, ui)
				{
					var offset = self.container.offset();
					var el = $(ui.draggable);
					var cellWidth = self.cellWidth();
					var cellHeight = self.cellHeight();
					var origNode = el.data('_gridstack_node');

					var width = origNode ? origNode.width : (Math.ceil(el.outerWidth() / cellWidth));
					var height = origNode ? origNode.height : (Math.ceil(el.outerHeight() / cellHeight));

					draggingElement = el;

					var node = self.grid._prepareNode({ width: width, height: height, _added: false, _temporary: true });
					el.data('_gridstack_node', node);
					el.data('_gridstack_node_orig', origNode);

					el.on('drag', onDrag);
				},
				out: function (event, ui)
				{
					var el = $(ui.draggable);
					el.unbind('drag', onDrag);
					var node = el.data('_gridstack_node');
					node.el = null;
					self.grid.removeNode(node);
					self.placeholder.detach();
					self._updateContainerHeight();
					el.data('_gridstack_node', el.data('_gridstack_node_orig'));
				},
				drop: function (event, ui)
				{
					self.placeholder.detach();

					var node = $(ui.draggable).data('_gridstack_node');
					node._grid = self;
					var el = $(ui.draggable).clone(false);
					el.data('_gridstack_node', node);
					$(ui.draggable).remove();
					node.el = el;
					self.placeholder.hide();
					el
                        .attr('data-gs-x', node.x)
                        .attr('data-gs-y', node.y)
                        .attr('data-gs-width', node.width)
                        .attr('data-gs-height', node.height)
                        .addClass(self.opts.itemClass)
                        .removeAttr('style')
                        .enableSelection()
                        .removeData('draggable')
                        .removeClass('ui-draggable ui-draggable-dragging ui-draggable-disabled')
                        .unbind('drag', onDrag);
					self.container.append(el);
					self._prepareElementsByNode(el, node);
					self._updateContainerHeight();
					self._triggerChangeEvent();

					self.grid.endUpdate();
				}
			});
		}
	};

	GridStack.prototype._triggerChangeEvent = function (forceTrigger)
	{
		var elements = this.grid.getDirtyNodes();
		var hasChanges = false;

		var eventParams = [];
		if (elements && elements.length)
		{
			eventParams.push(elements);
			hasChanges = true;
		}

		if (hasChanges || forceTrigger === true)
		{
			this.container.trigger('change', eventParams);
		}
	};

	GridStack.prototype._triggerAddEvent = function ()
	{
		if (this.grid._addedNodes && this.grid._addedNodes.length > 0)
		{
			this.container.trigger('added', [_.map(this.grid._addedNodes, _.clone)]);
			this.grid._addedNodes = [];
		}
	};

	GridStack.prototype._triggerRemoveEvent = function ()
	{
		if (this.grid._removedNodes && this.grid._removedNodes.length > 0)
		{
			this.container.trigger('removed', [_.map(this.grid._removedNodes, _.clone)]);
			this.grid._removedNodes = [];
		}
	};

	GridStack.prototype._initStyles = function ()
	{
		if (this._stylesId)
		{
			Utils.removeStylesheet(this._stylesId);
		}
		this._stylesId = 'gridstack-style-' + (Math.random() * 100000).toFixed();
		this._styles = Utils.createStylesheet(this._stylesId);
		if (this._styles !== null)
		{
			this._styles._max = 0;
		}
	};

	GridStack.prototype._updateStyles = function (maxHeight)
	{
		if (this._styles === null || typeof this._styles === 'undefined')
		{
			return;
		}

		var prefix = '.' + this.opts._class + ' > .' + this.opts.itemClass;
		var self = this;
		var getHeight;

		if (typeof maxHeight == 'undefined')
		{
			maxHeight = this._styles._max;
			this._initStyles();
			this._updateContainerHeight();
		}
		if (!this.opts.cellHeight)
		{ // The rest will be handled by CSS
			return;
		}
		if (this._styles._max !== 0 && maxHeight <= this._styles._max)
		{
			return;
		}

		if (!this.opts.verticalMargin || this.opts.cellHeightUnit === this.opts.verticalMarginUnit)
		{
			getHeight = function (nbRows, nbMargins)
			{
				return (self.opts.cellHeight * nbRows + self.opts.verticalMargin * nbMargins) +
                    self.opts.cellHeightUnit;
			};
		} else
		{
			getHeight = function (nbRows, nbMargins)
			{
				if (!nbRows || !nbMargins)
				{
					return (self.opts.cellHeight * nbRows + self.opts.verticalMargin * nbMargins) +
                        self.opts.cellHeightUnit;
				}
				return 'calc(' + ((self.opts.cellHeight * nbRows) + self.opts.cellHeightUnit) + ' + ' +
                    ((self.opts.verticalMargin * nbMargins) + self.opts.verticalMarginUnit) + ')';
			};
		}

		if (this._styles._max === 0)
		{
			Utils.insertCSSRule(this._styles, prefix, 'min-height: ' + getHeight(1, 0) + ';', 0);
		}

		if (maxHeight > this._styles._max)
		{
			for (var i = this._styles._max; i < maxHeight; ++i)
			{
				Utils.insertCSSRule(this._styles,
                    prefix + '[data-gs-height="' + (i + 1) + '"]',
                    'height: ' + getHeight(i + 1, i) + ';',
                    i
                );
				Utils.insertCSSRule(this._styles,
                    prefix + '[data-gs-min-height="' + (i + 1) + '"]',
                    'min-height: ' + getHeight(i + 1, i) + ';',
                    i
                );
				Utils.insertCSSRule(this._styles,
                    prefix + '[data-gs-max-height="' + (i + 1) + '"]',
                    'max-height: ' + getHeight(i + 1, i) + ';',
                    i
                );
				Utils.insertCSSRule(this._styles,
                    prefix + '[data-gs-y="' + i + '"]',
                    'top: ' + getHeight(i, i) + ';',
                    i
                );
			}
			this._styles._max = maxHeight;
		}
	};

	GridStack.prototype._updateContainerHeight = function ()
	{
		if (this.grid._updateCounter)
		{
			return;
		}
		var height = this.grid.getGridHeight();
		this.container.attr('data-gs-current-height', height);
		if (!this.opts.cellHeight)
		{
			return;
		}
		if (!this.opts.verticalMargin)
		{
			this.container.css('height', (height * (this.opts.cellHeight)) + this.opts.cellHeightUnit);
		} else if (this.opts.cellHeightUnit === this.opts.verticalMarginUnit)
		{
			this.container.css('height', (height * (this.opts.cellHeight + this.opts.verticalMargin) -
                this.opts.verticalMargin) + this.opts.cellHeightUnit);
		} else
		{
			this.container.css('height', 'calc(' + ((height * (this.opts.cellHeight)) + this.opts.cellHeightUnit) +
                ' + ' + ((height * (this.opts.verticalMargin - 1)) + this.opts.verticalMarginUnit) + ')');
		}
	};

	GridStack.prototype._isOneColumnMode = function ()
	{
		return (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) <=
            this.opts.minWidth;
	};

	GridStack.prototype._setupRemovingTimeout = function (el)
	{
		var self = this;
		var node = $(el).data('_gridstack_node');

		if (node._removeTimeout || !self.opts.removable)
		{
			return;
		}
		node._removeTimeout = setTimeout(function ()
		{
			el.addClass('grid-stack-item-removing');
			node._isAboutToRemove = true;
		}, self.opts.removeTimeout);
	};

	GridStack.prototype._clearRemovingTimeout = function (el)
	{
		var node = $(el).data('_gridstack_node');

		if (!node._removeTimeout)
		{
			return;
		}
		clearTimeout(node._removeTimeout);
		node._removeTimeout = null;
		el.removeClass('grid-stack-item-removing');
		node._isAboutToRemove = false;
	};

	GridStack.prototype._prepareElementsByNode = function (el, node)
	{
		if (typeof $.ui === 'undefined')
		{
			return;
		}
		var self = this;

		var cellWidth;
		var cellHeight;

		var dragOrResize = function (event, ui)
		{
			var x = Math.round(ui.position.left / cellWidth);
			var y = Math.floor((ui.position.top + cellHeight / 2) / cellHeight);
			var width;
			var height;

			if (event.type != 'drag')
			{
				width = Math.round(ui.size.width / cellWidth);
				height = Math.round(ui.size.height / cellHeight);
			}

			if (event.type == 'drag')
			{
				if (x < 0 || x >= self.grid.width || y < 0)
				{
					if (self.opts.removable === true)
					{
						self._setupRemovingTimeout(el);
					}

					x = node._beforeDragX;
					y = node._beforeDragY;

					self.placeholder.detach();
					self.placeholder.hide();
					self.grid.removeNode(node);
					self._updateContainerHeight();

					node._temporaryRemoved = true;
				} else
				{
					self._clearRemovingTimeout(el);

					if (node._temporaryRemoved)
					{
						self.grid.addNode(node);
						self.placeholder
                            .attr('data-gs-x', x)
                            .attr('data-gs-y', y)
                            .attr('data-gs-width', width)
                            .attr('data-gs-height', height)
                            .show();
						self.container.append(self.placeholder);
						node.el = self.placeholder;
						node._temporaryRemoved = false;
					}
				}
			} else if (event.type == 'resize')
			{
				if (x < 0)
				{
					return;
				}
			}

			if (!self.grid.canMoveNode(node, x, y, width, height))
			{
				return;
			}
			self.grid.moveNode(node, x, y, width, height);
			self._updateContainerHeight();
		};

		var onStartMoving = function (event, ui)
		{
			self.container.append(self.placeholder);
			var o = $(this);
			self.grid.cleanNodes();
			self.grid.beginUpdate(node);
			cellWidth = self.cellWidth();
			var strictCellHeight = Math.ceil(o.outerHeight() / o.attr('data-gs-height'));
			cellHeight = self.container.height() / parseInt(self.container.attr('data-gs-current-height'));
			cellHeight = strictCellHeight;
			self.placeholder
                .attr('data-gs-x', o.attr('data-gs-x'))
                .attr('data-gs-y', o.attr('data-gs-y'))
                .attr('data-gs-width', o.attr('data-gs-width'))
                .attr('data-gs-height', o.attr('data-gs-height'))
                .show();
			node.el = self.placeholder;
			node._beforeDragX = node.x;
			node._beforeDragY = node.y;

			el.resizable('option', 'minWidth', cellWidth * (node.minWidth || 1));
			el.resizable('option', 'minHeight', strictCellHeight * (node.minHeight || 1));

			if (event.type == 'resizestart')
			{
				o.find('.grid-stack-item').trigger('resizestart');
			}
		};

		var onEndMoving = function (event, ui)
		{
			var o = $(this);
			if (!o.data('_gridstack_node'))
			{
				return;
			}

			var forceNotify = false;
			self.placeholder.detach();
			node.el = o;
			self.placeholder.hide();

			if (node._isAboutToRemove)
			{
				forceNotify = true;
				el.removeData('_gridstack_node');
				el.remove();
			} else
			{
				self._clearRemovingTimeout(el);
				if (!node._temporaryRemoved)
				{
					o
                        .attr('data-gs-x', node.x)
                        .attr('data-gs-y', node.y)
                        .attr('data-gs-width', node.width)
                        .attr('data-gs-height', node.height)
                        .removeAttr('style');
				} else
				{
					o
                        .attr('data-gs-x', node._beforeDragX)
                        .attr('data-gs-y', node._beforeDragY)
                        .attr('data-gs-width', node.width)
                        .attr('data-gs-height', node.height)
                        .removeAttr('style');
					node.x = node._beforeDragX;
					node.y = node._beforeDragY;
					self.grid.addNode(node);
				}
			}
			self._updateContainerHeight();
			self._triggerChangeEvent(forceNotify);

			self.grid.endUpdate();

			var nestedGrids = o.find('.grid-stack');
			if (nestedGrids.length && event.type == 'resizestop')
			{
				nestedGrids.each(function (index, el)
				{
					$(el).data('gridstack').onResizeHandler();
				});
				o.find('.grid-stack-item').trigger('resizestop');
			}
		};

		el
            .draggable(_.extend({}, this.opts.draggable, {
            	containment: this.opts.isNested ? this.container.parent() : null,
            	start: onStartMoving,
            	stop: onEndMoving,
            	drag: dragOrResize
            }))
            .resizable(_.extend({}, this.opts.resizable, {
            	start: onStartMoving,
            	stop: onEndMoving,
            	resize: dragOrResize
            }));

		if (node.noMove || this._isOneColumnMode() || this.opts.disableDrag)
		{
			el.draggable('disable');
		}

		if (node.noResize || this._isOneColumnMode() || this.opts.disableResize)
		{
			el.resizable('disable');
		}

		el.attr('data-gs-locked', node.locked ? 'yes' : null);
	};

	GridStack.prototype._prepareElement = function (el, triggerAddEvent)
	{
		triggerAddEvent = typeof triggerAddEvent != 'undefined' ? triggerAddEvent : false;
		var self = this;
		el = $(el);

		el.addClass(this.opts.itemClass);
		var node = self.grid.addNode({
			x: el.attr('data-gs-x'),
			y: el.attr('data-gs-y'),
			width: el.attr('data-gs-width'),
			height: el.attr('data-gs-height'),
			maxWidth: el.attr('data-gs-max-width'),
			minWidth: el.attr('data-gs-min-width'),
			maxHeight: el.attr('data-gs-max-height'),
			minHeight: el.attr('data-gs-min-height'),
			autoPosition: Utils.toBool(el.attr('data-gs-auto-position')),
			noResize: Utils.toBool(el.attr('data-gs-no-resize')),
			noMove: Utils.toBool(el.attr('data-gs-no-move')),
			locked: Utils.toBool(el.attr('data-gs-locked')),
			el: el,
			id: el.attr('data-gs-id'),
			_grid: self
		}, triggerAddEvent);
		el.data('_gridstack_node', node);

		this._prepareElementsByNode(el, node);
	};

	GridStack.prototype.setAnimation = function (enable)
	{
		if (enable)
		{
			this.container.addClass('grid-stack-animate');
		} else
		{
			this.container.removeClass('grid-stack-animate');
		}
	};

	GridStack.prototype.addWidget = function (el, x, y, width, height, autoPosition, minWidth, maxWidth,
        minHeight, maxHeight, id)
	{
		el = $(el);
		if (typeof x != 'undefined') { el.attr('data-gs-x', x); }
		if (typeof y != 'undefined') { el.attr('data-gs-y', y); }
		if (typeof width != 'undefined') { el.attr('data-gs-width', width); }
		if (typeof height != 'undefined') { el.attr('data-gs-height', height); }
		if (typeof autoPosition != 'undefined') { el.attr('data-gs-auto-position', autoPosition ? 'yes' : null); }
		if (typeof minWidth != 'undefined') { el.attr('data-gs-min-width', minWidth); }
		if (typeof maxWidth != 'undefined') { el.attr('data-gs-max-width', maxWidth); }
		if (typeof minHeight != 'undefined') { el.attr('data-gs-min-height', minHeight); }
		if (typeof maxHeight != 'undefined') { el.attr('data-gs-max-height', maxHeight); }
		if (typeof id != 'undefined') { el.attr('data-gs-id', id); }
		this.container.append(el);
		this._prepareElement(el, true);
		this._triggerAddEvent();
		this._updateContainerHeight();
		this._triggerChangeEvent(true);

		return el;
	};

	GridStack.prototype.makeWidget = function (el)
	{
		el = $(el);
		this._prepareElement(el, true);
		this._triggerAddEvent();
		this._updateContainerHeight();
		this._triggerChangeEvent(true);

		return el;
	};

	GridStack.prototype.willItFit = function (x, y, width, height, autoPosition)
	{
		var node = { x: x, y: y, width: width, height: height, autoPosition: autoPosition };
		return this.grid.canBePlacedWithRespectToHeight(node);
	};

	GridStack.prototype.removeWidget = function (el, detachNode)
	{
		detachNode = typeof detachNode === 'undefined' ? true : detachNode;
		el = $(el);
		var node = el.data('_gridstack_node');

		// For Meteor support: https://github.com/troolee/gridstack.js/pull/272
		if (!node)
		{
			node = this.grid.getNodeDataByDOMEl(el);
		}

		this.grid.removeNode(node, detachNode);
		el.removeData('_gridstack_node');
		this._updateContainerHeight();
		if (detachNode)
		{
			el.remove();
		}
		this._triggerChangeEvent(true);
		this._triggerRemoveEvent();
	};

	GridStack.prototype.removeAll = function (detachNode)
	{
		_.each(this.grid.nodes, _.bind(function (node)
		{
			this.removeWidget(node.el, detachNode);
		}, this));
		this.grid.nodes = [];
		this._updateContainerHeight();
	};

	GridStack.prototype.destroy = function (detachGrid)
	{
		$(window).off('resize', this.onResizeHandler);
		this.disable();
		if (typeof detachGrid != 'undefined' && !detachGrid)
		{
			this.removeAll(false);
			this.container.removeData('gridstack');
		} else
		{
			this.container.remove();
		}
		Utils.removeStylesheet(this._stylesId);
		if (this.grid)
		{
			this.grid = null;
		}
	};

	GridStack.prototype.resizable = function (el, val)
	{
		var self = this;
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node == 'undefined' || node === null || typeof $.ui === 'undefined')
			{
				return;
			}

			node.noResize = !(val || false);
			if (node.noResize || self._isOneColumnMode())
			{
				el.resizable('disable');
			} else
			{
				el.resizable('enable');
			}
		});
		return this;
	};

	GridStack.prototype.movable = function (el, val)
	{
		var self = this;
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node == 'undefined' || node === null || typeof $.ui === 'undefined')
			{
				return;
			}

			node.noMove = !(val || false);
			if (node.noMove || self._isOneColumnMode())
			{
				el.draggable('disable');
				el.removeClass('ui-draggable-handle');
			} else
			{
				el.draggable('enable');
				el.addClass('ui-draggable-handle');
			}
		});
		return this;
	};

	GridStack.prototype.enableMove = function (doEnable, includeNewWidgets)
	{
		this.movable(this.container.children('.' + this.opts.itemClass), doEnable);
		if (includeNewWidgets)
		{
			this.opts.disableDrag = !doEnable;
		}
	};

	GridStack.prototype.enableResize = function (doEnable, includeNewWidgets)
	{
		this.resizable(this.container.children('.' + this.opts.itemClass), doEnable);
		if (includeNewWidgets)
		{
			this.opts.disableResize = !doEnable;
		}
	};

	GridStack.prototype.disable = function ()
	{
		this.movable(this.container.children('.' + this.opts.itemClass), false);
		this.resizable(this.container.children('.' + this.opts.itemClass), false);
		this.container.trigger('disable');
	};

	GridStack.prototype.enable = function ()
	{
		this.movable(this.container.children('.' + this.opts.itemClass), true);
		this.resizable(this.container.children('.' + this.opts.itemClass), true);
		this.container.trigger('enable');
	};

	GridStack.prototype.locked = function (el, val)
	{
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node == 'undefined' || node === null)
			{
				return;
			}

			node.locked = (val || false);
			el.attr('data-gs-locked', node.locked ? 'yes' : null);
		});
		return this;
	};

	GridStack.prototype.maxHeight = function (el, val)
	{
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node === 'undefined' || node === null)
			{
				return;
			}

			if (!isNaN(val))
			{
				node.maxHeight = (val || false);
				el.attr('data-gs-max-height', val);
			}
		});
		return this;
	};

	GridStack.prototype.minHeight = function (el, val)
	{
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node === 'undefined' || node === null)
			{
				return;
			}

			if (!isNaN(val))
			{
				node.minHeight = (val || false);
				el.attr('data-gs-min-height', val);
			}
		});
		return this;
	};

	GridStack.prototype.maxWidth = function (el, val)
	{
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node === 'undefined' || node === null)
			{
				return;
			}

			if (!isNaN(val))
			{
				node.maxWidth = (val || false);
				el.attr('data-gs-max-width', val);
			}
		});
		return this;
	};

	GridStack.prototype.minWidth = function (el, val)
	{
		el = $(el);
		el.each(function (index, el)
		{
			el = $(el);
			var node = el.data('_gridstack_node');
			if (typeof node === 'undefined' || node === null)
			{
				return;
			}

			if (!isNaN(val))
			{
				node.minWidth = (val || false);
				el.attr('data-gs-min-width', val);
			}
		});
		return this;
	};

	GridStack.prototype._updateElement = function (el, callback)
	{
		el = $(el).first();
		var node = el.data('_gridstack_node');
		if (typeof node == 'undefined' || node === null)
		{
			return;
		}

		var self = this;

		self.grid.cleanNodes();
		self.grid.beginUpdate(node);

		callback.call(this, el, node);

		self._updateContainerHeight();
		self._triggerChangeEvent();

		self.grid.endUpdate();
	};

	GridStack.prototype.resize = function (el, width, height)
	{
		this._updateElement(el, function (el, node)
		{
			width = (width !== null && typeof width != 'undefined') ? width : node.width;
			height = (height !== null && typeof height != 'undefined') ? height : node.height;

			this.grid.moveNode(node, node.x, node.y, width, height);
		});
	};

	GridStack.prototype.move = function (el, x, y)
	{
		this._updateElement(el, function (el, node)
		{
			x = (x !== null && typeof x != 'undefined') ? x : node.x;
			y = (y !== null && typeof y != 'undefined') ? y : node.y;

			this.grid.moveNode(node, x, y, node.width, node.height);
		});
	};

	GridStack.prototype.update = function (el, x, y, width, height)
	{
		this._updateElement(el, function (el, node)
		{
			x = (x !== null && typeof x != 'undefined') ? x : node.x;
			y = (y !== null && typeof y != 'undefined') ? y : node.y;
			width = (width !== null && typeof width != 'undefined') ? width : node.width;
			height = (height !== null && typeof height != 'undefined') ? height : node.height;

			this.grid.moveNode(node, x, y, width, height);
		});
	};

	GridStack.prototype.verticalMargin = function (val, noUpdate)
	{
		if (typeof val == 'undefined')
		{
			return this.opts.verticalMargin;
		}

		var heightData = Utils.parseHeight(val);

		if (this.opts.verticalMarginUnit === heightData.unit && this.opts.height === heightData.height)
		{
			return;
		}
		this.opts.verticalMarginUnit = heightData.unit;
		this.opts.verticalMargin = heightData.height;

		if (!noUpdate)
		{
			this._updateStyles();
		}
	};

	GridStack.prototype.cellHeight = function (val, noUpdate)
	{
		if (typeof val == 'undefined')
		{
			if (this.opts.cellHeight)
			{
				return this.opts.cellHeight;
			}
			var o = this.container.children('.' + this.opts.itemClass).first();
			return Math.ceil(o.outerHeight() / o.attr('data-gs-height'));
		}
		var heightData = Utils.parseHeight(val);

		if (this.opts.cellHeightUnit === heightData.heightUnit && this.opts.height === heightData.height)
		{
			return;
		}
		this.opts.cellHeightUnit = heightData.unit;
		this.opts.cellHeight = heightData.height;

		if (!noUpdate)
		{
			this._updateStyles();
		}

	};

	GridStack.prototype.cellWidth = function ()
	{
		return Math.round(this.container.outerWidth() / this.opts.width);
	};

	GridStack.prototype.getCellFromPixel = function (position, useOffset)
	{
		var containerPos = (typeof useOffset != 'undefined' && useOffset) ?
            this.container.offset() : this.container.position();
		var relativeLeft = position.left - containerPos.left;
		var relativeTop = position.top - containerPos.top;

		var columnWidth = Math.floor(this.container.width() / this.opts.width);
		var rowHeight = Math.floor(this.container.height() / parseInt(this.container.attr('data-gs-current-height')));

		return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };
	};

	GridStack.prototype.batchUpdate = function ()
	{
		this.grid.batchUpdate();
	};

	GridStack.prototype.commit = function ()
	{
		this.grid.commit();
		this._updateContainerHeight();
	};

	GridStack.prototype.isAreaEmpty = function (x, y, width, height)
	{
		return this.grid.isAreaEmpty(x, y, width, height);
	};

	GridStack.prototype.setStatic = function (staticValue)
	{
		this.opts.staticGrid = (staticValue === true);
		this.enableMove(!staticValue);
		this.enableResize(!staticValue);
		this._setStaticClass();
	};

	GridStack.prototype._setStaticClass = function ()
	{
		var staticClassName = 'grid-stack-static';

		if (this.opts.staticGrid === true)
		{
			this.container.addClass(staticClassName);
		} else
		{
			this.container.removeClass(staticClassName);
		}
	};

	GridStack.prototype._updateNodeWidths = function (oldWidth, newWidth)
	{
		this.grid._sortNodes();
		this.grid.batchUpdate();
		var node = {};
		for (var i = 0; i < this.grid.nodes.length; i++)
		{
			node = this.grid.nodes[i];
			this.update(node.el, Math.round(node.x * newWidth / oldWidth), undefined,
                Math.round(node.width * newWidth / oldWidth), undefined);
		}
		this.grid.commit();
	};

	GridStack.prototype.setGridWidth = function (gridWidth, doNotPropagate)
	{
		this.container.removeClass('grid-stack-' + this.opts.width);
		if (doNotPropagate !== true)
		{
			this._updateNodeWidths(this.opts.width, gridWidth);
		}
		this.opts.width = gridWidth;
		this.grid.width = gridWidth;
		this.container.addClass('grid-stack-' + gridWidth);
	};

	// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
	GridStackEngine.prototype.batch_update = obsolete(GridStackEngine.prototype.batchUpdate);
	GridStackEngine.prototype._fix_collisions = obsolete(GridStackEngine.prototype._fixCollisions,
        '_fix_collisions', '_fixCollisions');
	GridStackEngine.prototype.is_area_empty = obsolete(GridStackEngine.prototype.isAreaEmpty,
        'is_area_empty', 'isAreaEmpty');
	GridStackEngine.prototype._sort_nodes = obsolete(GridStackEngine.prototype._sortNodes,
        '_sort_nodes', '_sortNodes');
	GridStackEngine.prototype._pack_nodes = obsolete(GridStackEngine.prototype._packNodes,
        '_pack_nodes', '_packNodes');
	GridStackEngine.prototype._prepare_node = obsolete(GridStackEngine.prototype._prepareNode,
        '_prepare_node', '_prepareNode');
	GridStackEngine.prototype.clean_nodes = obsolete(GridStackEngine.prototype.cleanNodes,
        'clean_nodes', 'cleanNodes');
	GridStackEngine.prototype.get_dirty_nodes = obsolete(GridStackEngine.prototype.getDirtyNodes,
        'get_dirty_nodes', 'getDirtyNodes');
	GridStackEngine.prototype.add_node = obsolete(GridStackEngine.prototype.addNode,
        'add_node', 'addNode, ');
	GridStackEngine.prototype.remove_node = obsolete(GridStackEngine.prototype.removeNode,
        'remove_node', 'removeNode');
	GridStackEngine.prototype.can_move_node = obsolete(GridStackEngine.prototype.canMoveNode,
        'can_move_node', 'canMoveNode');
	GridStackEngine.prototype.move_node = obsolete(GridStackEngine.prototype.moveNode,
        'move_node', 'moveNode');
	GridStackEngine.prototype.get_grid_height = obsolete(GridStackEngine.prototype.getGridHeight,
        'get_grid_height', 'getGridHeight');
	GridStackEngine.prototype.begin_update = obsolete(GridStackEngine.prototype.beginUpdate,
        'begin_update', 'beginUpdate');
	GridStackEngine.prototype.end_update = obsolete(GridStackEngine.prototype.endUpdate,
        'end_update', 'endUpdate');
	GridStackEngine.prototype.can_be_placed_with_respect_to_height =
        obsolete(GridStackEngine.prototype.canBePlacedWithRespectToHeight,
        'can_be_placed_with_respect_to_height', 'canBePlacedWithRespectToHeight');
	GridStack.prototype._trigger_change_event = obsolete(GridStack.prototype._triggerChangeEvent,
        '_trigger_change_event', '_triggerChangeEvent');
	GridStack.prototype._init_styles = obsolete(GridStack.prototype._initStyles,
        '_init_styles', '_initStyles');
	GridStack.prototype._update_styles = obsolete(GridStack.prototype._updateStyles,
        '_update_styles', '_updateStyles');
	GridStack.prototype._update_container_height = obsolete(GridStack.prototype._updateContainerHeight,
        '_update_container_height', '_updateContainerHeight');
	GridStack.prototype._is_one_column_mode = obsolete(GridStack.prototype._isOneColumnMode,
        '_is_one_column_mode', '_isOneColumnMode');
	GridStack.prototype._prepare_element = obsolete(GridStack.prototype._prepareElement,
        '_prepare_element', '_prepareElement');
	GridStack.prototype.set_animation = obsolete(GridStack.prototype.setAnimation,
        'set_animation', 'setAnimation');
	GridStack.prototype.add_widget = obsolete(GridStack.prototype.addWidget,
        'add_widget', 'addWidget');
	GridStack.prototype.make_widget = obsolete(GridStack.prototype.makeWidget,
        'make_widget', 'makeWidget');
	GridStack.prototype.will_it_fit = obsolete(GridStack.prototype.willItFit,
        'will_it_fit', 'willItFit');
	GridStack.prototype.remove_widget = obsolete(GridStack.prototype.removeWidget,
        'remove_widget', 'removeWidget');
	GridStack.prototype.remove_all = obsolete(GridStack.prototype.removeAll,
        'remove_all', 'removeAll');
	GridStack.prototype.min_height = obsolete(GridStack.prototype.minHeight,
        'min_height', 'minHeight');
	GridStack.prototype.min_width = obsolete(GridStack.prototype.minWidth,
        'min_width', 'minWidth');
	GridStack.prototype._update_element = obsolete(GridStack.prototype._updateElement,
        '_update_element', '_updateElement');
	GridStack.prototype.cell_height = obsolete(GridStack.prototype.cellHeight,
        'cell_height', 'cellHeight');
	GridStack.prototype.cell_width = obsolete(GridStack.prototype.cellWidth,
        'cell_width', 'cellWidth');
	GridStack.prototype.get_cell_from_pixel = obsolete(GridStack.prototype.getCellFromPixel,
        'get_cell_from_pixel', 'getCellFromPixel');
	GridStack.prototype.batch_update = obsolete(GridStack.prototype.batchUpdate,
        'batch_update', 'batchUpdate');
	GridStack.prototype.is_area_empty = obsolete(GridStack.prototype.isAreaEmpty,
        'is_area_empty', 'isAreaEmpty');
	GridStack.prototype.set_static = obsolete(GridStack.prototype.setStatic,
        'set_static', 'setStatic');
	GridStack.prototype._set_static_class = obsolete(GridStack.prototype._setStaticClass,
        '_set_static_class', '_setStaticClass');
	// jscs:enable requireCamelCaseOrUpperCaseIdentifiers

	scope.GridStackUI = GridStack;

	scope.GridStackUI.Utils = Utils;
	scope.GridStackUI.Engine = GridStackEngine;

	$.fn.gridstack = function (opts)
	{
		return this.each(function ()
		{
			var o = $(this);
			if (!o.data('gridstack'))
			{
				o
                    .data('gridstack', new GridStack(this, opts));
			}
		});
	};

	return scope.GridStackUI;
});]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./etc/jquery-minicolors/jquery.minicolors.js"><![CDATA[//
// jQuery MiniColors: A tiny color picker built on jQuery
//
// Developed by Cory LaViska for A Beautiful Site, LLC
//
// Licensed under the MIT license: http://opensource.org/licenses/MIT
//
(function (factory) {
  if(typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if(typeof exports === 'object') {
    // Node/CommonJS
    module.exports = factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {
  'use strict';

  // Defaults
  $.minicolors = {
    defaults: {
      animationSpeed: 50,
      animationEasing: 'swing',
      change: null,
      changeDelay: 0,
      control: 'hue',
      defaultValue: '',
      format: 'hex',
      hide: null,
      hideSpeed: 100,
      inline: false,
      keywords: '',
      letterCase: 'lowercase',
      opacity: false,
      position: 'bottom',
      show: null,
      showSpeed: 100,
      theme: 'default',
      swatches: []
    }
  };

  // Public methods
  $.extend($.fn, {
    minicolors: function(method, data) {

      switch(method) {
      // Destroy the control
      case 'destroy':
        $(this).each(function() {
          destroy($(this));
        });
        return $(this);

      // Hide the color picker
      case 'hide':
        hide();
        return $(this);

      // Get/set opacity
      case 'opacity':
        // Getter
        if(data === undefined) {
          // Getter
          return $(this).attr('data-opacity');
        } else {
          // Setter
          $(this).each(function() {
            updateFromInput($(this).attr('data-opacity', data));
          });
        }
        return $(this);

      // Get an RGB(A) object based on the current color/opacity
      case 'rgbObject':
        return rgbObject($(this), method === 'rgbaObject');

      // Get an RGB(A) string based on the current color/opacity
      case 'rgbString':
      case 'rgbaString':
        return rgbString($(this), method === 'rgbaString');

      // Get/set settings on the fly
      case 'settings':
        if(data === undefined) {
          return $(this).data('minicolors-settings');
        } else {
          // Setter
          $(this).each(function() {
            var settings = $(this).data('minicolors-settings') || {};
            destroy($(this));
            $(this).minicolors($.extend(true, settings, data));
          });
        }
        return $(this);

      // Show the color picker
      case 'show':
        show($(this).eq(0));
        return $(this);

      // Get/set the hex color value
      case 'value':
        if(data === undefined) {
          // Getter
          return $(this).val();
        } else {
          // Setter
          $(this).each(function() {
            if(typeof(data) === 'object' && data !== null) {
              if(data.opacity !== undefined) {
                $(this).attr('data-opacity', keepWithin(data.opacity, 0, 1));
              }
              if(data.color) {
                $(this).val(data.color);
              }
            } else {
              $(this).val(data);
            }
            updateFromInput($(this));
          });
        }
        return $(this);

      // Initializes the control
      default:
        if(method !== 'create') data = method;
        $(this).each(function() {
          init($(this), data);
        });
        return $(this);

      }

    }
  });

  // Initialize input elements
  function init(input, settings) {
    var minicolors = $('<div class="minicolors" />');
    var defaults = $.minicolors.defaults;
    var name;
    var size;
    var swatches;
    var swatch;
    var panel;
    var i;

    // Do nothing if already initialized
    if(input.data('minicolors-initialized')) return;

    // Handle settings
    settings = $.extend(true, {}, defaults, settings);

    // The wrapper
    minicolors
    .addClass('minicolors-theme-' + settings.theme)
    .toggleClass('minicolors-with-opacity', settings.opacity);

    // Custom positioning
    if(settings.position !== undefined) {
      $.each(settings.position.split(' '), function() {
        minicolors.addClass('minicolors-position-' + this);
      });
    }

    // Input size
    if(settings.format === 'rgb') {
      size = settings.opacity ? '25' : '20';
    } else {
      size = settings.keywords ? '11' : '7';
    }

    // The input
    input
    .addClass('minicolors-input')
    .data('minicolors-initialized', false)
    .data('minicolors-settings', settings)
    .prop('size', size)
    .wrap(minicolors)
    .after(
      '<div class="minicolors-panel minicolors-slider-' + settings.control + '">' +
      '<div class="minicolors-slider minicolors-sprite">' +
      '<div class="minicolors-picker"></div>' +
      '</div>' +
      '<div class="minicolors-opacity-slider minicolors-sprite">' +
      '<div class="minicolors-picker"></div>' +
      '</div>' +
      '<div class="minicolors-grid minicolors-sprite">' +
      '<div class="minicolors-grid-inner"></div>' +
      '<div class="minicolors-picker"><div></div></div>' +
      '</div>' +
      '</div>'
    );

    // The swatch
    if(!settings.inline) {
      input.after('<span class="minicolors-swatch minicolors-sprite minicolors-input-swatch"><span class="minicolors-swatch-color"></span></span>');
      input.next('.minicolors-input-swatch').on('click', function(event) {
        event.preventDefault();
        input.focus();
      });
    }

    // Prevent text selection in IE
    panel = input.parent().find('.minicolors-panel');
    panel.on('selectstart', function() { return false; }).end();

    // Swatches
    if(settings.swatches && settings.swatches.length !== 0) {
      panel.addClass('minicolors-with-swatches');
      swatches = $('<ul class="minicolors-swatches"></ul>')
      .appendTo(panel);
      for(i = 0; i < settings.swatches.length; ++i) {
        // allow for custom objects as swatches
        if($.type(settings.swatches[i]) === "object") {
          name = settings.swatches[i].name;
          swatch = settings.swatches[i].color;
        } else {
          name = '';
          swatch = settings.swatches[i];
        }
        swatch = isRgb(swatch) ? parseRgb(swatch, true) : hex2rgb(parseHex(swatch, true));
        $('<li class="minicolors-swatch minicolors-sprite"><span class="minicolors-swatch-color" title="' + name + '"></span></li>')
        .appendTo(swatches)
        .data('swatch-color', settings.swatches[i])
        .find('.minicolors-swatch-color')
        .css({
          backgroundColor: rgb2hex(swatch),
          opacity: swatch.a
        });
        settings.swatches[i] = swatch;
      }
    }

    // Inline controls
    if(settings.inline) input.parent().addClass('minicolors-inline');

    updateFromInput(input, false);

    input.data('minicolors-initialized', true);
  }

  // Returns the input back to its original state
  function destroy(input) {
    var minicolors = input.parent();

    // Revert the input element
    input
      .removeData('minicolors-initialized')
      .removeData('minicolors-settings')
      .removeProp('size')
      .removeClass('minicolors-input');

    // Remove the wrap and destroy whatever remains
    minicolors.before(input).remove();
  }

  // Shows the specified dropdown panel
  function show(input) {
    var minicolors = input.parent();
    var panel = minicolors.find('.minicolors-panel');
    var settings = input.data('minicolors-settings');

    // Do nothing if uninitialized, disabled, inline, or already open
    if(
      !input.data('minicolors-initialized') ||
      input.prop('disabled') ||
      minicolors.hasClass('minicolors-inline') ||
      minicolors.hasClass('minicolors-focus')
    ) return;

    hide();

    minicolors.addClass('minicolors-focus');
    panel
    .stop(true, true)
    .fadeIn(settings.showSpeed, function() {
      if(settings.show) settings.show.call(input.get(0));
    });
  }

  // Hides all dropdown panels
  function hide() {
    $('.minicolors-focus').each(function() {
      var minicolors = $(this);
      var input = minicolors.find('.minicolors-input');
      var panel = minicolors.find('.minicolors-panel');
      var settings = input.data('minicolors-settings');

      panel.fadeOut(settings.hideSpeed, function() {
        if(settings.hide) settings.hide.call(input.get(0));
        minicolors.removeClass('minicolors-focus');
      });

    });
  }

  // Moves the selected picker
  function move(target, event, animate) {
    var input = target.parents('.minicolors').find('.minicolors-input');
    var settings = input.data('minicolors-settings');
    var picker = target.find('[class$=-picker]');
    var offsetX = target.offset().left;
    var offsetY = target.offset().top;
    var x = Math.round(event.pageX - offsetX);
    var y = Math.round(event.pageY - offsetY);
    var duration = animate ? settings.animationSpeed : 0;
    var wx, wy, r, phi;

    // Touch support
    if(event.originalEvent.changedTouches) {
      x = event.originalEvent.changedTouches[0].pageX - offsetX;
      y = event.originalEvent.changedTouches[0].pageY - offsetY;
    }

    // Constrain picker to its container
    if(x < 0) x = 0;
    if(y < 0) y = 0;
    if(x > target.width()) x = target.width();
    if(y > target.height()) y = target.height();

    // Constrain color wheel values to the wheel
    if(target.parent().is('.minicolors-slider-wheel') && picker.parent().is('.minicolors-grid')) {
      wx = 75 - x;
      wy = 75 - y;
      r = Math.sqrt(wx * wx + wy * wy);
      phi = Math.atan2(wy, wx);
      if(phi < 0) phi += Math.PI * 2;
      if(r > 75) {
        r = 75;
        x = 75 - (75 * Math.cos(phi));
        y = 75 - (75 * Math.sin(phi));
      }
      x = Math.round(x);
      y = Math.round(y);
    }

    // Move the picker
    if(target.is('.minicolors-grid')) {
      picker
      .stop(true)
      .animate({
        top: y + 'px',
        left: x + 'px'
      }, duration, settings.animationEasing, function() {
        updateFromControl(input, target);
      });
    } else {
      picker
      .stop(true)
      .animate({
        top: y + 'px'
      }, duration, settings.animationEasing, function() {
        updateFromControl(input, target);
      });
    }
  }

  // Sets the input based on the color picker values
  function updateFromControl(input, target) {

    function getCoords(picker, container) {
      var left, top;
      if(!picker.length || !container) return null;
      left = picker.offset().left;
      top = picker.offset().top;

      return {
        x: left - container.offset().left + (picker.outerWidth() / 2),
        y: top - container.offset().top + (picker.outerHeight() / 2)
      };
    }

    var hue, saturation, brightness, x, y, r, phi;
    var hex = input.val();
    var opacity = input.attr('data-opacity');

    // Helpful references
    var minicolors = input.parent();
    var settings = input.data('minicolors-settings');
    var swatch = minicolors.find('.minicolors-input-swatch');

    // Panel objects
    var grid = minicolors.find('.minicolors-grid');
    var slider = minicolors.find('.minicolors-slider');
    var opacitySlider = minicolors.find('.minicolors-opacity-slider');

    // Picker objects
    var gridPicker = grid.find('[class$=-picker]');
    var sliderPicker = slider.find('[class$=-picker]');
    var opacityPicker = opacitySlider.find('[class$=-picker]');

    // Picker positions
    var gridPos = getCoords(gridPicker, grid);
    var sliderPos = getCoords(sliderPicker, slider);
    var opacityPos = getCoords(opacityPicker, opacitySlider);

    // Handle colors
    if(target.is('.minicolors-grid, .minicolors-slider, .minicolors-opacity-slider')) {

      // Determine HSB values
      switch(settings.control) {
      case 'wheel':
        // Calculate hue, saturation, and brightness
        x = (grid.width() / 2) - gridPos.x;
        y = (grid.height() / 2) - gridPos.y;
        r = Math.sqrt(x * x + y * y);
        phi = Math.atan2(y, x);
        if(phi < 0) phi += Math.PI * 2;
        if(r > 75) {
          r = 75;
          gridPos.x = 69 - (75 * Math.cos(phi));
          gridPos.y = 69 - (75 * Math.sin(phi));
        }
        saturation = keepWithin(r / 0.75, 0, 100);
        hue = keepWithin(phi * 180 / Math.PI, 0, 360);
        brightness = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);
        hex = hsb2hex({
          h: hue,
          s: saturation,
          b: brightness
        });

        // Update UI
        slider.css('backgroundColor', hsb2hex({ h: hue, s: saturation, b: 100 }));
        break;

      case 'saturation':
        // Calculate hue, saturation, and brightness
        hue = keepWithin(parseInt(gridPos.x * (360 / grid.width()), 10), 0, 360);
        saturation = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);
        brightness = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);
        hex = hsb2hex({
          h: hue,
          s: saturation,
          b: brightness
        });

        // Update UI
        slider.css('backgroundColor', hsb2hex({ h: hue, s: 100, b: brightness }));
        minicolors.find('.minicolors-grid-inner').css('opacity', saturation / 100);
        break;

      case 'brightness':
        // Calculate hue, saturation, and brightness
        hue = keepWithin(parseInt(gridPos.x * (360 / grid.width()), 10), 0, 360);
        saturation = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);
        brightness = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);
        hex = hsb2hex({
          h: hue,
          s: saturation,
          b: brightness
        });

        // Update UI
        slider.css('backgroundColor', hsb2hex({ h: hue, s: saturation, b: 100 }));
        minicolors.find('.minicolors-grid-inner').css('opacity', 1 - (brightness / 100));
        break;

      default:
        // Calculate hue, saturation, and brightness
        hue = keepWithin(360 - parseInt(sliderPos.y * (360 / slider.height()), 10), 0, 360);
        saturation = keepWithin(Math.floor(gridPos.x * (100 / grid.width())), 0, 100);
        brightness = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);
        hex = hsb2hex({
          h: hue,
          s: saturation,
          b: brightness
        });

        // Update UI
        grid.css('backgroundColor', hsb2hex({ h: hue, s: 100, b: 100 }));
        break;
      }

      // Handle opacity
      if(settings.opacity) {
        opacity = parseFloat(1 - (opacityPos.y / opacitySlider.height())).toFixed(2);
      } else {
        opacity = 1;
      }

      updateInput(input, hex, opacity);
    }
    else {
      // Set swatch color
      swatch.find('span').css({
        backgroundColor: hex,
        opacity: opacity
      });

      // Handle change event
      doChange(input, hex, opacity);
    }
  }

  // Sets the value of the input and does the appropriate conversions
  // to respect settings, also updates the swatch
  function updateInput(input, value, opacity) {
    var rgb;

    // Helpful references
    var minicolors = input.parent();
    var settings = input.data('minicolors-settings');
    var swatch = minicolors.find('.minicolors-input-swatch');

    if(settings.opacity) input.attr('data-opacity', opacity);

    // Set color string
    if(settings.format === 'rgb') {
      // Returns RGB(A) string

      // Checks for input format and does the conversion
      if(isRgb(value)) {
        rgb = parseRgb(value, true);
      }
      else {
        rgb = hex2rgb(parseHex(value, true));
      }

      opacity = input.attr('data-opacity') === '' ? 1 : keepWithin(parseFloat(input.attr('data-opacity')).toFixed(2), 0, 1);
      if(isNaN(opacity) || !settings.opacity) opacity = 1;

      if(input.minicolors('rgbObject').a <= 1 && rgb && settings.opacity) {
        // Set RGBA string if alpha
        value = 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + parseFloat(opacity) + ')';
      } else {
        // Set RGB string (alpha = 1)
        value = 'rgb(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ')';
      }
    } else {
      // Returns hex color

      // Checks for input format and does the conversion
      if(isRgb(value)) {
        value = rgbString2hex(value);
      }

      value = convertCase(value, settings.letterCase);
    }

    // Update value from picker
    input.val(value);

    // Set swatch color
    swatch.find('span').css({
      backgroundColor: value,
      opacity: opacity
    });

    // Handle change event
    doChange(input, value, opacity);
  }

  // Sets the color picker values from the input
  function updateFromInput(input, preserveInputValue) {
    var hex, hsb, opacity, keywords, alpha, value, x, y, r, phi;

    // Helpful references
    var minicolors = input.parent();
    var settings = input.data('minicolors-settings');
    var swatch = minicolors.find('.minicolors-input-swatch');

    // Panel objects
    var grid = minicolors.find('.minicolors-grid');
    var slider = minicolors.find('.minicolors-slider');
    var opacitySlider = minicolors.find('.minicolors-opacity-slider');

    // Picker objects
    var gridPicker = grid.find('[class$=-picker]');
    var sliderPicker = slider.find('[class$=-picker]');
    var opacityPicker = opacitySlider.find('[class$=-picker]');

    // Determine hex/HSB values
    if(isRgb(input.val())) {
      // If input value is a rgb(a) string, convert it to hex color and update opacity
      hex = rgbString2hex(input.val());
      alpha = keepWithin(parseFloat(getAlpha(input.val())).toFixed(2), 0, 1);
      if(alpha) {
        input.attr('data-opacity', alpha);
      }
    } else {
      hex = convertCase(parseHex(input.val(), true), settings.letterCase);
    }

    if(!hex){
      hex = convertCase(parseInput(settings.defaultValue, true), settings.letterCase);
    }
    hsb = hex2hsb(hex);

    // Get array of lowercase keywords
    keywords = !settings.keywords ? [] : $.map(settings.keywords.split(','), function(a) {
      return $.trim(a.toLowerCase());
    });

    // Set color string
    if(input.val() !== '' && $.inArray(input.val().toLowerCase(), keywords) > -1) {
      value = convertCase(input.val());
    } else {
      value = isRgb(input.val()) ? parseRgb(input.val()) : hex;
    }

    // Update input value
    if(!preserveInputValue) input.val(value);

    // Determine opacity value
    if(settings.opacity) {
      // Get from data-opacity attribute and keep within 0-1 range
      opacity = input.attr('data-opacity') === '' ? 1 : keepWithin(parseFloat(input.attr('data-opacity')).toFixed(2), 0, 1);
      if(isNaN(opacity)) opacity = 1;
      input.attr('data-opacity', opacity);
      swatch.find('span').css('opacity', opacity);

      // Set opacity picker position
      y = keepWithin(opacitySlider.height() - (opacitySlider.height() * opacity), 0, opacitySlider.height());
      opacityPicker.css('top', y + 'px');
    }

    // Set opacity to zero if input value is transparent
    if(input.val().toLowerCase() === 'transparent') {
      swatch.find('span').css('opacity', 0);
    }

    // Update swatch
    swatch.find('span').css('backgroundColor', hex);

    // Determine picker locations
    switch(settings.control) {
    case 'wheel':
      // Set grid position
      r = keepWithin(Math.ceil(hsb.s * 0.75), 0, grid.height() / 2);
      phi = hsb.h * Math.PI / 180;
      x = keepWithin(75 - Math.cos(phi) * r, 0, grid.width());
      y = keepWithin(75 - Math.sin(phi) * r, 0, grid.height());
      gridPicker.css({
        top: y + 'px',
        left: x + 'px'
      });

      // Set slider position
      y = 150 - (hsb.b / (100 / grid.height()));
      if(hex === '') y = 0;
      sliderPicker.css('top', y + 'px');

      // Update panel color
      slider.css('backgroundColor', hsb2hex({ h: hsb.h, s: hsb.s, b: 100 }));
      break;

    case 'saturation':
      // Set grid position
      x = keepWithin((5 * hsb.h) / 12, 0, 150);
      y = keepWithin(grid.height() - Math.ceil(hsb.b / (100 / grid.height())), 0, grid.height());
      gridPicker.css({
        top: y + 'px',
        left: x + 'px'
      });

      // Set slider position
      y = keepWithin(slider.height() - (hsb.s * (slider.height() / 100)), 0, slider.height());
      sliderPicker.css('top', y + 'px');

      // Update UI
      slider.css('backgroundColor', hsb2hex({ h: hsb.h, s: 100, b: hsb.b }));
      minicolors.find('.minicolors-grid-inner').css('opacity', hsb.s / 100);
      break;

    case 'brightness':
      // Set grid position
      x = keepWithin((5 * hsb.h) / 12, 0, 150);
      y = keepWithin(grid.height() - Math.ceil(hsb.s / (100 / grid.height())), 0, grid.height());
      gridPicker.css({
        top: y + 'px',
        left: x + 'px'
      });

      // Set slider position
      y = keepWithin(slider.height() - (hsb.b * (slider.height() / 100)), 0, slider.height());
      sliderPicker.css('top', y + 'px');

      // Update UI
      slider.css('backgroundColor', hsb2hex({ h: hsb.h, s: hsb.s, b: 100 }));
      minicolors.find('.minicolors-grid-inner').css('opacity', 1 - (hsb.b / 100));
      break;

    default:
      // Set grid position
      x = keepWithin(Math.ceil(hsb.s / (100 / grid.width())), 0, grid.width());
      y = keepWithin(grid.height() - Math.ceil(hsb.b / (100 / grid.height())), 0, grid.height());
      gridPicker.css({
        top: y + 'px',
        left: x + 'px'
      });

      // Set slider position
      y = keepWithin(slider.height() - (hsb.h / (360 / slider.height())), 0, slider.height());
      sliderPicker.css('top', y + 'px');

      // Update panel color
      grid.css('backgroundColor', hsb2hex({ h: hsb.h, s: 100, b: 100 }));
      break;
    }

    // Fire change event, but only if minicolors is fully initialized
    if(input.data('minicolors-initialized')) {
      doChange(input, value, opacity);
    }
  }

  // Runs the change and changeDelay callbacks
  function doChange(input, value, opacity) {
    var settings = input.data('minicolors-settings');
    var lastChange = input.data('minicolors-lastChange');
    var obj, sel, i;

    // Only run if it actually changed
    if(!lastChange || lastChange.value !== value || lastChange.opacity !== opacity) {

      // Remember last-changed value
      input.data('minicolors-lastChange', {
        value: value,
        opacity: opacity
      });

      // Check and select applicable swatch
      if(settings.swatches && settings.swatches.length !== 0) {
        if(!isRgb(value)) {
          obj = hex2rgb(value);
        }
        else {
          obj = parseRgb(value, true);
        }
        sel = -1;
        for(i = 0; i < settings.swatches.length; ++i) {
          if(obj.r === settings.swatches[i].r && obj.g === settings.swatches[i].g && obj.b === settings.swatches[i].b && obj.a === settings.swatches[i].a) {
            sel = i;
            break;
          }
        }

        input.parent().find('.minicolors-swatches .minicolors-swatch').removeClass('selected');
        if(sel !== -1) {
          input.parent().find('.minicolors-swatches .minicolors-swatch').eq(i).addClass('selected');
        }
      }

      // Fire change event
      if(settings.change) {
        if(settings.changeDelay) {
          // Call after a delay
          clearTimeout(input.data('minicolors-changeTimeout'));
          input.data('minicolors-changeTimeout', setTimeout(function() {
            settings.change.call(input.get(0), value, opacity);
          }, settings.changeDelay));
        } else {
          // Call immediately
          settings.change.call(input.get(0), value, opacity);
        }
      }
      input.trigger('change').trigger('input');
    }
  }

  // Generates an RGB(A) object based on the input's value
  function rgbObject(input) {
    var rgb,
      opacity = $(input).attr('data-opacity');
    if( isRgb($(input).val()) ) {
      rgb = parseRgb($(input).val(), true);
    } else {
      var hex = parseHex($(input).val(), true);
      rgb = hex2rgb(hex);
    }
    if( !rgb ) return null;
    if( opacity !== undefined ) $.extend(rgb, { a: parseFloat(opacity) });
    return rgb;
  }

  // Generates an RGB(A) string based on the input's value
  function rgbString(input, alpha) {
    var rgb,
      opacity = $(input).attr('data-opacity');
    if( isRgb($(input).val()) ) {
      rgb = parseRgb($(input).val(), true);
    } else {
      var hex = parseHex($(input).val(), true);
      rgb = hex2rgb(hex);
    }
    if( !rgb ) return null;
    if( opacity === undefined ) opacity = 1;
    if( alpha ) {
      return 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + parseFloat(opacity) + ')';
    } else {
      return 'rgb(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ')';
    }
  }

  // Converts to the letter case specified in settings
  function convertCase(string, letterCase) {
    return letterCase === 'uppercase' ? string.toUpperCase() : string.toLowerCase();
  }

  // Parses a string and returns a valid hex string when possible
  function parseHex(string, expand) {
    string = string.replace(/^#/g, '');
    if(!string.match(/^[A-F0-9]{3,6}/ig)) return '';
    if(string.length !== 3 && string.length !== 6) return '';
    if(string.length === 3 && expand) {
      string = string[0] + string[0] + string[1] + string[1] + string[2] + string[2];
    }
    return '#' + string;
  }

  // Parses a string and returns a valid RGB(A) string when possible
  function parseRgb(string, obj) {
    var values = string.replace(/[^\d,.]/g, '');
    var rgba = values.split(',');

    rgba[0] = keepWithin(parseInt(rgba[0], 10), 0, 255);
    rgba[1] = keepWithin(parseInt(rgba[1], 10), 0, 255);
    rgba[2] = keepWithin(parseInt(rgba[2], 10), 0, 255);
    if(rgba[3]) {
      rgba[3] = keepWithin(parseFloat(rgba[3], 10), 0, 1);
    }

    // Return RGBA object
    if( obj ) {
      if (rgba[3]) {
        return {
          r: rgba[0],
          g: rgba[1],
          b: rgba[2],
          a: rgba[3]
        };
      } else {
        return {
          r: rgba[0],
          g: rgba[1],
          b: rgba[2]
        };
      }
    }

    // Return RGBA string
    if(typeof(rgba[3]) !== 'undefined' && rgba[3] <= 1) {
      return 'rgba(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ', ' + rgba[3] + ')';
    } else {
      return 'rgb(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ')';
    }

  }

  // Parses a string and returns a valid color string when possible
  function parseInput(string, expand) {
    if(isRgb(string)) {
      // Returns a valid rgb(a) string
      return parseRgb(string);
    } else {
      return parseHex(string, expand);
    }
  }

  // Keeps value within min and max
  function keepWithin(value, min, max) {
    if(value < min) value = min;
    if(value > max) value = max;
    return value;
  }

  // Checks if a string is a valid RGB(A) string
  function isRgb(string) {
    var rgb = string.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return (rgb && rgb.length === 4) ? true : false;
  }

  // Function to get alpha from a RGB(A) string
  function getAlpha(rgba) {
    rgba = rgba.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+(\.\d{1,2})?|\.\d{1,2})[\s+]?/i);
    return (rgba && rgba.length === 6) ? rgba[4] : '1';
  }

  // Converts an HSB object to an RGB object
  function hsb2rgb(hsb) {
    var rgb = {};
    var h = Math.round(hsb.h);
    var s = Math.round(hsb.s * 255 / 100);
    var v = Math.round(hsb.b * 255 / 100);
    if(s === 0) {
      rgb.r = rgb.g = rgb.b = v;
    } else {
      var t1 = v;
      var t2 = (255 - s) * v / 255;
      var t3 = (t1 - t2) * (h % 60) / 60;
      if(h === 360) h = 0;
      if(h < 60) { rgb.r = t1; rgb.b = t2; rgb.g = t2 + t3; }
      else if(h < 120) {rgb.g = t1; rgb.b = t2; rgb.r = t1 - t3; }
      else if(h < 180) {rgb.g = t1; rgb.r = t2; rgb.b = t2 + t3; }
      else if(h < 240) {rgb.b = t1; rgb.r = t2; rgb.g = t1 - t3; }
      else if(h < 300) {rgb.b = t1; rgb.g = t2; rgb.r = t2 + t3; }
      else if(h < 360) {rgb.r = t1; rgb.g = t2; rgb.b = t1 - t3; }
      else { rgb.r = 0; rgb.g = 0; rgb.b = 0; }
    }
    return {
      r: Math.round(rgb.r),
      g: Math.round(rgb.g),
      b: Math.round(rgb.b)
    };
  }

  // Converts an RGB string to a hex string
  function rgbString2hex(rgb){
    rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return (rgb && rgb.length === 4) ? '#' +
    ('0' + parseInt(rgb[1],10).toString(16)).slice(-2) +
    ('0' + parseInt(rgb[2],10).toString(16)).slice(-2) +
    ('0' + parseInt(rgb[3],10).toString(16)).slice(-2) : '';
  }

  // Converts an RGB object to a hex string
  function rgb2hex(rgb) {
    var hex = [
      rgb.r.toString(16),
      rgb.g.toString(16),
      rgb.b.toString(16)
    ];
    $.each(hex, function(nr, val) {
      if(val.length === 1) hex[nr] = '0' + val;
    });
    return '#' + hex.join('');
  }

  // Converts an HSB object to a hex string
  function hsb2hex(hsb) {
    return rgb2hex(hsb2rgb(hsb));
  }

  // Converts a hex string to an HSB object
  function hex2hsb(hex) {
    var hsb = rgb2hsb(hex2rgb(hex));
    if(hsb.s === 0) hsb.h = 360;
    return hsb;
  }

  // Converts an RGB object to an HSB object
  function rgb2hsb(rgb) {
    var hsb = { h: 0, s: 0, b: 0 };
    var min = Math.min(rgb.r, rgb.g, rgb.b);
    var max = Math.max(rgb.r, rgb.g, rgb.b);
    var delta = max - min;
    hsb.b = max;
    hsb.s = max !== 0 ? 255 * delta / max : 0;
    if(hsb.s !== 0) {
      if(rgb.r === max) {
        hsb.h = (rgb.g - rgb.b) / delta;
      } else if(rgb.g === max) {
        hsb.h = 2 + (rgb.b - rgb.r) / delta;
      } else {
        hsb.h = 4 + (rgb.r - rgb.g) / delta;
      }
    } else {
      hsb.h = -1;
    }
    hsb.h *= 60;
    if(hsb.h < 0) {
      hsb.h += 360;
    }
    hsb.s *= 100/255;
    hsb.b *= 100/255;
    return hsb;
  }

  // Converts a hex string to an RGB object
  function hex2rgb(hex) {
    hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
    return {
      r: hex >> 16,
      g: (hex & 0x00FF00) >> 8,
      b: (hex & 0x0000FF)
    };
  }

  // Handle events
  $([document])
    // Hide on clicks outside of the control
    .on('mousedown.minicolors touchstart.minicolors', function(event) {
      if(!$(event.target).parents().add(event.target).hasClass('minicolors')) {
        hide();
      }
    })
    // Start moving
    .on('mousedown.minicolors touchstart.minicolors', '.minicolors-grid, .minicolors-slider, .minicolors-opacity-slider', function(event) {
      var target = $(this);
      event.preventDefault();
      $(event.delegateTarget).data('minicolors-target', target);
      move(target, event, true);
    })
    // Move pickers
    .on('mousemove.minicolors touchmove.minicolors', function(event) {
      var target = $(event.delegateTarget).data('minicolors-target');
      if(target) move(target, event);
    })
    // Stop moving
    .on('mouseup.minicolors touchend.minicolors', function() {
      $(this).removeData('minicolors-target');
    })
    // Selected a swatch
    .on('click.minicolors', '.minicolors-swatches li', function(event) {
      event.preventDefault();
      var target = $(this), input = target.parents('.minicolors').find('.minicolors-input'), color = target.data('swatch-color');
      updateInput(input, color, getAlpha(color));
      updateFromInput(input);
    })
    // Show panel when swatch is clicked
    .on('mousedown.minicolors touchstart.minicolors', '.minicolors-input-swatch', function(event) {
      var input = $(this).parent().find('.minicolors-input');
      event.preventDefault();
      show(input);
    })
    // Show on focus
    .on('focus.minicolors', '.minicolors-input', function() {
      var input = $(this);
      if(!input.data('minicolors-initialized')) return;
      show(input);
    })
    // Update value on blur
    .on('blur.minicolors', '.minicolors-input', function() {
      var input = $(this);
      var settings = input.data('minicolors-settings');
      var keywords;
      var hex;
      var rgba;
      var swatchOpacity;
      var value;

      if(!input.data('minicolors-initialized')) return;

      // Get array of lowercase keywords
      keywords = !settings.keywords ? [] : $.map(settings.keywords.split(','), function(a) {
        return $.trim(a.toLowerCase());
      });

      // Set color string
      if(input.val() !== '' && $.inArray(input.val().toLowerCase(), keywords) > -1) {
        value = input.val();
      } else {
        // Get RGBA values for easy conversion
        if(isRgb(input.val())) {
          rgba = parseRgb(input.val(), true);
        } else {
          hex = parseHex(input.val(), true);
          rgba = hex ? hex2rgb(hex) : null;
        }

        // Convert to format
        if(rgba === null) {
          value = settings.defaultValue;
        } else if(settings.format === 'rgb') {
          value = settings.opacity ?
          parseRgb('rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + input.attr('data-opacity') + ')') :
          parseRgb('rgb(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ')');
        } else {
          value = rgb2hex(rgba);
        }
      }

      // Update swatch opacity
      swatchOpacity = settings.opacity ? input.attr('data-opacity') : 1;
      if(value.toLowerCase() === 'transparent') swatchOpacity = 0;
      input
      .closest('.minicolors')
      .find('.minicolors-input-swatch > span')
      .css('opacity', swatchOpacity);

      // Set input value
      input.val(value);

      // Is it blank?
      if(input.val() === '') input.val(parseInput(settings.defaultValue, true));

      // Adjust case
      input.val(convertCase(input.val(), settings.letterCase));

    })
    // Handle keypresses
    .on('keydown.minicolors', '.minicolors-input', function(event) {
      var input = $(this);
      if(!input.data('minicolors-initialized')) return;
      switch(event.which) {
      case 9: // tab
        hide();
        break;
      case 13: // enter
      case 27: // esc
        hide();
        input.blur();
        break;
      }
    })
    // Update on keyup
    .on('keyup.minicolors', '.minicolors-input', function() {
      var input = $(this);
      if(!input.data('minicolors-initialized')) return;
      updateFromInput(input, true);
    })
    // Update on paste
    .on('paste.minicolors', '.minicolors-input', function() {
      var input = $(this);
      if(!input.data('minicolors-initialized')) return;
      setTimeout(function() {
        updateFromInput(input, true);
      }, 1);
    });
}));
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/events.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.78 $:

function ibxEventManager()
{
	if(ibx.eventMgr)
		return;

	window.addEventListener("touchstart", ibxEventManager._onTouchEvent.bind(this), {passive:false, capture:true});
	window.addEventListener("touchend", ibxEventManager._onTouchEvent, {passive:false, capture:true});
	window.addEventListener("touchmove", ibxEventManager._onTouchEvent, {passive:false, capture:true});

	window.addEventListener("keydown", ibxEventManager._onKeyDown);
	window.addEventListener("contextmenu", ibxEventManager._onContextMenu);
	window.addEventListener("touchstart", ibxEventManager._onNoScrollTouchEvent, {passive:false, capture:true});
}
ibxEventManager.noBrowserCtxMenu = true;
ibxEventManager.noBackspaceNavigate = true;
ibxEventManager.noSpaceScroll = true;
ibxEventManager.noIOSBodyScroll = false;
ibxEventManager.msCtxMenu = 500;	//context menu timer length
ibxEventManager.msDblClick = 300;	//time between touches to trigger doubleclick
ibxEventManager.msSwipe = 300;		//time for touch movement before swipe event
ibxEventManager.deltaSwipe = 30;	//distance for touch move to trigger a swipe event

ibxEventManager.createMouseEvent = function(eType, e)
{
	var touch = (e instanceof TouchEvent) ? e.touches[0] : null;
	var eLast = ((e instanceof TouchEvent) && ibxEventManager._eLast) ? ibxEventManager._eLast.touches[0] : null;
	var eInit = $.extend({}, e, touch);
	eInit.movementX = eLast ? (eInit.screenX - eLast.screenX) : 0;
	eInit.movementY = eLast ? (eInit.screenY - eLast.screenY) : 0;

	var event = new MouseEvent(eType, eInit);
	event.movementX = eInit.movementX;//for IOS...they don't allow arbitrary properties in new MouseEvent.
	event.movementY = eInit.movementY;//for IOS...they don't allow arbitrary properties in new MouseEvent.
	event.originalEvent = e;
	return event;
};

/***
 * Translate touch events into mouse events.
 */
ibxEventManager._onTouchEvent = function(e)
{
	//cancel any pending context menu by clearing the timer.
	window.clearTimeout(ibxEventManager._ctxMenuTimer);

	var eType = e.type;
	if(eType == "touchstart")
	{
		var me = ibxEventManager.createMouseEvent("mousedown", e);
		e.target.dispatchEvent(me);
		ibxEventManager._eLastTouch = e;
		ibxEventManager._ctxMenuTimer = window.setTimeout(function(e)
		{
			var me = ibxEventManager.createMouseEvent("contextmenu", e);
			e.target.dispatchEvent(me);
		}.bind(ibxEventManager, e), ibxEventManager.msCtxMenu);
	}
	else
	if(eType == "touchend")
	{
		//do mouseup
		var me = ibxEventManager.createMouseEvent("mouseup", e);
		e.target.dispatchEvent(me);

		//do click
		var me = ibxEventManager.createMouseEvent("click", e);
		e.target.dispatchEvent(me);

		//do double click
		var dt = ibxEventManager._eLastClick ? (e.timeStamp - ibxEventManager._eLastClick.timeStamp) : Infinity;
		if(dt < ibxEventManager.msDblClick)
		{
			var me = ibxEventManager.createMouseEvent("dblclick", e);
			e.target.dispatchEvent(me);
		}

		//save info, and prevent default so browser won't generate its own native mouse events.
		ibxEventManager._eLastClick = e;
		ibxEventManager._eLastTouch = null;
		ibxEventManager._hasSwiped = false;
		e.preventDefault();
	}
	else
	if(eType == "touchmove")
	{
		//do swiping
		var touch = e.touches[0];
		var tElapsed = e.timeStamp - ibxEventManager._eLastTouch.timeStamp;
		var dx = touch.clientX - ibxEventManager._eLastTouch.touches[0].clientX;
		var dy = touch.clientY - ibxEventManager._eLastTouch.touches[0].clientY;
		if(tElapsed <= ibxEventManager.msSwipe && (Math.abs(dx) >= ibxEventManager.deltaSwipe || Math.abs(dy) >= ibxEventManager.deltaSwipe))
		{
			var dir = ""
			if(dy > ibxEventManager.deltaSwipe)
				dir += "down";
			if(dy < -ibxEventManager.deltaSwipe)
				dir += "up";
			if(dx > ibxEventManager.deltaSwipe)
				dir += "right";
			if(dx < -ibxEventManager.deltaSwipe)
				dir += "left";
			
			if(dir)
			{
				var se = ibxEventManager.createMouseEvent("swipe", e);
				se.data = dir;
				ibxEventManager._hasSwiped = true;
				e.target.dispatchEvent(se);
			}
		}

		//do mouse move
		var me = ibxEventManager.createMouseEvent("mousemove", e);
		e.target.dispatchEvent(me);
	}
};

ibxEventManager._onContextMenu = function(e)
{
	if(ibxEventManager.noBrowserCtxMenu)
		e.preventDefault();
};

//[HOME-183] stop backspace from navigating
//see: https://stackoverflow.com/questions/1495219/how-can-i-prevent-the-backspace-key-from-navigating-back
ibxEventManager.isInputEventToIgnore = function(event)
{
	var ignore = true;
	var types = ["text", "password", "file", "search", "email", "number", "date", "color", "datetime", "datetime-local", "month", "range", "search", "tel", "time", "url", "week"];
	var target = $(event.target);
	var disabled = target.prop("readonly") || target.prop("disabled");

	if(!disabled && target.length)
	{
		if(target[0].isContentEditable)
			ignore = false;
		else
		if(target.is("input"))
		{
			var type = target.attr("type");
			if(type)
				type = type.toLowerCase();
			if(types.indexOf(type) > -1)
				ignore = false;
		}
		else
		if(target.is("textarea"))
			ignore = false;
	}
	return ignore;
};

ibxEventManager._onKeyDown = function(event)
{
	if((ibxEventManager.noBackspaceNavigate && (event.keyCode === $.ui.keyCode.BACKSPACE)) || (ibxEventManager.noSpaceScroll && (event.keyCode === $.ui.keyCode.SPACE)))
	{
		var ignore = ibxEventManager.isInputEventToIgnore(event);
		if(ignore)
			event.preventDefault();
		return !ignore;
	}
};

//ios has an annoying habit of attempting to scroll the body element even when it has nothing to scroll.  This stops that!
ibxEventManager._onNoScrollTouchEvent = function(e)
{
	// THIS IS NOT WORKING CORRECTLY YET...DO NOT UNCOMMENT!!!!
	// if(ibxPlatformCheck.isIOS && ibxEventManager.noIOSBodyScroll && e.target === document.body)
	// 	e.preventDefault();
};

//singleton event manager object.
ibx.eventMgr = new ibxEventManager();

//# sourceURL=events.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/selection.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.68 $:

$.widget("ibi.ibxSelectionManager", $.Widget, 
{
	options:
	{
		"type":"none",						//none - no selection, single - single selection, multi - multiple selection
		"toggleSelection":false,			//clicking on an item will select/deselect.
		"escClearSelection":true,			//clear the selection on the escape key
		"selectButtons":[0, 2],				//which buttons trigger a select 0 = left, 1 = middle, 2 = right
		"selectKeys":[13, 32],				//which keys trigger a select 13 = ENTER, 32 = SPACE
		"focusRoot":false,					//keep focus circular within this element
		"focusDefault":false,				//focus the first item in root. (can be a select pattern).
		"focusResetOnBlur":true,			//when widget loses focus, reset the current active navKey child.
		"navKeyRoot":false,					//arrow keys will move you circularly through the items.
		"navKeyDir":"both",					//horizontal = left/right, vertical = up/down, or both
		"rubberBand":false,					//selection by rubberband
		"rubberBandPartialSelect":false,	//rubberband must fully enclose the item for selection
		"selectableChildren":null,			//class for what children are selectable.
		"cacheSelectableChildren":false,	//when true, save last retreived to save time
	},
	_create:function()
	{
		this._super();
		$.extend(true, this.options, ibx.getIbxMarkupOptions(this.element));//we aren't an ibxWidget, so get the markup options.
		this.option(this.options);//force initial update.

		this.element.ibxAddClass("ibx-selection-manager");
		this.element.data("ibiIbxSelectionManager", this);//plymorphism
		this.element[0].addEventListener("focusin", this._focusInBound = this._onFocusIn.bind(this), true);
		this.element[0].addEventListener("focusout", this._focusOutBound = this._onFocusOut.bind(this), true);
		this.element[0].addEventListener("mousedown", this._onMouseEventBound = this._onMouseEvent.bind(this), true);
		this.element[0].addEventListener("mouseup", this._onMouseEventBound, true);
		this.element[0].addEventListener("keydown", this._onKeyDownBound = this._onKeyDown.bind(this), true);
		this.element[0].addEventListener("ibx_rubberbandchange", this._onRubberBandEventBound = this._onRubberBandEvent.bind(this), true);

	},
	_destroy:function()
	{
		if(this.element.is(".ibx-rubber-band"))
			this.element.ibxRubberBand("destroy");

		this.element.ibxRemoveClass([this._widgetClass, "ibx-sm-selection-root", "ibx-sm-focus-root", "ibx-sm-nav-key-root", "ibx-sm-focus-default"]);
		this.element[0].removeEventListener("focusin", this._focusInBound, true);
		this.element[0].removeEventListener("focusout", this._focusOutBound, true);
		this.element[0].removeEventListener("mousedown", this._onMouseEventBound, true);
		this.element[0].removeEventListener("mouseup", this._onMouseEventBound, true);
		this.element[0].removeEventListener("mouseup", this._onMouseUpBound, true);
		this.element[0].removeEventListener("keydown", this._onKeyDownBound, true);
		this.element[0].removeEventListener("ibx_rubberbandchange", this._onRubberBandEventBound, true);
		this._super();
	},
	_onFocusIn:function(e)
	{
		var options = this.options;
		var isTarget = this.element.is(e.target);
		var ownsTarget = $.contains(this.element[0], e.target) && $(e.target.parentElement).closest(".ibx-selection-manager").is(this.element);
		var ownsRelTarget = $.contains(this.element[0], e.relatedTarget);

		//make sure the manager is in the focused state.
		this._activate(true);

		//do the default focusing when manager is directly focused - not one of its children, and not when clicked on its scrollbar.
		var onScrollBar = this._eLastMouseDown ? ClickOnScrollbar(this.element[0], this._eLastMouseDown.clientX, this._eLastMouseDown.clientY) : false;
		if(isTarget && !onScrollBar && !ownsRelTarget && options.focusDefault !== false)
		{
			var defItem = this._focus();
			if(!defItem)
			{
				var defItem = this.element.find(options.focusDefault);
				defItem = defItem.length ? defItem : this.selectableChildren(":ibxVisible").first();
			}

			//this will cuase _onFocusIn to recurse with the default item being the e.target element.
			$(defItem).focus();
			return;
		}

		//focus the selected item
		if(!isTarget && ownsTarget)
			this._focus(e.target);
	},
	_onFocusOut:function(e)
	{
		//make sure the manager is in the blurred stated when some external element is focused.
		var isTarget = this.element.is(e.target);
		var ownsRelTarget = $.contains(this.element[0], e.relatedTarget);
		
		if(!isTarget && !ownsRelTarget)
			this._activate(false);
	},
	_onKeyDown:function(e)
	{
		var options = this.options;
		var ownsTarget = $.contains(this.element[0], e.target) && $(e.target.parentElement).closest(".ibx-selection-manager").is(this.element); //is there a deeper selection manager?!

		//this aint the selectionmanager you're looking for...get out of Dodge!
		if(!ownsTarget)
			return;

		//back tabbing with focus default means find outer prev sibling that's tabbable
		if(!options.focusRoot && options.focusDefault && e.keyCode == $.ui.keyCode.TAB && e.shiftKey)
		{
			var isFirstChild = $(e.target).is(":first-child");
			var prev = this.element.prevAll("[tabindex]").first();
			if(isFirstChild && prev.length)
			{
				prev.focus();
				e.preventDefault();
			}
		}

		//manage circular tabbing if desired.
		if(options.focusRoot && e.keyCode == $.ui.keyCode.TAB)
		{
			var focusKids = this.element.logicalChildren(".ibx-sm-focus-root", ":ibxFocusable:ibxVisible");
			var target = null;
			var firstKid = focusKids.first();
			var lastKid = focusKids.last();

			if(firstKid.length && lastKid.length)
			{
				if((firstKid.is(e.target) || $.contains(firstKid[0], e.target)) && e.shiftKey)
					target = focusKids.last();
				else
				if((lastKid.is(e.target) || $.contains(lastKid[0], e.target)) && !e.shiftKey)
					target = focusKids.first();
			}

			//target means first/last item and need to loop...or no kids, so do nothing.
			if(target || !focusKids.length)
			{
				target = $(target);
				target.focus();
				e.preventDefault();
				e.stopPropagation();
			}
		}

		//manage arrow navigation if desired.
		if(options.navKeyRoot && [$.ui.keyCode.LEFT, $.ui.keyCode.RIGHT, $.ui.keyCode.UP, $.ui.keyCode.DOWN].indexOf(e.keyCode) != -1)
		{
			var navKids = this.selectableChildren(":ibxVisible");
			var focusedItem = this._focus();
			var idxFocused = navKids.index(focusedItem);
			var goPrev = (e.keyCode == $.ui.keyCode.LEFT || e.keyCode == $.ui.keyCode.UP);
			var goNext = (e.keyCode == $.ui.keyCode.RIGHT || e.keyCode == $.ui.keyCode.DOWN);
			var vert = (options.navKeyDir == "horizontal" || options.navKeyDir == "both") && (e.keyCode == $.ui.keyCode.LEFT || e.keyCode == $.ui.keyCode.RIGHT);
			var horz = (options.navKeyDir == "vertical" || options.navKeyDir == "both") && (e.keyCode == $.ui.keyCode.UP || e.keyCode == $.ui.keyCode.DOWN);
			var focusItem = $();

			if(this.element.is(document.activeElement))
				focusItem = (focusedItem) ? focusedItem : navKids.first();
			else
			if(goPrev && (vert || horz))
				focusItem = (idxFocused > 0) ? navKids[idxFocused - 1] : navKids.last();
			else
			if(goNext && vert || horz)
				focusItem = (idxFocused < navKids.length-1) ? navKids[idxFocused + 1] : navKids.first();
			
			//don't focus for just shift/ctrl keys
			if(e.keyCode != 17 && e.keyCode != 16)
			{
				//focus the target
				focusItem.focus();
				e.preventDefault();
				e.stopPropagation();//propagation can conflict with outer selection managers.
			}
		}

		//manage selection, and focus jumping
		if((options.type != "none") && options.selectKeys.indexOf(e.keyCode) != -1)
		{
			var focusedItem = this._focus();
			var isMulti = options.type == "multi";
			if(isMulti && !e.shiftKey && !e.ctrlKey && !this.isSelected(focusedItem) && !options.toggleSelection)
				this.deselectAll(true, false);

			if(e.shiftKey)
			{
				var selChildren = this.selectableChildren(":ibxVisible");
				var idxAnchor = selChildren.index(this._anchor());
				var idxSel = selChildren.index(this._focus());
				var idxStart = Math.min(idxAnchor, idxSel);
				var idxEnd = Math.max(idxAnchor, idxSel);
				this.toggleSelected(selChildren.slice(idxStart, idxEnd + 1), true, false);
			}
			else
			if(isMulti && e.ctrlKey)
				this.toggleSelected(focusedItem);//toggle the target!
			else
				this.toggleSelected(focusedItem, (options.toggleSelection ? undefined : true));
		}
		else
		if((e.keyCode == $.ui.keyCode.HOME) && ibxEventManager.isInputEventToIgnore(e))
		{
			this.selectableChildren(":ibxVisible").first().focus();
			e.preventDefault();
		}
		else
		if((e.keyCode == $.ui.keyCode.END) && ibxEventManager.isInputEventToIgnore(e))
		{
			this.selectableChildren(":ibxVisible").last().focus();
			e.preventDefault();
		}
		else
		if(e.keyCode == $.ui.keyCode.ESCAPE && options.escClearSelection)
			this.deselectAll(true);
	},
	_eLastMouseDown:null,//used to know if click is on scrollbar for focusin
	_onMouseEvent:function(e)
	{
		var options = this.options;
		var isTarget = this.element.is(e.target);
		var ownsTarget = $.contains(this.element[0], e.target) && $(e.target.parentElement).closest(".ibx-selection-manager").is(this.element); //is there a deeper selection manager?!

		//deselect all when clicking on whitespace...BUT, not on scrollbar!
		// if(e.type == "mousedown" && isTarget && !ClickOnScrollbar(e.target, e.clientX, e.clientY) && !options.toggleSelection)
		// 	this.deselectAll()
		if(isTarget && ClickOnScrollbar(e.target, e.clientX, e.clientY))
			return;

		//if we don't directly own the target, then, Neo, you aren't the one.
		if(!ownsTarget && !isTarget)
			return;

		if(e.type == "mousedown")
		{
			this._eLastMouseDown = e;//save last mousedown so on activate we can check to see if it's on the scrollbar and not do focusDefault.
			this._activate(true);//mousedown happens before focus, so make us active before anything.

			//stop if we don't care about selection.
			if(options.type == "none" || options.selectButtons.indexOf(e.button) == -1)
				return;

			var isMulti = options.type == "multi";
			var selChildren = this.selectableChildren(":ibxVisible");
			var selTarget = this.mapToSelectable(e.target);

			if(isTarget || (isMulti && !e.shiftKey && !e.ctrlKey && !options.toggleSelection && !this.isSelected(selTarget)))
				this.deselectAll(true);

			//focus the target
			this.focus(selTarget, true);

			//event could happen on child element...map back to something we know can be selected
			//and can actually be selected by this selection manager.
			if(selChildren.index(selTarget) != -1)
			{
				if(options.type == "multi" && e.shiftKey)
				{
					var idxAnchor = selChildren.index(this._anchor());
					var idxSel = selChildren.index(selTarget[0]);
					var idxStart = Math.min(idxAnchor, idxSel);
					var idxEnd = Math.max(idxAnchor, idxSel);
					this.toggleSelected(selChildren.slice(idxStart, idxEnd + 1), true, false, false);
				}
				else
				if(isMulti && e.ctrlKey)
					this.toggleSelected(selTarget);//toggle the target!
				else
				if(isMulti)
					this.toggleSelected(selTarget, options.toggleSelection ? undefined : true);
				else
					this.toggleSelected(selTarget, true);
			}
		}
		else
		if(e.type == "mouseup")
		{
			this._eLastMouseDown = null;
		}
	},
	_onRubberBandEvent:function(e)
	{
		if(e.type == "ibx_rubberbandchange")
		{
			var anchor = null;
			var focus = null;
			var options = this.options;
			var selBox = e.data;
			selBox.right = selBox.left + selBox.width;
			selBox.bottom = selBox.top + selBox.height;

			var children = this.selectableChildren(":ibxVisible");
			for(var i = 0; i < children.length; ++i)
			{
				var child = children[i];
				var inBox = $(child).visInfo("borderBox", selBox);
				var select = options.rubberBandPartialSelect ? inBox.partial : inBox.total;
				this.selected(child, select, false);
				if(!anchor && select)
					anchor = child;
				focus = select ? child : focus;
			}

			this.anchor(anchor);
			this.focus(focus);
		}
	},
	preDispacthEvent:function(eventInfo){return eventInfo;},
	_dispatchEvent:function(eType, data, canBubble, cancelable, relatedTarget, mapItems)
	{
		mapItems = (mapItems === undefined) ? true : mapItems;
		data.items = mapItems ? this.mapFromSelectable(data.items) : data.items;
		var parms = this.preDispacthEvent({"eType":eType, "data":data, "canBubble":canBubble, "cancelable":cancelable, "relatedTarget":relatedTarget});
		var evt = this.element.dispatchEvent(parms.eType, parms.data, parms.canBubble, parms.cancelable, parms.relatedTarget);
		evt.data.items = mapItems ? this.mapToSelectable(data.items) : data.items;
		return evt;
	},
	mapToSelectable:function(el)
	{
		el = $(el)
		var selChildren = this.options.selectableChildren;
		return $(el).closest(".ibx-sm-selectable" + (selChildren ? (", " + selChildren) : ""));
	},
	mapFromSelectable:function(el)
	{
		return $(el);
	},
	_cachedSelectableChildren:$(),
	updateSelectableCache:function(children)
	{
		this._cachedSelectableChildren.ibxRemoveClass("ibx-sm-selectable");
		this._cachedSelectableChildren = $(children);
		return;
	},
	selectableChildren:function(selector)
	{
		var options = this.options;
		var children = $();
		if(options.cacheSelectableChildren && this._cachedSelectableChildren.length)
			children = selector ? this._cachedSelectableChildren.filter(selector) : this._cachedSelectableChildren;
		else
		{
			var e = this._dispatchEvent("ibx_selectablechildren", {"items":null}, false, true, undefined, false);
			var children = e.data.items
				? $(e.data.items)
				: this.element.logicalChildren(".ibx-sm-selection-root, .ibx-sm-nav-key-root, .ibx-sm-focus-root, .ibx-sm-focus-default", ":ibxFocusable(-1)");			

			if(options.selectableChildren)
				children =  children.filter(options.selectableChildren);

			this.updateSelectableCache(children);
			children.ibxAddClass("ibx-sm-selectable");
			children =  selector ? children.filter(selector) : children;
		}
		return children;
	},
	isSelected:function(el){return $(el).hasClass("ibx-sm-selected");},
	selected:function(el, select, anchor, focus)
	{
		//public interface needs to map nodes...think tree from ibxTreeNode to it's selectable label.
		el = $(el, this.element);
		el = this.mapToSelectable(el);
		el = this._selected(el, select, anchor, focus);
		return el ? this.mapFromSelectable(el) : undefined;
	},
	_selected:function(el, select, anchor, focus)
	{
		//return the selected children.
		if(!el.length)
		{
			select = (select !== false) ? ".ibx-sm-selected" : ":not(.ibx-sm-selected)";
			return this.element.logicalChildren(".ibx-sm-selection-root", select);
		}

		//only children that are direct descendants of this root can be manipulated.
		el = this.element.logicalChildren(".ibx-sm-selection-root", el);

		//by default set the anchor/focus item
		anchor = (select && (anchor === undefined)) ? true : anchor;
		focus = (select && (focus === undefined)) ? true : focus;

		if(select)
		{
			//handle selection types...
			var options = this.options;
			if(options.type == "single")//single selection
			{
				this.deselectAll(true);
				el = $(el).first(":not(.ibx-sm-selected)");
			}
			else//multi
			if(options.type == "multi")//multiple selection
				el = $(el).filter(":not(.ibx-sm-selected)");
			else
				el = $();//default just nav, no selection.

			if(el.length)
			{
				var evt = this._dispatchEvent("ibx_beforeselchange", {"selected":select, "items":el, "selMgr":this, "anchor":this._elAnchor, "focus":this._elFocus}, true, true);
				if(!evt.isDefaultPrevented())
				{
					el = evt.data.items;
					el.ibxAddClass("ibx-sm-selected").attr("aria-selected", true);
					if(anchor)
						this.anchor(el.first());
					if(focus)
						this.focus(el.last());
					this._dispatchEvent("ibx_selchange", {"selected":select, "items":el, "selMgr":this, "anchor":this._elAnchor, "focus":this._elFocus}, true, false);
				}
			}
		}
		else
		{
			el = $(el).filter(".ibx-sm-selected");
			if(el.length)
			{
				var evt = this._dispatchEvent("ibx_beforeselchange",{"selected":select, "items":el, "selMgr":this, "anchor":this._elAnchor, "focus":this._elFocus}, true, true);
				if(!evt.isDefaultPrevented())
				{
					el.ibxRemoveClass("ibx-sm-selected").attr("aria-selected", null);
					if(anchor && el.is(this._elAnchor))
						this.anchor(null);
					if(focus && el.is(this._elFocus))
						this.focus(null);
					this._dispatchEvent("ibx_selchange", {"selected":select, "items":el, "selMgr":this, "anchor":this._elAnchor, "focus":this._elFocus}, true, false);
				}
			}
		}
	},
	toggleSelected:function(el, selected, anchor, focus)
	{
		selected = (selected === undefined) ? !this.isSelected(el) : selected;
		this.selected(el, selected, anchor, focus);
	},
	selectAll:function(selector)
	{
		this.selected(":not(.ibx-sm-selected)", true);
	},
	deselectAll:function(andAnchor, andFocus)
	{
		andAnchor = (andAnchor == undefined) ? true : andAnchor;
		andFocus = (andFocus == undefined) ? true : andFocus;
		
		this.selected(".ibx-sm-selected", false);
		if(andAnchor)
			this.anchor(null);
		if(andFocus)
			this.focus(null);
	},
	_elAnchor:$(),
	anchor:function(el)
	{
		//public interface needs to map nodes...think tree from ibxTreeNode to it's selectable label.
		el = el ? this.mapToSelectable(el)[0] : el;
		el = this._anchor(el);
		return el ? this.mapFromSelectable(el) : undefined;
	},
	_anchor:function(el)
	{
		if(el === undefined)
			return this._elAnchor[0];

		if(!this._elAnchor.is(el))
		{
			var relTarget = this._elAnchor[0];
			this._elAnchor.ibxRemoveClass("ibx-sm-anchor");
			this._elAnchor = $(el).first().ibxAddClass("ibx-sm-anchor");
			var evt = this._dispatchEvent("ibx_anchored", {"anchor":this._elAnchor[0], "focus":this._elFocus[0], "selMgr":this}, true, false, relTarget);
		}
		return this._elAnchor[0];
	},
	_elFocus:$(),
	focus:function(el)
	{
		//public interface needs to map nodes...think tree from ibxTreeNode to it's selectable label.
		el = el ? this.mapToSelectable(el)[0] : el;
		el = this._focus(el);
		return el ? this.mapFromSelectable(el) : undefined;
	},
	_focus:function(el)
	{
		if(el === undefined)
			return this._elFocus[0];

		if(!this._elFocus.is(el))
		{
			var relTarget = this._elFocus[0];
			this._elFocus.ibxRemoveClass("ibx-sm-focused ibx-ie-pseudo-focus");
			this._elFocus = $(el).first().ibxAddClass("ibx-sm-focused " + (ibxPlatformCheck.isIE ? "ibx-ie-pseudo-focus" : ""));
			if(!this._elFocus.is(document.activeElement))
			{
				this._elFocus.focus();
				this._dispatchEvent("ibx_focused", {"focus":this._elFocus[0], "anchor":this._elAnchor[0], "selMgr":this}, true, false, relTarget);
			}
			var idFocus = this._elFocus.prop("id");
			this.element.attr("aria-activedescendant", idFocus || null);
		}
		return this._elFocus[0];
	},
	_active:false,
	active:function()
	{
		return this._active;
	},
	_activate:function(active)
	{
		if(active === undefined)
			return this._active;

		if(this._active != active)
		{
			var options = this.options;
			if(active)
			{
				this.element.ibxAddClass("ibx-sm-active");

				//take the element out of the tab order so shift+tab will work and not focus this container.
				//if(options.focusDefault)
				//	this.element.data("ibxFocDefSavedTabIndex", this.element.prop("tabindex")).prop("tabindex", -1);
			}
			else
			{
				if(this.options.focusResetOnBlur)
					this._focus(null);
				this.element.ibxRemoveClass("ibx-sm-active");

				//put this element back in the tab order...so that next tab into will will do auto-focus.
				//this.element.prop("tabIndex", this.element.data("ibxFocDefSavedTabIndex")).removeData("ibxFocDefSavedTabIndex");
			}
			this._active = active;
		}
	},
	option:function(key, value)
	{
		return this._superApply(arguments);
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = this.options[key] != value;
		if(key == "type")
		{
			this.element.ibxToggleClass("ibx-sm-selection-root", (value != "none"));
			if(changed)
			{
				(value == "multi") ? this.element.attr("aria-multiselectable", true) : (this.element.removeAttr("aria-multiselectable"));
				this.deselectAll(true);
			}
		}
		else
		if(key == "focusRoot")
			this.element.ibxToggleClass("ibx-sm-focus-root", value);
		else
		if(key == "navKeyRoot")
			this.element.ibxToggleClass("ibx-sm-nav-key-root", value);
		else
		if(key == "focusDefault")
			this.element.ibxToggleClass("ibx-sm-focus-default", !!value);
		else
		if(key == "rubberBand")
		{
			if(this.element.is(".ibx-rubber-band") && value === false)
				this.element.ibxRubberBand("destroy");
			else
			if(value)
				this.element.ibxRubberBand();
		}
		this._super(key, value);
	},
});

$.widget("ibi.ibxRubberBand", $.Widget, 
{
	options:
	{
		"startDistanceX":5,
		"startDistanceY":5,
	},
	_create:function()
	{
		this._super();
		this.element.ibxAutoScroll().ibxAddClass("ibx-rubber-band");
		this._onMouseEventBound = this._onMouseEvent.bind(this);
		this.element[0].addEventListener("mousedown", this._onMouseEventBound);
		this.element[0].addEventListener("mouseup", this._onMouseEventBound);
		this.element[0].addEventListener("mousemove", this._onMouseEventBound);
	},
	_init:function()
	{
		this._super();
	},
	_destroy:function()
	{
		this.element.ibxAutoScroll("destroy").ibxRemoveClass("ibx-rubber-band");
		this.element[0].removeEventListener("mousedown", this._onMouseEventBound);
		this.element[0].removeEventListener("mouseup", this._onMouseEventBound);
		this.element[0].removeEventListener("mousemove", this._onMouseEventBound);
		this._super();
	},
	_onMouseEvent:function(e)
	{
		var eType = e.type;
		if(eType == "mousedown")
		{
			this.stop();
			this._startPoint = {"x":e.clientX, "y":e.clientY};
		}
		else
		if(eType == "mouseup")
			this.stop();
		else
		if(eType == "mousemove" && this._startPoint)
		{
			var isActive = this.isActive();
			var options = this.options;
			if(!isActive && (Math.abs(this._startPoint.x - e.clientX) >= options.startDistanceX || Math.abs(this._startPoint.y - e.clientY) >= options.startDistanceY))
			{
				var event = this.element.dispatchEvent("ibx_beforerubberbandstart", null, true, true);
				if(!event.isDefaultPrevented())
				{
					//start rubberbanding!
					var pos = this.element.css("position");
					if(pos != "absolute")
						this.element.css("position", "relative").data("ibxSelMgrRubberBandOrigPos", pos);
					this.element.ibxAddClass("ibx-sm-rubber-band-active");
					this._rubberBand = $("<div class='ibx-sm-rubber-band'>").css({"left":eTrueX, "top":eTrueY}).appendTo(this.element);
					this.element.ibxAutoScroll("start");
					this.element.dispatchEvent("ibx_rubberbandstart", null, true, false, this._rubberBand[0]);

					//have to recalculate the start point in terms of the grid, and not the target cell
					var isTarget = this.element.is(e.target);
					this._startPoint = {"x":(isTarget ? 0 : e.target.offsetLeft) + e.offsetX, "y":(isTarget ? 0 : e.target.offsetTop) + e.offsetY};
				}
			}
			else
			if(isActive)
			{
				var eTrueX = e.offsetX + this.element.prop("scrollLeft");
				var eTrueY = e.offsetY + this.element.prop("scrollTop");
				var left = Math.min(this._startPoint.x, eTrueX);
				var top = Math.min(this._startPoint.y, eTrueY);
				var width = Math.abs(this._startPoint.x - eTrueX);
				var height = Math.abs(this._startPoint.y - eTrueY);
				var rBounds = {"left": left, "top":top, "width":width, "height":height};
				this._rubberBand.css(rBounds);
				this.element.dispatchEvent("ibx_rubberbandchange", rBounds, true, false, this._rubberBand[0]);
			}
		}
	},
	stop:function(e)
	{
		if(this.isActive())
			this.element.dispatchEvent("ibx_rubberbandend", null, true, false, this._rubberBand[0]);

		this.element.ibxRemoveClass("ibx-sm-rubber-band-active").css("position", this.element.data("ibxSelMgrRubberBandOrigPos"));
		this.element.ibxAutoScroll("stop");
		delete this._startPoint;

		if(this._rubberBand)
			this._rubberBand.remove();
		delete this._rubberBand;
	},
	isActive:function()
	{
		return this.element.is(".ibx-sm-rubber-band-active");
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = options[key] != value;
		this._super(key, value);
	}
});

//# sourceURL=selection.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/dragdrop.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.10 $:

function ibxDataTransfer()
{
	this.items = {};
	this.types = [];
	this.effectAllowed = "all";
	this.dropEffect = "not-allowed";
}
_p = ibxDataTransfer.prototype = new Object();
_p.dataLock = false;
_p.items = null;
_p.types = null;
_p.getData = function(type){return this.items[type];};
_p.setData = function(type, data)
{
	if(this.dataLock)
	{
		console.warn("[ibx Warning] ibxDataTransfer - set/clear data is not technically supported in drag/drop once drag has started.  You can set dataLock to false to enable if you must.");
		return;
	}

	this.items[type] = data;
	if(-1 == this.types.indexOf(type))
		this.types.push(type);
};
_p.clearData = function(type)
{
	if(this.dataLock)
	{
		console.warn("[ibx Warning] ibxDataTransfer - set/clear data is not technically supported in drag/drop once drag has started.  You can set dataLock to false to enable if you must.");
		return;
	}

	delete this.items[type];
	this.types.splice(this.types.indexOf(type), 1);
};
_p.dragXOffset = 8;
_p.dragYOffset = 8;
_p._dragImage = null;
_p.setDragImage = function(img, xOffset, yOffset)
{
	if(this._dragImage)
	{
		this._dragImage.style.position = "";
		this._dragImage.classList.remove(ibxDragDropManager.dragImageClass);
		if(this._dragImage.parentNode)
			this._dragImage.parentNode.removeChild(this._dragImage);
	}
	
	this._dragImage = img ? img : this._dragImage;
	if(this._dragImage)
	{
		this._dragImage.style.position = "absolute";
		this._dragImage.classList.add(ibxDragDropManager.dragImageClass);
		document.body.appendChild(this._dragImage);
	}

	this.dragXOffset = xOffset || this.dragXOffset;
	this.dragYOffset = yOffset || this.dragYOffset;
};

function ibxDragDropManager()
{
	if(ibx.dragDropMgr)
		return;

	document.documentElement.addEventListener("keydown", ibxDragDropManager._onKeyEvent.bind(ibxDragDropManager), true);
	document.documentElement.addEventListener("mousedown", ibxDragDropManager._onMouseEvent.bind(ibxDragDropManager), true);
	document.documentElement.addEventListener("mouseup", ibxDragDropManager._onMouseEvent.bind(ibxDragDropManager), true);
	document.documentElement.addEventListener("mousemove", ibxDragDropManager._onMouseEvent.bind(ibxDragDropManager), true);
	document.documentElement.addEventListener("dragover", ibxDragDropManager._onNativeDragEvent.bind(ibxDragDropManager), false);
	document.documentElement.addEventListener("drop", ibxDragDropManager._onNativeDragEvent.bind(ibxDragDropManager), false);
}
ibxDragDropManager.dragPrevented = false;
ibxDragDropManager.dragElement = null;
ibxDragDropManager.curTarget = $();
ibxDragDropManager.dragSourceClass = "ibx-drag-source";
ibxDragDropManager.dragTargetClass = "ibx-drop-target";
ibxDragDropManager.dragImageClass = "ibx-drag-image";
ibxDragDropManager.dragStartDistanceX = 5;
ibxDragDropManager.dragStartDistanceY = 5;

ibxDragDropManager.getDefaultDragImage = function(el)
{
	//clone the node and make sure the width/height are preserved so it lays out correctly.
	el = $(el);
	var width = el.outerWidth();
	var height = el.outerHeight();
	var clone = el.clone().css({"width":width + "px", "height":height + "px", "margin":"0px"}).removeAttr("id");
	return clone[0];
};
ibxDragDropManager._dispatchDragEvent = function(e, type, target, bubbles, cancelable, data)
{
	var evt = cloneNativeEvent(e, type, data, bubbles, cancelable, null);
	evt.dataTransfer = this._dataTransfer || e.dataTransfer;
	if(target)
		target.dispatchEvent(evt);
	return evt;
};
ibxDragDropManager.endDrag = function(eType, e)
{
	if(eType && this.isDragging())//[IA-7558] Only spit out event if dragging.
		this._dispatchDragEvent(e, eType, this.dragElement, true);
			
	if(this._dataTransfer)
		$(this._dataTransfer._dragImage).remove();

	if(this.curTarget.length)
	{
		//when canceling a drag target gets a dragleave
		if(eType == "ibx_dragcancel")
			this._dispatchDragEvent(e, "ibx_dragleave", this.curTarget, true)

		this.curTarget.ibxRemoveClass(this.dragTargetClass);
		this.curTarget.css("cursor", this.curTarget.data("ibxDragTargetCursorOrig")); 
		this.curTarget.removeData("ibxDragTargetCursorOrig");
		this.curTarget = $();
	}

	//reset body cursor
	document.body.style.cursor = document.body.dataset.ibxOrigDragCursor;
	delete document.body.dataset.ibxOrigDragCursor;


	if(this.dragElement)
	{
		this.dragElement.classList.remove(this.dragSourceClass);
		this.dragElement = null;
		this.dragPrevented = false;
	}
	document.body.classList.remove("ibx-dragging");

	delete this._dataTransfer;
	delete this._mDownLoc;
};
ibxDragDropManager._onKeyEvent = function(e)
{
	if(this.isDragging() && e.keyCode == $.ui.keyCode.ESCAPE)
		this.endDrag("ibx_dragcancel", e);
};
ibxDragDropManager.isDragging = function()
{
	return (this.dragElement && this.dragElement.classList.contains(this.dragSourceClass));
};
ibxDragDropManager._onMouseEvent = function(e)
{
	var eType = e.type;
	if(eType == "mousedown" && !this.isDragging())
	{
		this.dragElement = $(e.target).closest(".ibx-draggable")[0];
		this._mDownLoc = {"x":e.clientX, "y":e.clientY};
	}
	else
	if(eType == "mouseup")
	{
		//if allowed let target know it was dropped on
		if(!this.dragPrevented && this.isDragging())
			this._dispatchDragEvent(e, "ibx_drop", this.curTarget[0], true, true);

		//end the drag operation
		this.endDrag("ibx_dragend", e);
	}
	else
	if(eType == "mousemove" && this.dragElement)
	{
		var dEvent = null;
		var dx = e.clientX - this._mDownLoc.x;
		var dy = e.clientY - this._mDownLoc.y;
		var isDragging = this.isDragging();
		if(!isDragging && (Math.abs(dx) >= this.dragStartDistanceX || Math.abs(dy) >= this.dragStartDistanceY))
		{
			var dt = this._dataTransfer = new ibxDataTransfer();
			dEvent = this._dispatchDragEvent(e, "ibx_dragstart", this.dragElement, true, true);
			if(!dEvent.isDefaultPrevented())
			{
				//start dragging...and also set default drag image if not already set...default the offest for drag image to where dragged on 
				if(!dt._dragImage)
				{
					var bRect = this.dragElement.getBoundingClientRect();
					var offsetX = bRect.left - this._mDownLoc.x;
					var offsetY = bRect.top - this._mDownLoc.y;
					dt.setDragImage(this.getDefaultDragImage(this.dragElement), offsetX, offsetY);
				}

				isDragging = true;
				dt.dataLock = true;
				this.dragElement.classList.add(this.dragSourceClass);
				document.body.classList.add("ibx-dragging");
				document.body.dataset.ibxOrigDragCursor = document.body.style.cursor;
			}
		}

		if(isDragging)
		{
			//find the element under the mouse.
			var elTarget = document.elementFromPoint(e.clientX, e.clientY);

			//new drop target so reset the effect.
			this._dataTransfer.dropEffect = "not-allowed";

			//manage the current target
			if(!this.curTarget.is(elTarget))
			{
				//spit out events for source/target
				dEvent = this._dispatchDragEvent(e, "ibx_dragleave", this.curTarget[0], true);
				dEvent = this._dispatchDragEvent(e, "ibx_dragenter", elTarget, true, true);

				//reset last drag target
				if(this.curTarget.length)
				{
					this.curTarget.ibxRemoveClass(this.dragTargetClass);
					this.curTarget.css("cursor", this.curTarget.data("ibxDragTargetCursorOrig"));
					this.curTarget.removeData("ibxDragTargetCursorOrig");
				}

				//save new drag target
				this.curTarget = $(elTarget);
				if(this.curTarget.length)
				{
					//[IA-8982] when dragging over an svg node in IE (of course) there is no style property...so just ignore in that case.
					var cursor = this.curTarget[0].style ? this.curTarget[0].style.cursor : "";
					this.curTarget.data("ibxDragTargetCursorOrig", cursor);
					this.curTarget.ibxAddClass(this.dragTargetClass);
				}
			}

			if(this.curTarget.length)
			{
				//send drag messages if 'ibx_dragover' was not prevented
				dEvent = this._dispatchDragEvent(e, "ibx_drag", this.dragElement, true, true);
				dEvent = this._dispatchDragEvent(e, "ibx_dragover", this.curTarget[0], true, true);
				this.dragPrevented = !dEvent.isDefaultPrevented();

				//figure out the cursor
				var cursor = "not-allowed";
				if(!this.dragPrevented)
				{
					if(this._dataTransfer.effectAllowed == "all")
						cursor = this._dataTransfer.dropEffect;
					else
					if(this._dataTransfer.effectAllowed == this._dataTransfer.dropEffect)
						cursor = this._dataTransfer.dropEffect;
				}
				this.curTarget.css("cursor", cursor);
				this.curTarget[0].offsetHeight;
				document.body.style.cursor = cursor;
			}

			//manage the drag image
			if(this._dataTransfer._dragImage)
			{
				var dragImage = this._dataTransfer._dragImage;
				var xOffset = (this._dataTransfer.dragXOffset == "center") ? -(dragImage.width()/2) : this._dataTransfer.dragXOffset;
				var yOffset = (this._dataTransfer.dragYOffset == "center") ? -(dragImage.height()/2) : this._dataTransfer.dragYOffset;
				$(this._dataTransfer._dragImage).css(
				{
					"left":e.clientX + xOffset + "px",
					"top":e.clientY + yOffset + "px",
				});
			}
		}
	}
};
ibxDragDropManager._onNativeDragEvent = function(e)
{
	var dropTarget = $(e.target).closest(".ibx-external-drop-target")[0];
	if(!dropTarget)
		return;

	var eType = e.type;
	if(eType == "dragover")
		e.preventDefault();
	else
	if(eType == "drop" && !e.defaultPrevented)
	{
		var dt = e.dataTransfer;
		if(dt.files.length)
		{
			var formData = new FormData();
			$.each(dt.files, function(idx, file)
			{
				formData.append(file.name, file);
			});
			var ajaxOptions = 
			{
				"method":"POST",
				"contentType":false,
				"processData":false,
				"data":formData,
				"url":"",
				"dataTransfer":dt
			};

			if(this._dispatchDragEvent(e, "ibx_beforefilesupload", e.target, ajaxOptions).isDefaultPrevented())
				return;

			var deferred = $.ajax(ajaxOptions);
			this._dispatchDragEvent(e, "ibx_filesuploading", e.target, deferred);
		}
		e.preventDefault();
	}
};

//singleton drag/drop manager object.
ibx.dragDropMgr = new ibxDragDropManager();


/******************************************************************************
Drag scrolling allows any object to be scrolled by dragging its content area (panning)
******************************************************************************/
$.widget("ibi.ibxDragScrolling", $.Widget, 
{
	options:
	{
		overflowX:"auto",
		overflowY:"auto",
	},
	_create:function()
	{
		this._super();
		this.widgetEventPrefix = "ibx_";
		this._onDragScrollBound = this._onDragScroll.bind(this);

		this.element.on("wheel", function(e)
		{
			this._onDragScroll(e);
		}.bind(this));

		//on mobile let the device do the scrolling...otherwise we handle it.
		if(ibxPlatformCheck.isMobile)
			this.element.css({"overflow":"auto", "-webkit-overflow-scrolling":"touch"});
		else
			this.element.on("mousedown mouseup mousemove mouseleave", this._onDragScrollBound);
	},
	_destroy:function()
	{
		this._super();
		this.element.off("mousedown mouseup mousemove mouseleave", this._onDragScrollBound);
	},
	_onDragScroll:function(e)
	{
		if(this.options.disabled)
			return;

		if(e.type == "mousedown")
		{
			if(!this.element.dispatchEvent("ibx_beforescroll", null, true, true).isDefaultPrevented())
			{
				this._scrolling = true;
				this._eLast = e;
			}
		}
		else
		if(e.type == "mouseup" || e.type == "mouseleave" && this._scrolling)
		{
			this._scrolling = false;
			this.element.dispatchEvent("ibx_endscroll", null, true, false);
		}
		else
		if(this._scrolling && e.type == "mousemove" && this._scrolling)
		{
			var dx = e.screenX - this._eLast.screenX;
			var dy = e.screenY - this._eLast.screenY;
			this._scroll(dx, dy);
			this._eLast = e;
		}
		else
		if(e.type == "wheel")
		{
			//firefox always seems to report a delta of 1...chrome/ie 100...go figure.
			var dx = (e.originalEvent.deltaX * -1) * (ibxPlatformCheck.isFirefox ? 100 : 1);
			var dy = (e.originalEvent.deltaY * -1) * (ibxPlatformCheck.isFirefox ? 100 : 1);
			this._scroll(dx, dy);

			//if we don't allow y scrolling then we aren't handling it...and we are not gonna prevent default;
			if(this.options.overflowY != "hidden")
				e.preventDefault();

		}
	},
	_scroll:function(dx, dy)
	{
		var options = this.options;
		dx = options.overflowX != "hidden" ? dx : 0;
		dy = options.overflowY != "hidden" ? dy : 0;

		var sl = this.element.prop("scrollLeft");
		var st = this.element.prop("scrollTop");
		this.element.prop({"scrollLeft": sl - dx, "scrollTop": st - dy});
	},
	_refresh:function()
	{
		this._super();
	}
});

//# sourceURL=dragdrop.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/mutationobserver.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.10 $:

/******************************************************************************
	MUTATION OBSERVER
******************************************************************************/
$.widget("ibi.ibxMutationObserver", $.Widget, 
{
	options:
	{
		listen:false,
		allEvents:false,
		childList:false,
		subtree:false,
		characterData:false,
		characterDataOldValue:false,
		attributes:false,
		attributeOldValue:false,
		attributeFilter:null,
		mutationObserver:null,
	},
	_create:function()
	{
		this._super();
		var options = this.options;
		options.mutationObserver = new MutationObserver(this._onMutationEvent.bind(this));
	},
	_init:function()
	{
		this.refresh();
		this._super();
	},
	_destroy:function()
	{
		this.options.mutationObserver.disconnect();
		this._super();
	},
	_onMutationEvent:function(mutations)
	{
		var options = this.options;

		this.element.dispatchEvent("ibx_nodemutated", mutations, false, false);
		$.each(mutations, function(idx, mutation)
		{
			if(mutation.addedNodes.length)
				this.element.dispatchEvent("ibx_nodesadded", mutation.addedNodes, false, false);
			if(mutation.removedNodes.length)
				this.element.dispatchEvent("ibx_nodesremoved", mutation.removedNodes, false, false);
			if(mutation.attributeName)
				this.element.dispatchEvent("ibx_nodeattrchange", mutation, false, false);
			if(mutation.type == "characterData")
				this.element.dispatchEvent("ibx_nodecharchange", mutation, false, false);
		}.bind(this));
	},
	records:function()
	{
		return this.options.mutationObserver.takeRecords();
	},
	_setOption:function(key, value)
	{
		var changed = this.options[key] != value;
		this._super(key, value);
		if(changed)
			this.refresh();
	},
	refresh:function()
	{
		var options = this.options;
		var all = options.allEvents;
		var moOptions = 
		{
			childList: all || options.childList || options.subtree,
			subtree: all || options.subtree,
			characterData: all || options.characterData,
			characterDataOldValue: all || options.characterDataOldValue,
			attributes: all || options.attributes,
			attributeOldValue: all || options.attributeOldValue,
		};
		if(moOptions.attributes && options.attributeFilter)
			moOptions.attributeFilter = options.attributeFilter;

		if(options.listen)
			options.mutationObserver.observe(this.element[0], moOptions);
		else
			options.mutationObserver.disconnect();
	}
});

//# sourceURL=mutationobserver.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/shell.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/

/*****************************************************************************/
/* ibxShellApp - container for ibxShellTools */
/*****************************************************************************/
function ibxShellApp(config)
{
	if(window._ibxShellApp)
		return window._ibxShellApp;

	this.config = config || {};
	this.runningTools = {};
	window._ibxShellApp = this;
	window.getIbxShellApp = function(){return window._ibxShellApp};
	window.addEventListener("message", this._onToolMessage.bind(this));
}
var _p = ibxShellApp.prototype = new Object();
ibxShellApp.msgActivateTool = "ibx_activatetool";
ibxShellApp.msgUpdateToolUI = "ibx_updatetoolui";
ibxShellApp.attrShellToolId = "data-ibx-shell-tool-id";
ibxShellApp.idTool = 0;

_p._onToolMessage = function(e)
{
	var mType = e.data.type;
	if(mType == ibxShellTool.msgToolLoaded)
	{
		var toolInfo = this.runningTools[e.data.id];
		var host = $(toolInfo.host);
		if(host.is("iframe"))
		{
			var wnd = host[0].contentWindow;
			toolInfo.tool = wnd.ibxShellTool.getShellTool();
		}
		toolInfo.createDeferred.resolve(toolInfo);
	}
	else
	if(mType == ibxShellTool.msgActivate)
		this._activateTool(e.data);
	else
	if(mType == ibxShellTool.msgUpdateUI)
		this._updateToolUI(e.data);
};

_p.config = null;
_p.runningTools = null;
_p.createTool = function(tType)
{
	var tool = this.config.tools[tType];
	if(!tool)
		return console.error("[ibxShellApp] No registered ibxShellTool type: " + tType);

	var toolId = sformat("ibxShellToolId{1}", ++ibxShellApp.idTool);
	var host = $().data("ibxShellToolId", toolId);
	if(tool.host == "iframe")
		host = $("<iframe tabindex='-1' class='ibx-shell-tool-host'>").attr(ibxShellApp.attrShellToolId, toolId).attr("src", tool.src);
	else
	if(tool.host == "div")
	{
		var shellTool = tool.shellType ? toolShellType.call() : new ibxShellTool(toolId);
		host = $("<div tabindex='1' class='ibx-shell-tool-host'>").data("ibxShellTool", tool);
	}

	var toolInfo = this.runningTools[toolId] = {"id":toolId, "type":tType, "tool":shellTool, "host":host[0], "createDeferred":new $.Deferred()};
	return toolInfo;
};
_p._activateTool = function(activateInfo)
{
	var event = $(window).dispatchEvent(ibxShellApp.msgActivateTool, activateInfo, true, false);
	if(activateInfo.updateUI)
		this._updateToolUI(activateInfo);
};
_p._updateToolUI = function(updateInfo)
{
	var event = $(window).dispatchEvent(ibxShellApp.msgUpdateToolUI, updateInfo, true, false);
};
_p.manageCss = function(toolId, add)
{
	var tool = this.runningTools[toolId];
	if(tool && tool.shellUI && tool.shellUI.css)
	{
		var css = tool.shellUI.css;
		if(add)
		{
			var style = $("<style type='text/css'>").ibxAddClass(toolId).text(css);
			$(document.head).append(style);
		}
		else
			$("."+toolId).remove();
	}
};
/*****************************************************************************/
/* ibxShellTool - plugin for ibx shell application */
/*****************************************************************************/
function ibxShellTool(id)
{
	var singletonTool = ibxShellTool.getShellTool();
	if(singletonTool)
		return singletonTool;
	this._id = id;
	this._jqTool = window.jQuery;
}
var _p = ibxShellTool.prototype = new Object();
ibxShellTool.msgToolLoaded = "ibx_shelltoolloaded";
ibxShellTool.msgGetShellToolResources = "ibx_shelltoolbindresources";
ibxShellTool.msgActivate = "ibx_shelltoolactivate";
ibxShellTool.msgUpdateUI = "ibx_shelltoolupdateui";



//statically manage the shell tool.
ibxShellTool.msgSerialize = "ibx_shelltoolserialize";
ibxShellTool._shellTool = undefined;
ibxShellTool.getShellTool = function()
{
	var tool = ibxShellTool._shellTool;
	if(ibxShellTool._shellTool === undefined)
	{
		var ibxShellToolId = (window.frameElement) ? window.frameElement.getAttribute(ibxShellApp.attrShellToolId) : null;
		if(ibxShellToolId != null && !this._inctor)
		{
			this._inctor = true;
			tool = ibxShellTool._shellTool = new ibxShellTool(ibxShellToolId);
			this._inctor = false;
			window.parent.postMessage({"type":ibxShellTool.msgToolLoaded, "id":ibxShellToolId}, "*");
		}
	}
	return tool;	
};

_p.shellUI = null;
_p._id = null;
_p._jqTool = null;
_p._jqShell = null;
_p.getResources = function(jqShell, shellUI, data)
{
	shellUI = $.extend(true, {}, shellUI);
	this.setResContext(true, jqShell);
	shellUI = this._getResources(shellUI, data);
	this.setResContext(false);
	return shellUI;
};
_p._getResources = function(shellUI, data)
{
	var event = $(window).dispatchEvent(ibxShellTool.msgGetShellToolResources, {"shellUI":shellUI, "data":data}, true, false);
	return event.data.shellUI;
};
_p.setResContext = function(shell, jqShell)
{
	if(shell)
		this._jqShell = window.jQuery = window.$ = (jqShell || this._jqShell);
	else
		window.jQuery = window.$ = this._jqTool;		
};
_p.activate = function(activate, updateUI, data)
{
	updateUI = (updateUI != undefined) ? updateUI : activate;
	window.parent.postMessage({"type":ibxShellTool.msgActivate, "id":this._id, "activate":activate, "updateUI":updateUI, "data":data}, "*");
};
_p.updateUI = function(data)
{
	window.parent.postMessage({"type":ibxShellTool.msgUpdateUI, "id":this._id, "data":data}, "*");
};
_p.serialize = function(read, data)
{
	var event = $(window).dispatchEvent(ibxShellTool.msgSerialize, {"read":read, "data":data}, true, false);
	return !read ? event.data : this;
};

//# sourceURL=shell.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/widget.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
$.widget("ibi.ibxWidget", $.Widget, 
{
	options:
	{
		"class":"",
		"nameRoot":false,
		"ctxMenu":null,
		"command":null,
		"userValue":null,
		"draggable":false,
		"dragScrolling":false,
		"externalDropTarget":false,		//can you drop external things on this (like native OS files).
		"wantResize":false,
		"opaque":false,					//add iframe behind to stop pdf from bleading through.
		"tooltip":null,

		//for selection and keyboard naviation (circular tabbing/arrow keys)
		//These are just passthrough options for the attached ibxSelectionManager widget.
		"selType":"none",				//no selection by default.
		"focusRoot":false,				//keep tabbing to this container (like dialogs).
		"focusDefault":false,			//focus the first item in root. (can be a select pattern).
		"navKeyRoot":false,				//keep keyboard navigation to this container (not tabbing, more like arrows in trees/lists/etc.).
		"navKeyDir":"both",				//horizontal = left/right, vertical = up/down, or both
		"navKeyResetFocusOnBlur":true,	//when widget loses focus, reset the current active navKey child.
		"selMgrOpts":{},				//extended selection manager options.

		//ARIA (508)
		"aria":
		{
			"accessible":false,
			"role":null,
			"label":null,
			"labelledby":null,
			"describedby":null,
		}
	},
	_widgetClass:"ibx-widget",
	_adjustWidgetClasses:function(bAdd)
	{
		var classes = [];
		var p = this.__proto__;
		do
		{
			if(p._widgetClass)
				classes.unshift(p._widgetClass);
		}
		while(p = p.__proto__);
		for(var i = 0; i < classes.length; ++i)
		{
			var cls = classes[i];
			if(cls == "ibx-tree")
				var x = 10;
				
			this.element.ibxToggleClass(cls, bAdd);
		}
	},
	created:function(){return this._created;},
	_created:false,
	_createWidget:function(options, element)
	{
		this.options.aria.accessible = ibx.isAccessible;//default accessible to ibx, but allow markup/js to override.
		this._super(options, element);
		this._created = true;
		this._destroyed = false;
	},
	_create:function()
	{
		this.widgetFullName = this._widgetClass;
		this.widgetEventPrefix = "ibx_";
		this.element.data("ibxWidget", this);
		this.element.data("ibiIbxWidget", this);
		this.element.attr("data-ibx-type", this.widgetName);
		this.element.on("focusin focusout", this._onWidgetFocusEvent.bind(this));
		this.element.on("contextmenu", this._onWidgetContextMenu.bind(this));
		this.element.on("mouseover mouseout mousemove", this._onWidgetMouseEvent.bind(this));
		this._adjustWidgetClasses(true);

		//save the resize sensor callback;
		this._resizeCallbackBound = this._resizeCallback.bind(this);

		//assign memember variables
		var memberData = this.element.data("_ibxPrecreateMemberVariables");
		$.each(memberData, function(memberName, memberValue)
		{
			this.member(memberName, memberValue);
		}.bind(this));
		this.element.removeData("_ibxPrecreateMemberVariables");
		this._super();
	},
	_loadWidgetTemplate:function(tmpl)
	{
		var template = ibx.resourceMgr.getResource(tmpl, false);
		$.extend(true, this.options, ibx.getIbxMarkupOptions(template));

		var children = template.children();
		this.element.append(children);
		ibx.bindElements(children);
	},				
	setAccessibility:function(accessible, aria)
	{
		var aria = this.options.aria = $.extend(true, {}, this.options.aria, aria);
		aria.disabled = this.options.disabled;
		aria.accessible = accessible = (accessible === undefined) ? aria.accessible : accessible;

		//NEVER reset the role unless you have to, as it will cause the reader to completely re-read the element!
		if(accessible &&  aria.role && (this.element.attr("role") != aria.role))
			this.element.attr("role", aria.role);
		else
		if(!accessible || !aria.role)
			this.element.removeAttr("role");
			
		accessible ? this.element.ibxAriaId() : this.element.removeIbxAriaId();

		//let derived adjust their attributes, and adjust labelledby
		aria = this._setAccessibility(accessible, aria);
		aria.label = (typeof(this.options.tooltip) === "string") ? this.options.tooltip : aria.label;

		aria.labelledby = aria.label ? null : aria.labelledby; //can't have aria-label and aria-labelledby at same time...label wins.

		//now set the aria- attributes.
		for(var key in aria)
		{
			if($.ibi.ibxWidget.ARIA_PROPS_IGNORE[key])
				continue;
			var ariaAttr = "aria-" + key;
			accessible ? this.element.attr(ariaAttr, aria[key]) : this.element.removeAttr(ariaAttr);
		}
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		options.ctxMenu ? (aria.haspopup = true) : null;
		return aria;
	},
	destroyed:function(){return this._destroyed;},
	_destroyed:false,
	_destroy:function()
	{
		this._super();

		//kill the resize sensor
		if(this._resizeSensor)
			this._resizeSensor.detach();
		delete this._resizeSensor;

		this._setOptionDisabled(false);
		
		//remove all ibxWidget, and derived data
		var data = this.element.data();
		$.each(data, function(key, value)
		{
			if(key.search("ibiIbx") == 0 || key.search("ibx") == 0)
				this.element.removeData(key);
		}.bind(this));
		
		this.element.off();
		this.element.removeAttr("data-ibx-type");
		this.element.ibxRemoveClass(this.options.class);
		this._adjustWidgetClasses(false);
		this.setAccessibility(false);
		this._created = false;
		this._destroyed = true;
		this.element.dispatchEvent("destroy", null, false, false);
	},
	_init:function()
	{
		//some elements can already have aria- attributes when created, so we need to transfer them to the internal
		//options.aria object so they will be properly set in setAccessibility.
		var ariaOptions = ibx.getIbxMarkupOptions(this.element, "aria-");
		this.options.aria = $.extend(true, this.options.aria, ariaOptions);

		var options = $.extend(true, {}, this.options, ibx.getIbxMarkupOptions(this.element));
		this.option(options);
	},
	owner:function(){return this.element.parent();},
	member:function(memberName, value)
	{
		var ret = null;
		if(value === undefined)
			ret = this[memberName];
		else
		{
			if(this[memberName])
				console.warn("Overwriting Member '" + memberName + "' in nameroot, info=>", {nameRoot:this, memberExisting:this[memberName], memberOverwrite:value});
			this[memberName] = value;
		}
		return ret || $();
	},
	userValue:function(value)
	{
		if(value === undefined)
			return this.options.userValue;
		this.option("userValue", value);
	},
	getCommand:function()
	{
		return $.ibi.ibxCommand.cmds[this.options.command];
	},
	doCommandAction:function(action, data)
	{
		var cmd = this.getCommand();
		if(cmd)
			cmd.ibxWidget("doAction", action, data, this.element[0]);
	},
	_resizeCallback:function()
	{
		this.element.dispatchEvent("ibx_resize");
	},
	_widgetFocused:false,
	widgetFocused:function(){return this._widgetFocused;},
	_onWidgetFocusEvent:function(e)
	{
		var isTarget = this.element.is(e.target);
		var ownsRelTarget = $.contains(this.element[0], e.relatedTarget);
		if(e.type == "focusin" && !this._widgetFocused)
		{
			this._widgetFocused = true;
			this.element.dispatchEvent("ibx_widgetfocus", e.originalEvent, false, false, e.relatedTarget);
		}
		else
		if(e.type == "focusout" && this._widgetFocused && !ownsRelTarget)
		{
			this._widgetFocused = false;
			this.element.dispatchEvent("ibx_widgetblur", e, false, false, e.relatedTarget);
		}
	},
	_onWidgetContextMenu:function(e)
	{
		var ctxEvent = $.Event(e.originalEvent);
		ctxEvent.type = "ibx_ctxmenu";

		var ret = this.element.trigger(ctxEvent);
		if(ctxEvent.isDefaultPrevented() || !this.element.is(e.currentTarget))
			return;

		if(ctxEvent.result)
			console.warn("[ibx Deprecation] Event ibx_ctxmenu - event.result is deprecated.  Use event.menu instead.");
		ctxMenu = ctxEvent.result || ctxEvent.menu || $(this.options.ctxMenu);
		if(ctxMenu.length)
		{
			ctxMenu.ibxWidget("option", {"ctxWidget":this.element[0], "position":{my:"left top", at:"", collision:"flipfit", of:e}});
			ctxMenu.ibxWidget("open");
			e.stopPropagation();
			e.preventDefault();
		}
	},
	_ttTimer:null,
	_ttPopup:null,
	_onWidgetMouseEvent:function(e)
	{
		var eType = e.type;
		if(eType == "mouseover" && !this._ttPopup)
		{
			//let the user stop/modify the tooltip
			var tt = this.options.tooltip;
			var event = this.element.dispatchEvent("ibx_beforeshowtooltip", tt, true, true);
			if(event.isDefaultPrevented())
			{
				e.stopPropagation();
				return;
			}

			tt = event.data;
			if(typeof(tt) == "string")
				tt = $("<div>").ibxTooltip({"text":tt, "destroyOnClose":true});

			if(tt)
			{
				var ttWidget = tt.data("ibxWidget");
				var delay = ttWidget.options.delay;
				this._ttTimer = window.setTimeout(function(ttWidget)
				{
					ttWidget.option("position", {"collision":"flip fit", "my":"left+8 top+22", "at":"left bottom", "of":this._eLastMouse});
					ttWidget.element.ibxWidget("open").on("ibx_close", function(e)
					{
						this._ttPopup = null;//if user closes by clicking, or something other than mouseout.
					}.bind(this));
				}.bind(this, ttWidget), delay);
				this._ttPopup = tt;
				e.stopPropagation();
			}
		}
		else
		if(eType == "mouseout" && this._ttPopup && !this._ttPopup.is(e.relatedTarget) && !$.contains(this._ttPopup[0], e.relatedTarget))
		{
			window.clearTimeout(this._ttTimer);
			this._ttPopup.ibxWidget("close");
			this._ttPopup = null;
		}
		else
		if(this._ttPopup)
			e.stopPropagation();//if a tooltip is showing, then stop any higher level from doing the same.

		this._eLastMouse = e;
	},
	children:function(selector)
	{
		return this.element.children(selector);
	},
	add:function(el, elSibling, before, refresh)
	{
		el = $(el);
		elSibling = $(elSibling, this.element);
		if(elSibling.length)
			before ? el.insertBefore(elSibling) : el.insertAfter(elSibling);
		else
			before ? this.element.prepend(el) : this.element.append(el);

		if(refresh)
			this.refresh();
	},
	remove:function(el, destroy, refresh)
	{
		var children = this.element.children().filter(el || "*");
		var ret = (destroy) ? children.remove() : children.detach();
		if(refresh)
			this.refresh();
	},
	option:function(key, value, refresh)
	{
		var options = this.options;
		var bRefresh = (typeof(key) == "object") || (value !== undefined && (options[key] != value));

		var ret = this._superApply(arguments);
		if(bRefresh && refresh !== false)
			this.refresh();
		return ret;
	},
	_setOption:function(key, value)
	{
		var changed = (this.options[key] != value);
		this._super(key, value);
		if(changed && key == "userValue")
		{
			this.doCommandAction("uservalue", value);
			this.element.dispatchEvent("ibx_uservaluechanged", this.options.userValue, false, false);
		}
	},
	_setOptionDisabled:function(value)
	{
		//only do this if the state is changing.
		var changed = value != this.element.ibxHasClass("ibx-widget-disabled");
		if(!changed)
			return;

		this._super(value);
		var wClass = this._widgetClass;
		this.element.ibxToggleClass("ibx-widget-disabled", value);
		this.element.ibxToggleClass(wClass + "-disabled", value);
		if(this.options.class)
			this.element.ibxToggleClass(this.options.class + "-disabled", value);

		this.setAccessibility();
		
		//the add(this.element) looks weird, but it's just adding the element into the previous answer set so each opperates on it.
		this.element.find("[tabIndex], input, textarea").add(this.element).each(function(disabled, idx, el)
		{
			el = $(el);
			if(!disabled)
				el.prop("tabIndex", el.data("ibxDisabledTabIndex")).removeData("ibxDisabledTabIndex");
			else
				el.data("ibxDisabledTabIndex", el.prop("tabIndex")).prop("tabIndex", -1);
		}.bind(this, value));
	},
	refresh:function()
	{
		if(!$.ibi.ibxWidget.noRefresh)
			this._refresh();
	},
	_refresh:function()
	{
		var options = this.options;

		this.element.ibxAddClass(options.class);
		this.element.ibxToggleClass("ibx-draggable", options.draggable);
		this.element.ibxToggleClass("ibx-external-drop-target", options.externalDropTarget);

		//config the widget's selection manager, unless it's a custom job...then don't muck with it!
		if(options.selType !== "custom")
		{
			if(options.focusRoot || options.navKeyRoot || options.focusDefault || options.selType != "none")
			{
				var mgrOptions = 
				{
					"type": options.selType,
					"focusDefault": options.focusDefault,
					"focusRoot": options.focusRoot,
					"navKeyRoot": options.navKeyRoot,
					"navKeyDir": options.navKeyDir,
					"focusResetOnBlur": options.navKeyResetFocusOnBlur,
				};
				if(!this.element.is(".ibx-selection-manager"))
					this.element.ibxSelectionManager();
				this.element.ibxSelectionManager("option", $.extend({}, mgrOptions, options.selMgrOpts));//need this or options won't get set properly.
			}
			else
			if(this.element.is(".ibx-selection-manager"))
				this.element.ibxSelectionManager("destroy");
		}

		//now config accessibility
		this.setAccessibility();

		//associate widget with the command
		(options.command) ? this.element.attr("data-ibx-command", options.command) : this.element.removeAttr("data-ibx-command");

		//[PD-198] pdf files in ie bleed through divs above.  This stops that!
		if(options.opaque)
		{
			if(!this.element.children(".ibx-opaque-frame").length)
			{
				var path = sformat("{1}{2}", ibx.getPath(), "markup/blank.html");
				var iframe = $("<iframe class='ibx-opaque-frame' allowTransparency='false'>").prop("src", path);
				this.element.ibxAddClass("ibx-opaque").append(iframe);
			}
		}
		else
		{
			this.element.children(".ibx-opaque-frame").remove();
			this.element.ibxRemoveClass("ibx-opaque");
		}

		//hookup the resize sensor if interested in resize events.
		if(!options.wantResize && this._resizeSensor)
		{
			this._resizeSensor.detach();
			delete this._resizeSensor;
		}
		else
		if(options.wantResize)
		{
			//create a new resize sensor if we don't have one.
			if(!this._resizeSensor)
				this._resizeSensor = new ResizeSensor(this.element[0],this._resizeCallbackBound);

			//due to a problem with the resize sensor, when things are created in memory and then
			//added to the dom these values are all set to 0 and need to be set as follows.
			var expand = this.element.find(".resize-sensor-expand");
			var shrink = this.element.find(".resize-sensor-shrink");
			expand.prop("scrollLeft", 100000);
			expand.prop("scrollTop", 100000);
			shrink.prop("scrollLeft", 100000);
			shrink.prop("scrollTop", 100000);
		}
	},
});
$.ibi.ibxWidget.noRefresh = false; //globally turn off refresh to speed up various add/remove/update operations.
$.ibi.ibxWidget.ARIA_PROPS_IGNORE = {"role":true, "accessible":true},
$.ibi.ibxWidget.navKeys = [$.ui.keyCode.LEFT, $.ui.keyCode.RIGHT, $.ui.keyCode.UP, $.ui.keyCode.DOWN, $.ui.keyCode.HOME, $.ui.keyCode.END, $.ui.keyCode.PAGE_UP, $.ui.keyCode.PAGE_DOWN, 45/*INSERT*/];
$.ibi.ibxWidget.isNavKey = function(keyCode)
{
	keyCode = (keyCode instanceof Object) ? keyCode.keyCode : keyCode;
	return ($.ibi.ibxWidget.navKeys.indexOf(keyCode) != -1);
};
//# sourceURL=widget.ibx.js]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/commands.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.23 $:

/******************************************************************************
	COMMAND HANDLING
******************************************************************************/

$.widget("ibi.ibxCommand", $.ibi.ibxWidget, 
{
	options:
	{
		"id":null,
		"checked":false,
		"shortcut":null,
		"userValue":null,
	},
	_widgetClass:"ibx-command",
	_create:function()
	{
		this._super();
		this.element.css("display", "none");
		this._onCommandKeyEventBound = this._onCommandKeyEvent.bind(this);
		document.documentElement.addEventListener("keydown", this._onCommandKeyEventBound, true);
	},
	_destroy:function()
	{
		this._super();
		document.documentElement.removeEventListener("keydown", this._onCommandKeyEventBound, true);
		delete $.ibi.ibxCommand.cmds[this.options.id];
	},
	_init:function()
	{
		//need to do this so that if created from markup the id will be set first so userValue/etc will correctly be set on associated widgets.
		//_setOption relies on id being set first.
		var markupOpts = ibx.getIbxMarkupOptions(this.element);
		if(markupOpts.id !== undefined)
			this.option("id", markupOpts.id);
		this._super();
	},
	doAction:function(action, data, src)
	{
		var relTarget = this._relTarget = src;
		if(action == "trigger" && !this.options.disabled)
			event = this.element.dispatchEvent("ibx_triggered", data, false, false, src);
		else
		if(action == "disabled")
			this.option("disabled", data);
		else
		if(action == "checked")
			this.option("checked", data);
		else
		if(action == "uservalue")
			this.option("userValue", data);
		this._relTarget = null;
	},
	_onCommandKeyEvent:function(e)
	{
		if(eventMatchesShortcut(this.options.shortcut, e))
			this.doAction("trigger", null, e.target);
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var idOld = options.id;
		var changed = this.options[key] != value;
		
		//calls base
		this._super(key, value);

		if(key == "id")
		{
			delete $.ibi.ibxCommand.cmds[idOld];//remove old entry
			$.ibi.ibxCommand.cmds[value] = this.element;//add new entry
			this.updateState();//update all the states of connected widgets.
		}
		else
		if(changed && (key == "disabled" || key == "checked" || key == "userValue"))
		{
			if(key == "disabled")
				this.updateState(key);
			else
			if(key == "checked")
				this.updateState(key);
			else
			if(key == "userValue")
				this.updateState(key);
		}
	},
	updateState:function(state)
	{
		var options = this.options;
		var widgets = $(sformat(".ibx-widget[data-ibx-command='{1}']", options.id)); //widgets attached to this command.
		if(state == "disabled" || !state)
		{
			widgets.ibxWidget(options.disabled ? "disable" : "enable");
			this.element.dispatchEvent("ibx_disabledchanged", options.disabled, false, false, this._relTarget);
		}

		if(state == "checked" || !state)
		{
			widgets.filter(".ibx-can-toggle").ibxWidget("checked", options.checked);
			this.element.dispatchEvent("ibx_checkchanged", options.checked, false, false, this._relTarget);
		}

		if(state == "userValue" || !state)
		{
			widgets.ibxWidget("userValue", options.userValue);
			//don't need to dispatch uservaluechanged event because the base widget will do that when the option changes.
		}
	}
});
$.ibi.ibxCommand.cmds = {};

//# sourceURL=commands.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/autoscroll.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.10 $:

$.widget("ibi.ibxAutoScroll", $.Widget,
{
	options:
	{
		"autoActivate":false,
		"direction":"all",
		"marginLeft":20,
		"marginTop":20,
		"marginRight":20,
		"marginBottom":20,
		"stepLeft":5,
		"stepTop":5,
		"stepRight":5,
		"stepBottom":5,
	},
	_widgetClass:"ibx-auto-scroll",
	_timer:null,
	_lastMouseMove:null,
	_create:function()
	{
		this._super();
		this.element.ibxAddClass(this._widgetClass);
		var el = this.element[0];
		el.addEventListener("mousemove", this._onMouseEvent.bind(this), true);
		el.addEventListener("mouseover", this._onMouseEvent.bind(this), true);
		el.addEventListener("mouseout", this._onMouseEvent.bind(this), true);
	},
	_destroy:function()
	{
		this._super();
		this.disable();
		this.element.ibxRemoveClass(this._widgetClass);
	},
	_onMouseEvent: function(e)
	{
		var options = this.options;
		if(options.autoActivate)
		{
			var eType = e.type;
			if(eType == "mouseover")
				this.start();
			else
			if(eType == "mouseout")
				this.stop();
		}
		this._lastMouseMove = e;
	},
	_started:false,
	start:function()
	{
		if(!this._timer)
			this._timer = window.setInterval(this._onManageScroll.bind(this), 10);
		this.options.disabled = false;
	},
	stop:function()
	{
		window.clearInterval(this._timer);
		this._timer = null;
		this.options.disabled = true;
	},
	_onManageScroll:function()
	{
		if(this._lastMouseMove)
		{
			var options = this.options;
			var borderBox = this.element[0].getBoundingClientRect();
			var e = this._lastMouseMove;
			
			if(options.direction.search(/^all|^horizontal/) == 0)
			{
				var curScroll = this.element.scrollLeft();
				if(e.clientX <= (borderBox.left + options.marginLeft) && curScroll != 0)
					this.element.scrollLeft(curScroll - options.stepLeft);
				if(e.clientX >= (borderBox.right - options.marginRight))
					this.element.scrollLeft(curScroll + options.stepRight);
			}

			if(options.direction.search(/^all|^vertical/) == 0)
			{
				var curScroll = this.element.scrollTop();
				if(e.clientY <= (borderBox.top + options.marginTop) && curScroll != 0)
					this.element.scrollTop(curScroll - options.stepTop);
				if(e.clientY >= (borderBox.bottom - options.marginBottom))
					this.element.scrollTop(curScroll + options.stepBottom);
			}
		}
	},
	_setOption:function(key, value)
	{
		this._super(key, value);
		var options = this.options;
		if(key == "margin")
			options.marginLeft = options.marginTop = options.marginRight = options.marginBottom = value;
		else
		if(key == "step")
			options.stepLeft = options.stepTop = options.stepRight = options.stepBottom = value;
		else
		if(key == "disabled" && value)
			this.stop();
	}
});

//# sourceURL=autoscroll.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/sortable.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.29 $:

$.widget("ibi.ibxSortable", $.Widget, 
{
	options:
	{
		"direction":"vertical",
		"lockDragAxis":false,
		"startDragDistanceX":8,
		"startDragDistanceY":8,
		"sortItemClasses":"",
		"placeholderClasses":"",
		"sortableItems":"*",
	},
	_widgetClass:"ibx-sortable",
	_create:function()
	{
		this._super();
		var options = this.options;
		var curPos = this.element.css("position");
		this.element.ibxAddClass(this._widgetClass).ibxAutoScroll({"direction":options.direction});
		var el = this.element[0];
		el.addEventListener("mousedown", this._onDragEvent.bind(this), true);
		el.addEventListener("mouseup", this._onDragEvent.bind(this), true);
		el.addEventListener("mousemove", this._onDragEvent.bind(this), true);
		el.addEventListener("mouseover", this._onDragEvent.bind(this), true);
		el.addEventListener("mouseout", this._onDragEvent.bind(this), true);
		el.addEventListener("scroll", this._onDragEvent.bind(this), true);
	},
	_destroy:function()
	{
		this._super();
		this.element.ibxRemoveClass(this._widgetClass);
	},
	_createPlaceholder:function(dragElement)
	{
		var ph = dragElement.clone().ibxAddClass("ibx-sortable-placeholder " + this.options.placeholderClasses);
		var e = this.element.dispatchEvent("ibx_createplaceholder", ph, false);
		ph = e.data;
		return ph;
	},
	_dragElement:null,
	_placeholder:null,
	_inDrag: false,
	_onDragEvent:function(e)
	{
		var options = this.options;
		var de = this._dragElement;
		var vert = this.options.direction == "vertical";
		var horz = this.options.direction == "horizontal";
		var both = !vert && !horz;
		var target = $(e.target);
		var eType = e.type;
		if(eType == "mousedown")
		{
			//can only sort direct children
			this._stopDrag();//kill any left over drag (you dragged out of bounds and confused the world).
			var directChild = $(this.element.directChild(e.target));
			if(directChild.is(this.options.sortableItems))
			{
				this._dragElement = directChild;
				this._eMouseDown = e;
			}
		}
		else
		if(eType == "mouseup")
		{
			if(this._inDrag)
			{							
				this._dragElement.insertAfter(this._placeholder);
				var evt = this.element.dispatchEvent("ibx_sortend", {"sortElement":this._dragElement, "beforeElement":this._placeholder.prev(), "afterElement":this._placeholder.next(), "originalEvent":e}, false);
			}
			this._stopDrag();
		}
		else
		if(eType == "mousemove" && this._eMouseDown)
		{
			if(!this._inDrag)
			{
				var dx = Math.abs(e.clientX - this._eMouseDown.clientX);
				var dy = Math.abs(e.clientY - this._eMouseDown.clientY);
				var movX = dx >= options.startDragDistanceX;
				var movY = dy >= options.startDragDistanceY;
				if(horz && movX || vert && movY || (both && (movX || movY)))
				{
					var evt = this.element.dispatchEvent("ibx_beforesort", this._dragElement, false);
					if(!evt.defaultPrevented)
					{
						this._inDrag = true;
						var ph = this._placeholder = this._createPlaceholder(de);
						ph.insertAfter(de);

						var pos = de.position();
						de.css(
						{
							"left":pos.left + this.element.prop("scrollLeft"),
							"top":pos.top + this.element.prop("scrollTop"),
							"width":de.width(),
							"height":de.height(),
						}).ibxAddClass("ibx-sortable-drag-item " + options.sortItemClasses);
						this.element.ibxAutoScroll("start");
						this.element.ibxAddClass("ibx-sortable-dragging");
					}
				}
			}
			else
			if(this._inDrag && this._eLast)
			{
				var eLast = this._eLast
				var dx = e.clientX - eLast.clientX;
				var dy = e.clientY - eLast.clientY;
				this._moveDragElement(dx, dy);
				
				if(!this.element.is(target) && !this._placeholder.is(target))
				{
					//can only sort direct children
					var target = $(this.element.directChild(e.target));
					if(target.is(options.sortableItems))
					{
						var tBounds = target[0].getBoundingClientRect();
						var after = false;
					
						if(vert)
							after = e.clientY > (tBounds.top + (tBounds.height / 2));
						else
							after = e.clientX > (tBounds.left + (tBounds.width / 2));

						//let the world know we are doing a sort move...can't cancel
						this.element.dispatchEvent("ibx_sortmove", {"sortElement":de, "targetElement":target, "tBounds":tBounds, "after":after, "originalEvent":e}, false, false);

						if(after)
							this._placeholder.insertAfter(target);
						else
							this._placeholder.insertBefore(target);
					}
				}
			}
			this._eLast = e;
		}
		else
		if(eType == "scroll")
		{
			if(this._inDrag)
			{
				var scrollPos = {left:this.element.prop("scrollLeft"), top:this.element.prop("scrollTop")};
				var lastScrollPos = this._lastScrollPos || scrollPos;
				var dx = scrollPos.left - lastScrollPos.left;
				var dy = scrollPos.top - lastScrollPos.top;
				this._moveDragElement(dx, dy);
				this._lastScrollPos = scrollPos;
			}
			else
				this._lastScrollPos = null;
		}
	},
	_moveDragElement:function(dx, dy)
	{
		var de = this._dragElement;
		if(de)
		{
			var options = this.options;
			var vert = options.direction == "vertical";
			var horz = options.direction == "horizontal";
			var both = !vert && !horz;
			
			//calculate the proper offset
			var pos = de.position();
			pos.offsetLeft = pos.left + this.element.prop("scrollLeft") + dx;
			pos.offsetTop = pos.top + this.element.prop("scrollTop") + dy;

			//move within axis only if specified
			if(options.lockDragAxis)
				de.css({"left": (horz ? pos.offsetLeft : pos.left), "top": (vert ? pos.offsetTop : pos.top)});
			else
				de.css({"left": pos.offsetLeft, "top": pos.offsetTop});
		}			
	},
	_stopDrag:function()
	{
		this.element.ibxAutoScroll("stop").ibxRemoveClass("ibx-sortable-dragging");
		if(this._dragElement)
			this._dragElement.css({"width":"", "height":"", "left":"", "top":""}).ibxRemoveClass("ibx-sortable-drag-item " + this.options.sortItemClasses);
		delete this._dragElement;
		if(this._placeholder)
			this._placeholder.remove();
		delete this._placeholder;
		delete this._eLast;
		delete this._eMouseDown;
		this._inDrag = false;
	},
});
$.widget("ibi.ibxVSortable", $.ibi.ibxSortable, {options:{direction:"vertical", lockDragAxis:true}}); 
$.widget("ibi.ibxHSortable", $.ibi.ibxSortable, {options:{direction:"horizontal", lockDragAxis:true}}); 
//# sourceURL=sortable.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/collapsible.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.24 $:

$.widget("ibi.ibxCollapsible", $.Widget, 
{
	options:
	{
		"direction": "left",
		"mode": "push",
		"startCollapsed": false,
		"collapsedClass": "collapsed",
		"autoClose": false,
		"gap": 0,
	},
	_create:function()
	{
		this._marginInfo = 
		{
			"margin-left":this.element.css("margin-left"),
			"margin-top":this.element.css("margin-top"),
			"margin-right":this.element.css("margin-right"),
			"margin-bottom":this.element.css("margin-bottom"),
		}
		this.widgetEventPrefix = "ibx_";
		this.element.ibxAddClass("ibx-collapsible");
		this.element.on("transitionend", this._onTransitionEnd.bind(this))
		this.element.on("click", this._onMouseEvent.bind(this));
		this._boundWindowMouseEvent = this._onWindowMouseEvent.bind(this);
		this._super();
	},
	_destroy:function()
	{
		this._super();
		this.element.css(this._marginInfo);
		$(window).off("mousedown");
	},
	_init:function()
	{
		//don't call super as close/open calls refresh
		if(this.element.hasClass("menu-bar"))
			var x = 10;
		this.element.ibxAddClass("ibx-collapsible-initializing");//stop transition while initializing
		this._isOpen = this.options.startCollapsed;
		this.options.startCollapsed ? this.close() : this.open();
		this._onTransitionEnd();
	},
	_isOpen:false,
	isOpen:function()
	{
		return this._isOpen;
	},
	open: function ()
	{
		if (!this.isOpen() && !this.options.disabled && this._trigger("beforeopen"))
		{
			//remove the initializing class that stops transitions. Could be done just first time, but really doesn't matter to do it every time
			this._isOpen = true;
			this.element.ibxRemoveClass("ibx-collapsed ibx-collapsible-initializing")
			if(this.options.autoClose)
				$("body").ibxAddClass("body-collapsible-auto-close");
			this.refresh();
			this._trigger("opened")
		}
	},
	close: function ()
	{
		if (this.isOpen() && !this.options.disabled && this._trigger("beforeclose"))
		{
			this._isOpen = false;
			this.refresh();
			this._trigger("closed");
		}
	},
	toggle: function ()
	{
		(this.isOpen()) ? this.close() : this.open();
	},
	_onWindowMouseEvent: function (e)
	{
		if(this.options.autoClose && this.isOpen())
		{
			//close all open auto close collapsible and then let body get pointer events again.
			this.close();
			$("body").ibxRemoveClass("body-collapsible-auto-close");
		}
	},
	_onMouseEvent: function (e)
	{
		e.stopPropagation();
	},
	_onTransitionEnd: function (e)
	{
		if(this.isOpen())
		{
			$(window).on("click", this._boundWindowMouseEvent);
			this._trigger("open");
		}
		else
		{
			if(!e || e.originalEvent.propertyName.search("margin") != -1)
			{
				this.element.ibxAddClass("ibx-collapsed");
				$(window).off("click", this._boundWindowMouseEvent);
				this._trigger("close");
			}
		}
	},
	refresh: function ()
	{
		var options = this.options;
		var isOpen = this.isOpen();

		this.element.ibxToggleClass("auto-close", options.autoClose);
		
		var nMargin = 0;
		if(isOpen)
			nMargin = this._marginInfo["margin-" + options.direction];
		else
			nMargin = options.gap + (-1 * ((options.direction == "left" || options.direction == "right") ? this.element.outerWidth(true) : this.element.outerHeight(true)));
		this.element.css("margin-" + options.direction, nMargin)
		
		//IE has a problem with opacity and zIndex...it'll put the collapsed widget on top of everything else (at least in the case of a grid).
		if(!ibxPlatformCheck.isIE)
			this.element.css("opacity", isOpen ? 1 : 0);
	}
});
//# sourceURL=collapsible.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/iframe.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.13 $:

/******************************************************************************
	IBXIFRAME
	Simple wrapper around an iframe...needed because on ios you can't actually
	set the size of the iframe directly, so you have to wrap it in an outer
	div which you can size.
******************************************************************************/
$.widget("ibi.ibxIFrame", $.ibi.ibxWidget, 
{
	options:
	{
		"focusDefault":true,
		"name":"",
		"src":""
	},
	_widgetClass:"ibx-iframe",
	_create:function()
	{
		this._super();
		this._loadPromise = new $.Deferred();
		var frame = this._iFrame = $("<iframe tabindex='-1'>").ibxAddClass("ibx-iframe-frame");
		frame.on("load", this._onIFrameEvent.bind(this));
		this.element.append(frame);

		var cw = $(this.contentWindow());
		cw.on("keydown keyup keypress mousedown mouseup contextmenu", this._onIFrameEvent.bind(this));
	},
	_destroy:function()
	{
		this._super();
	},
	frame:function()
	{
		return this._iFrame;
	},
	_onIFrameEvent:function(e)
	{
		if(e.type == "load")
			this._loadPromise.resolve(this.element[0]);


		if(e.originalEvent)
		{
			var proxyEvent = $.Event(e.originalEvent);
			if(!this.element.trigger(proxyEvent))
				e.preventDefault;
		}
	},
	ready:function(fnReady)
	{
		this._loadPromise.then(fnReady);
	},
	contentDocument:function()
	{
		return this._iFrame.prop("contentDocument");
	},
	contentWindow:function()
	{
		return this._iFrame.prop("contentWindow");
	},
	text:function(txt)
	{
		if(txt === undefined)
			return this.contentDocument().body.innerText;
		this.contentDocument().body.innerText = txt;
	},
	html:function(html)
	{
		if(html === undefined)
			return this.contentDocument().body.innerHTML;
		this.contentDocument().body.innerHTML = html;
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var frmOptions = {};
		var curSrc = this._iFrame.attr("src") || "";
		var curName = this._iFrame.prop("name");
		if(curSrc != options.src)
			frmOptions.src = options.src;
		if(curName != options.name)
			frmOptions.name = options.name;
		this._iFrame.prop(frmOptions);
	}
});
//# sourceURL=iframe.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/flexbox.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.11 $:

$.widget("ibi.ibxFlexBox", $.ibi.ibxWidget, 
{
	options:
	{
		"inline":false,
		"direction":"row",
		"wrap":true,
		"justify":"start",
		"justifyItems":"start",
		"justifyContent":"start",
		"align":"start",
		"alignItems":"start",
		"alignContent":"start",
		"childSizing":"content",
	},
	_widgetClass:"ibx-flexbox",
	_create:function()
	{
		this._super();
	},
	_destroy:function()
	{
		this._super();
		this.element.ibxRemoveClass(this._curClasses);
	},
	_refresh:function()
	{
		var options = this.options;

		//remove all flexbox (fbx-xxx) classes.
		var curClasses = this.element.prop("class").replace(/fbx-[^ ]* */g,""); 
		this.element.prop("class", curClasses);

		//reapply flexbox classes based on current options.
		var fc = $.ibi.ibxFlexBox.statics.flexClasses;;
		var classes = "";
		classes += fc["display"][options.inline ? "inline" : "block"] + " ";
		classes += fc["direction"][options.direction] + " ";
		classes += fc["wrap"][options.wrap] + " ";
		classes += fc["justify"][options.justify] + " ";
		classes += fc["align"][options.align] + " ";
		//classes += fc["alignItems"][options.alignContent];
		//classes += fc["alignContent"][options.alignContent];
		classes += fc["childSizing"][options.childSizing] + " ";
		this._curClasses = classes;
		this.element.ibxAddClass(classes);
		this._super();
	}
});
$.widget("ibi.ibxHBox", $.ibi.ibxFlexBox, {options:{direction:"row",wrap:false}, _widgetClass:"ibx-flexbox-horizontal"});
$.widget("ibi.ibxVBox", $.ibi.ibxFlexBox, {options:{direction:"column",wrap:false}, _widgetClass:"ibx-flexbox-vertical"});

$.ibi.ibxFlexBox.statics = 
{
	"flexClasses":
	{
		"display":
		{
			"block":"fbx-block",
			"inline":"fbx-inline"
		},
		"direction":
		{
			"row":"fbx-row",
			"rowReverse":"fbx-row-reverse",
			"column":"fbx-column",
			"columnReverse":"fbx-column-reverse"
		},
		"wrap":
		{
			"false":"fbx-nowrap",
			"true":"fbx-wrap",
			"reverse":"fbx-wrap-reverse"
		},
		"justify":
		{
			"start":"fbx-justify-content-start fbx-justify-items-start",
			"end":"fbx-justify-content-end fbx-justify-items-end",
			"center":"fbx-justify-content-center fbx-justify-items-center",
			"spaceBetween":"fbx-justify-content-space-between",
			"spaceAround":"fbx-justify-content-space-around"
		},
		"justifyContent":
		{
			"start":"fbx-justify-content-start",
			"end":"fbx-justify-content-end",
			"center":"fbx-justify-content-center",
			"spaceBetween":"fbx-justify-content-space-between",
			"spaceAround":"fbx-justify-content-space-around"
		},
		"justifyItems":
		{
			"start":"fbx-justify-items-start",
			"end":"fbx-justify-items-end",
			"center":"fbx-justify-items-center",
		},
		"align":
		{
			"start":"fbx-align-items-start fbx-align-content-start",
			"end":"fbx-align-items-end fbx-align-content-end",
			"center":"fbx-align-items-center fbx-align-content-center",
			"stretch":"fbx-align-items-stretch fbx-align-content-stretch",
			"baseline":"fbx-align-items-baseline",
			"spaceBetween":"fbx-align-items-baseline",
			"spaceAround":"fbx-align-content-space-around"
		},
		"alignItems":
		{
			"start":"fbx-align-items-start",
			"end":"fbx-align-items-end",
			"center":"fbx-align-items-center",
			"stretch":"fbx-align-items-stretch",
			"baseline":"fbx-align-items-baseline"
		},
		"alignContent":
		{
			"start":"fbx-align-content-start",
			"end":"fbx-align-content-end",
			"center":"fbx-align-content-center",
			"stretch":"fbx-align-content-stretch",
			"spaceBetween":"fbx-align-items-baseline",
			"spaceAround":"fbx-align-content-space-around"
		},
		"childSizing":
		{
			"content":"fbx-child-sizing-content-box",
			"border":"fbx-child-sizing-border-box",
		},
	}
};

//# sourceURL=flexbox.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/grid.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.105 $:

/******************************************************************************
	CSS GRID
******************************************************************************/
$.widget("ibi.ibxGrid", $.ibi.ibxWidget,
{
	options:
	{
		"inline":false,

		"cols":"",
		"autoCols":"",
		"colGap":"",

		"rows":"",
		"autoRows":"",
		"rowGap":"",

		"areas":"",
		"autoFlow":"",

		"justify":"",
		"justifyContent":"",
		
		"align":"",
		"alignContent":"",
	},
	_widgetClass: "ibx-grid",
	_create: function ()
	{
		this._super();
	},
	_destroy: function ()
	{
		this._super();
	},
	_ieHasWarned:false,
	_refresh: function ()
	{
		this._super();
		var options = this.options;
		var cols = options.cols;
		var rows = options.rows;

		//Polyfill for IE repeats, just different syntax...coerce normal syntax.
		if(ibxPlatformCheck.isIE)
		{
			cols = cols.replace(/repeat\((\d+)\W+(.*?)\)/g, "($2)[$1]");			
			rows = rows.replace(/repeat\((\d+)\W+(.*?)\)/g, "($2)[$1]");	

			//can't use this stuff with IE.
			if((options.autoCols || options.autoRows || options.autoFlow  || options.areas || options.rowGap || options.colGap) && !this._ieHasWarned)
			{
				console.warn("[ibxGrid] IE does not support autoRows/autoCols/autoFlow/areas/rowGap/colGap for css grids.");
				this._ieHasWarned = true;
			}
		}

		var gridCss = 
		{
			//IE...do before so standard CSS can override in compliant browsers
			"-ms-grid-columns":			cols,
			"-ms-grid-rows":			rows,

			//Standard CSS
			"grid-template-columns":	cols,
			"grid-auto-columns":		options.autoCols,
			"grid-template-rows":		rows,
			"grid-auto-rows":			options.autoRows,
			"grid-template-areas":		options.areas,				//each line must be quoted, ex: " 'a1 a1 a1''a2 . a2''a3 . a3' "
			"grid-auto-flow":			options.autoFlow,
			"grid-column-gap":			options.colGap,
			"grid-row-gap":				options.rowGap,
			"justify-content":			options.justifyContent,		//stretch - default
			"justify-items":			options.justify,			//stretch - default
			"align-content":			options.alignContent,		//stretch - default
			"align-items":				options.align,				//stretch - default
		};
		this.element.css(gridCss);
		options.inline ? this.element.ibxAddClass("gd-inline") : this.element.ibxRemoveClass("gd-inline");

		this.element.children().each(function(options, idx, cell)
		{
			cell = $(cell);
			var cellData = cell.data();
			var colInfo = cellData.ibxCol ? cellData.ibxCol.toString().split("/") : [];
			var colStart = colInfo[0] || "";
			var colEnd = colInfo[1] || "";
			var rowInfo = cellData.ibxRow ? cellData.ibxRow.toString().split("/") : [];
			var rowStart = rowInfo[0] || "";
			var rowEnd = rowInfo[1] || "";
			var css = 
			{
				//IE Columns...do before so standard CSS can override in compliant browsers
				"-ms-grid-column":			colStart,
				"-ms-grid-column-span":		colEnd.replace(/\s*span\s*/, ""),
				"-ms-grid-column-align":	cell.data("ibxJustify") || options.justify,

				//IE Rows...do before so standard CSS can override in compliant browsers
				"-ms-grid-row":				rowStart,
				"-ms-grid-row-span":		rowEnd.replace(/\s*span\s*/, ""),
				"-ms-grid-row-align":		cell.data("ibxAlign") || options.align,

				//Standard CSS Columns
				"grid-column-start":		colStart,
				"grid-column-end":			colEnd,
				"justify-self":				cell.data("ibxJustify"),

				//Standard CSS Rows
				"grid-row-start":			rowStart,
				"grid-row-end":				rowEnd,
				"align-self":				cell.data("ibxAlign"),

				//Standard CSS not supported by IE
				"grid-area":				cell.data("ibxArea"),
			};
			cell.css(css).ibxAddClass("ibx-grid-cell");
		}.bind(this, options));		
	}
});

/****
	These extensions are what stops jQuery from adding 'px' to these properties when setting $(xxx).css(yyy, zzz).
	jQuery is also smart enough to check if these properties are vendor prefixed when setting them (-ms, -moz, -webkit)
****/
$.extend($.cssNumber, 
{
	gridColumn:true,
	gridColumnStart:true,
	gridColumnEnd:true,
	gridColumnSpan:true,
	gridRow:true,
	gridRowStart:true,
	gridRowEnd:true,
	gridRowSpan:true,
});

/******************************************************************************
	DATA GRID
******************************************************************************/
$.widget("ibi.ibxDataGridSelectionManager", $.ibi.ibxSelectionManager,
{
	"options":
	{
		"grid":null,
		"type":"multi",
		"rowSelect":false,
		"focusDefault":true,
		"focusResetOnBlur":false,
		"navKeyRoot":true,
		"toggleSelection":false,
		"rubberBand":true,
		"rubberBandPartialSelect":true,
		"escClearSelection":true,
		"selectableChildren":".dgrid-cell", //can be elements/classes/etc.
		"cacheSelectableChildren":true,
	},
	_widgetClass:"ibx-data-grid-selection-manager",
	_onKeyDown:function(e)
	{
		var options = this.options;
		if(!options.rowSelect && options.navKeyRoot && [$.ui.keyCode.LEFT, $.ui.keyCode.RIGHT, $.ui.keyCode.UP, $.ui.keyCode.DOWN].indexOf(e.keyCode) != -1)
		{
			var selector = options.selectableChildren;
			var cell = $(e.target).closest(selector).filter(":visible()");
			var row = cell.parent();
			if(e.keyCode == $.ui.keyCode.LEFT)
				cell = cell.prevAll(selector + ":visible()").first();
			else
			if(e.keyCode == $.ui.keyCode.RIGHT)
				cell = cell.nextAll(selector + ":visible()").first();
			else
			if(e.keyCode == $.ui.keyCode.UP)
			{
				var cellIdx = row.children(selector).index(cell[0]);
				row = cell.parent().prevAll(".dgrid-row:visible()").first();
				cell = row.children(sformat(":nth-child({1})", cellIdx+1));
			}
			else
			if(e.keyCode == $.ui.keyCode.DOWN)
			{
				var cellIdx = row.children(selector).index(cell[0]);
				row = cell.parent().nextAll(".dgrid-row:visible()").first();
				cell = row.children(sformat(":nth-child({1})", cellIdx+1));
			}

			cell.focus();
			e.preventDefault();
			e.stopPropagation();
		}
		else
			this._super(e);
	},
	mapToSelectable:function(el)
	{
		if(this.options.rowSelect)
			return $(el).closest(".dgrid-row");
		else
			return this._super(el);
	},
	option:function(key, value)
	{
		if(key == "rowSelect")
		{
			this.deselectAll();
			this.selectableChildren().ibxRemoveClass("ibx-sm-selectable");
			this.updateSelectableCache();
			this.options.selectableChildren = value ? ".dgrid-row" : ".dgrid-cell";
			this.element.ibxToggleClass("dgrid-sm-row-select", value);
		}
		this._super(key, value);
	},
});

//Super light weight jQuery widget wrapper around ibxDataGrid rows.
$.fn.ibxDataGridRow = $.ibi.ibxDataGridRow = function(opts, el)
{
	var ret = this;
	var els = $();
	if(this instanceof jQuery)
		els = this;
	else
	if(el instanceof jQuery)
		els = el;

	els.each(function ibxDataGridRow_widget(args, idx, el)
	{
		el = $(el);
		var widget = el.data("ibxDataGridRow");
		if(!widget)
		{
			widget =
			{
				element:el,
				parent:null,
				container:false,
				size:null,
				header:$("<div>").attr({"tabindex": -1}),
				dynamicHeaderSize:false,//calculate row header size on refresh...VERY SLOW, USE WITH CAUTION!
				splitter:null,
				title:null,
				size:null,
				rowClasses:["ibx-data-grid-row", "dgrid-row", "ibx-flexbox", "fbx-inline", "fbx-row", "fbx-align-items-stretch", "fbx-align-content-stretch"],
				headerClasses:["dgrid-header-row", "dgrid-row", "ibx-flexbox", "fbx-inline", "fbx-row", "fbx-align-items-center", "fbx-justify-content-center"],
				cellContainerClasses:["ibx-flexbox", "fbx-inline", "fbx-row", "fbx-align-items-center"],
				expanded:0,
				singleClickExpand:false,
				
				getGrid:function(){return this.element.closest(".ibx-data-grid");},
				depth:function()
				{
					var depth = 0;
					var parent = this.element;
					while(parent = $(parent).data("ibxDataGridRow").parent)
						depth++;
					return depth;
				},
				setParent:function(parent)
				{
					$(this.parent).off("ibx_expand ibx_collapse ibx_get_row_children", this._boundParentEvent);
					this.parent = parent;
					this._boundParentEvent = this._onParentEvent.bind(this);
					$(this.parent).on("ibx_expand ibx_collapse ibx_get_row_children", this._boundParentEvent);
					this.refresh();
				},
				addRow:function(row)
				{
					var row = $(row).ibxDataGridRow("setParent", this.element);
					this.container = !!row.length || this.container;
					row.ibxDataGridRow("show", this.isVisible() && this.isExpanded());
				},
				removeRow:function(row)
				{
					var row = $(row).ibxDataGridRow("setParent", null);
				},
				childRows:function(filter)
				{
					filter = filter || "*";
					var event = this.element.dispatchEvent("ibx_get_row_children", {"filter":filter, "children":[]}, false, false);
					return event.data.children;
				},
				show:function(show)
				{
					this.element.ibxToggleClass("dgrid-row-hidden", !show);
					this.header.ibxToggleClass("dgrid-row-hidden", !show);
					this.updateAccessibility();
					if(this.isExpanded())
						this.element.dispatchEvent(show ? "ibx_expand" : "ibx_collapse", null, false, false);
				},
				isVisible:function()
				{
					return !this.element.ibxHasClass("dgrid-row-hidden");
				},
				isExpanded:function()
				{
					return this.element.is(".dgrid-row-expanded");
				},
				expand:function(expand)
				{
					if(this.isExpanded() == expand)
						return;

					var evt = this.element.dispatchEvent( expand ? "ibx_beforeexpand" : "ibx_beforecollapse", null, true, true);
					if(!evt.isDefaultPrevented())
					{
						this.expanded = expand;
						this.element.ibxToggleClass("dgrid-row-expanded", expand);
						this.updateAccessibility();
						this.element.dispatchEvent(expand ? "ibx_expand" : "ibx_collapse", null, true, false);
					}
				},
				toggleExpand:function()
				{
					this.expand(!this.expanded);
				},
				_onExpandButtonClick:function(e)
				{
					this.toggleExpand();
				},
				_onIndentCellEvent:function(e)
				{
					var eType = e.type;
					if((eType == "click" && this.singleClickExpand) || eType == "dblclick")
						this.toggleExpand();
					else
					if(eType == "keydown" && this.container)
					{
						if(e.keyCode === $.ui.keyCode.ENTER)
							this.toggleExpand();
						else
						if(e.keyCode === $.ui.keyCode.RIGHT && e.ctrlKey && !this.expanded)
						{
							if(!this.expanded)
							{
								this.toggleExpand(true);
								e.stopPropagation();
								e.preventDefault();
							}
						}
						else
						if(e.keyCode === $.ui.keyCode.LEFT && e.ctrlKey && this.expanded)
						{
							if(this.expanded)
							{
								this.toggleExpand(false);
								e.stopPropagation();
								e.preventDefault();
							}
						}

					}
				},
				_onParentEvent:function(e)
				{
					if(e.type == "ibx_get_row_children")
					{
						var data = e.originalEvent.data;
						if(this.element.is(data.filter))
							data.children.push(this.element[0]);
					}
					else
						this.show(e.type == "ibx_expand");
				},
				_indentColumn:-1,
				setIndentColumn:function(indentColumn)
				{
					if(this._indentColumn != indentColumn)
					{
						//remove the current indent cell config.
						var indentCell = this.getIndentCell();
						indentCell.off("dblclick click keydown", this._onIndentCellEventBound);

						if(!indentCell.is(".ibx-flexbox"))				
							indentCell.ibxRemoveClass(this.cellContainerClasses)
						indentCell.ibxRemoveClass("dgrid-cell-indent-column dgrid-cell-indent-padding").css("paddingLeft", "");

						//now get and configure the NEW indent cell.
						indentCell = this.getCell(indentColumn);
						if(indentCell.length)
						{
							this._indentColumn = indentColumn;

							//save new indentColumn
							this._indentColumn = indentColumn;
							indentCell.on("dblclick click keydown", this._onIndentCellEventBound);
							indentCell.ibxAddClass("dgrid-cell-indent-column").ibxToggleClass("dgrid-cell-indent-padding", !this.container);
							if(!indentCell.is(".ibx-flexbox"))
								indentCell.ibxAddClass(this.cellContainerClasses);

							if(this.container)
							{
								//create the expand button, and move it to the current indent cell.
								var expandButton = this._expandButton = this._expandButton || $("<div class='material-icons dgrid-cell-expand-button'></div>").on("click", this._onExpandButtonClick.bind(this));
								expandButton.detach();
								indentCell.prepend(expandButton);
							}
							indentCell.ibxToggleClass("dgrid-cell-indent-padding", !this.container);

							//update our indent
							indentCell.css("paddingLeft", (this.depth() + "em"));
							
							//then update all our children...and so on.
							$(this.childRows()).ibxDataGridRow("setIndentColumn", indentColumn);
						}
					}
				},
				getIndentCell:function(){return this.getCell(this._indentColumn);},
				getCell:function(nCol){return this.element.children(sformat(":nth-child({1})", nCol+1));},
				updateAccessibility:function()
				{
					var ariaOpts = 
					{
						"role":"row",
						"aria-level":this.depth() + 1,
						"aria-hidden":!this.isVisible(),
						"aria-owns":this.header.prop("id")
					};
					this.container ? ariaOpts["aria-expanded"] = this.isExpanded() : null;
					this.element.attr(ariaOpts);
					//this.getIndentCell().attr(ariaOpts);
					this.header.attr({"role":"rowheader", "aria-hidden":ariaOpts["aria-hidden"]});
				},
				refresh:function(options)
				{
					$.extend(this, options);
					this.element.ibxAddClass(widget.rowClasses).data("ibxDataGridRow", widget);
					this.header.ibxAddClass(widget.headerClasses).data("ibxDataGridRow", widget).ibxAriaId().text(this.title == null ? "." : this.title);

					//setup the indent column stuff.
					var grid = this.getGrid();
					var indentColumn = grid.length ? grid.ibxDataGrid("option", "indentColumn") : -1;
					this.setIndentColumn(indentColumn);
					this.expand(this.expanded);
					this.updateAccessibility();

					//Much as I HATE timers...There are times when the height of a row can be dynamic (text wrapping)
					//So, in that case, you can make the row calculate its header size dynamically.
					if(this.dynamicHeaderSize)
					{
						window.setTimeout(function()
						{
							this.header.outerHeight(this.element.outerHeight()).css("visibility", "");
						}.bind(this), 0);
					}
				},
			};

			widget._onIndentCellEventBound = widget._onIndentCellEvent.bind(widget);//need to save for event binding.
			widget.refresh(args[0]);//when constructing, only an 'options' object can be passed.
		}
		else
		{
			var val = this;
			var fn = args[0];
			if(fn instanceof Object)
				widget.refresh(fn);
			else
			if(widget[fn] instanceof Function)
			{
				var fnArgs = $(args).toArray().slice(1);
				val = widget[fn].apply(widget, fnArgs);
			}
			else
				console.error("[ibxDataGridRow] No such method '" + fn + "'.");

			if(val != this && val !== undefined)
			{
				ret = val;
				return false;
			}
		}
		return this;
	}.bind(this, arguments));
	return ret;
};

$.widget("ibi.ibxDataGrid", $.ibi.ibxGrid,
{
	options:
	{
		colMap:[],
		defaultColConfig:
		{
			title:"Column",
			size:"100px", //the last column can have a size of 'flex' indicating that column should take up empty space at end.
			justify:"center",
			resizable:true,
			selectable:true,
			visible:true,
			ui:null,
		},

		//selection manager option passthroughs.
		selType:"multi",
		rowSelect:false, 
		toggleSelection:false,

		defaultRowConfig: {},//not currently used.
		showColumnHeaders:true,
		showRowHeaders:true,
		indentColumn:-1,
		
		/*frame stuff*/
		cols:"auto 1fr",
		rows:"auto 1fr",
		classes:
		{
			colHeaderBarClass:"dgrid-header-col-bar",
			colHeaderClass:"dgrid-header-col",
			colHeaderSplitterClass:"dgrid-header-col-splitter",
			rowHeaderBarClass:"dgrid-header-row-bar",
			rowHeaderClass:"dgrid-header-row",
			rowHeaderSplitterClass:"dgrid-header-row-splitter",
			gridClass:"dgrid-grid",
			gridRow:"dgrid-row",
			gridCell:"dgrid-cell",
		},

		/*accessibility stuff*/
		aria:
		{
			role:"treegrid"
		}
	},
	_widgetClass:"ibx-data-grid",
	_create:function()
	{
		var options = this.options;
		var classes = options.classes;
		var corner = this._corner = $("<div>").ibxAddClass("dgrid-corner").data({ibxCol:1, ibxRow:1});
		var grid = this._grid = $("<div tabindex='0'>").ibxVBox({align:"start", selType:"custom"}).ibxAddClass(classes.gridClass).data({ibxCol:"2", ibxRow:"2"});
		grid.on("ibx_beforeselchange", this._onGridSelChange.bind(this));
		grid.on("scroll", this._onGridScroll.bind(this));

		this._sm = grid.ibxDataGridSelectionManager({grid:this});
		this._sm = grid.ibxDataGridSelectionManager("instance");

		var colHeaderBar = this._colHeaderBar = $("<div tabindex='0'>").ibxHBox({navKeyRoot:true, focusDefault:true}).ibxAddClass(classes.colHeaderBarClass);
		var colHeaderBarGroup = this._colHeaderBarGroup = $("<div class='dgrid-header-col-bar-group'>").append(colHeaderBar).data({ibxCol:"2", ibxRow:"1"});
		var rowHeaderBar = this._rowHeaderBar = $("<div tabindex='0'>").ibxVBox({navKeyRoot:true, focusDefault:true, align:"stretch"}).ibxAddClass(classes.rowHeaderBarClass).data({ibxCol:"1", ibxRow:"2"});

		this.add([corner[0], colHeaderBarGroup[0], rowHeaderBar[0], grid[0]]);
		this._super();
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		var options = this.options;
		this.element.attr("role", (options.indentColumn == -1) ? "grid" : "treegrid");
		this._colHeaderBarGroup.attr("role", "rowgroup");
		this._colHeaderBar.ibxWidget("setAccessibility", undefined, {"role":"row"});
		this._grid.ibxWidget("setAccessibility", undefined, {"role":"rowgroup"});
		return aria;
	},
	_init:function()
	{
		//call super first so grid options are set correctly before adding rows.
		this._super();

		//make the columns from markup.
		var colMap = [];
		var cols = this.element.children("[data-ibxp-grid-col-map]").detach().children();
		for(var i = 0; i < cols.length; ++i)
		{
			var col = cols[i];
			var opts = ibx.getIbxMarkupOptions(cols[i]);
			opts.title = col.innerText || opts.title;
			colMap.push(opts);
		}

		if(colMap.length)
			this.option("colMap", colMap);

		//make the rows from markup...these are just divs with inner cell...I'll construct the ibxDataGridRow object.
		var rows = this.element.children("[data-grid-row]").detach();
		for(var i = 0; i < rows.length; ++i)
		{
			var row = rows[i];
			var opts = ibx.getIbxMarkupOptions(row);
			$(row).ibxDataGridRow(opts);
			this.addRow(row);
			this._buildTreeFromMarkup(row);
		}

		//make yet more rows from markup...these are already constructed ibxDataGridRow objects.
		row = this.element.children(".ibx-data-grid-row").detach();
		this.addRow(row);

		//now visually clean up the grid.
		this.refresh();
	},
	_buildTreeFromMarkup:function(parentRow)
	{
		parentRow = $(parentRow);
		var children = !parentRow.length ? this.element.children("[data-grid-row]") : parentRow.children("[data-grid-row]");
		children.detach();
		for(var i = 0; i < children.length; ++i)
		{
			var childRow = children[i];
			var opts = ibx.getIbxMarkupOptions(childRow);
			$(childRow).ibxDataGridRow(opts);
			this.addRow(childRow);
			parentRow.ibxDataGridRow("addRow", childRow);
			this._buildTreeFromMarkup(childRow);
		}
	},
	initGrid:function(nRows, nCols, colConfig)
	{
		nRows = nRows || 0;
		nCols = nCols || 0;
		colConfig = colConfig || this.options.defaultColConfig;

		var colMap = [];
		var rows = [];
		for(var i = 0; i < nRows; ++i)
		{
			var row = $("<div>").ibxDataGridRow({"title":i+1});
			for(var j = 0; j < nCols; ++j)
			{
				var cell = $("<div>");
				row.append(cell);

				//only need to build the colMap for the first row.
				if(i > 0)
					continue;
				var curColConfig = $.extend({}, colConfig);
				curColConfig.title = "C " + (j+1);
				colMap.push(curColConfig);
			}
			this.options.colMap = colMap;
			rows.push(row);
		}
		this.updateHeaders();
		this.removeRow();
		this.addRows(rows);
	},
	getSelectionManager:function()
	{
		return this._sm;
	},
	updateHeaders:function(which)
	{
		which = which || "both";

		var options = this.options;
		var classes = options.classes;

		if(which == "column" || which == "both")
		{
			//this._colHeaderBar.empty();
			this._colHeaderBar.ibxWidget("remove");

			var flexing = false;
			var colMap = options.colMap;
			for(var i = 0; i < colMap.length; ++i)
			{
				var cInfo = colMap[i];
				
				//make default header if one isn't supplied
				var cHeading = $(cInfo.ui);
				if(!cHeading.length)
					cHeading = $("<div>").ibxButtonSimple({justify:cInfo.justify, text:cInfo.title});
				cHeading.ibxAddClass(classes.colHeaderClass).attr({tabindex:-1, role:"columnheader"});

				//make splitter
				var splitter = $(sformat("<div class='{1}'>", classes.colHeaderSplitterClass));
				splitter.ibxSplitter({locked:!cInfo.resizable, resize:"first", el1:cHeading}).on("ibx_resize ibx_reset", this._onSplitterResize.bind(this));
				splitter.on("click", function(e){e.stopPropagation()});//click on splitter not click on header!

				//now add the column header and set the size as everything is in the dom.
				cInfo._ui = {"idx":i, "header":cHeading, "curSize":null};
				cHeading.append(splitter).data("ibxDataGridCol", cInfo);
				this._colHeaderBar.ibxWidget("add", cHeading[0]);
				if(cInfo.size == "flex")
				{
					cHeading.css("flex", "1 1 auto");
					this.getColumn(i).css("flex", "1 1 auto");
					splitter.detach(); //flex columns don't have splitters
					flexing = true;
				}
				else
				{
					cHeading.css("flex", "");
					this.setColumnWidth(i, cInfo.size);
				}

				this.showColumn(i, cInfo.visible);
			}

			//adjust the grid options and padding based on flexing.
			this._grid.ibxWidget("option", "align", flexing ? "stretch" : "start").ibxToggleClass("dgrid-grid-flexing", flexing);
			if(!flexing)
			{
				var padding = $("<div>").css({"flex":"0 0 auto", "width":"50px", height:"1px"});
				this._colHeaderBar.append(padding);
			}
		}
	},
	getHeaders:function(row)
	{
		var headerBar = row ? this._rowHeaderBar : this._colHeaderBar;
		var headerClass = row ? this.options.classes.rowHeaderClass : this.options.classes.colHeaderClass;
		return headerBar.children("." + headerClass);
	},
	getCell:function(idxRow, idxCol)
	{
		var ret = null;
		var row = this.getRow(idxRow);
		return row.children(sformat(":nth-child({1})", idxCol + 1)) || null;
	},
	getCellPos:function(cell)
	{
		cell = $(cell);
		var options = this.options;
		var row = cell.closest("." + options.classes.gridRow);
		return {"column":cell.index(), "row":row.index()};
	},
	getColumnCount:function()
	{
		return this.options.colMap.length;
	},
	getColumnWidth:function(idxCol)
	{
		var cInfo = this.options.colMap[idxCol];
		return (cInfo && cInfo._ui && cInfo._ui.header) ? cInfo._ui.header.outerWidth() : cInfo.size;
	},
	setColumnWidth:function(idxCol, width)
	{
		var cInfo = this.options.colMap[idxCol];
		if(cInfo && cInfo._ui)
		{
			//this looks weird because the 'width' parm can be a string like "100px", and that has to be set, then we need the 
			//actual width...AND THEN...we need to subtract out the splitter width...oy vey!
			cInfo._ui.curSize = width;
			cInfo._ui.header.outerWidth(width);
			cInfo._ui.header.outerWidth(cInfo._ui.header.outerWidth());

			var cells = this.getColumn(idxCol);
			cells.outerWidth(cInfo._ui.header.outerWidth());
		}
	},
	getColumn:function(col)
	{
		var filter = isNaN(col) ? col : sformat(".{1} > :nth-child({2})", this.options.classes.gridRow, col + 1);
		return this._grid.find(filter);
	},
	showColumn:function(idxCol, show)
	{
		var cells = this.getColumn(idxCol);
		var cInfo = this.options.colMap[idxCol];
		if(cInfo)
		{
			cInfo.visible = show;
			if(cInfo._ui)
				cells = cells.add(cInfo._ui.header);
		}
		cells.ibxToggleClass("dgrid-col-hidden", !show);
	},
	selectColumn:function(idxCol, select, addSelection)
	{
		var cells = this.getColumn(idxCol);
		if(!addSelection)
			this._grid.ibxDataGridSelectionManager("deselectAll", true);
		this._grid.ibxDataGridSelectionManager("selected", cells.toArray(), select);
	},
	getRowCount:function()
	{
		return this._grid.children("." + this.options.classes.gridRow).length;
	},
	getRow:function(row)
	{
		var filter = isNaN(row) ? row : sformat(".{1}:nth-child({2})", this.options.classes.gridRow, row + 1);
		return this._grid.children(filter);
	},
	getRowIndex:function(row)
	{
		return this.getRow().index(row);
	},
	showRow:function(row, show)
	{
		var rows = this.getRow(row);
		rows.ibxDataGridRow("show", show);
	},
	selectRow:function(row, select, addSelection)
	{
		var cells = this.getRow(row).children();
		if(!addSelection)
			this._grid.ibxDataGridSelectionManager("deselectAll", true);
		this._grid.ibxDataGridSelectionManager("selected", cells.toArray(), select);
	},
	expandRow:function(row, expand)
	{
		if(this.options.indentColumn != -1)
		{
			row = row || "*";
			this.getRow(row).ibxDataGridRow("expand", expand);
		}
	},
	addRow:function(row, sibling, before)
	{
		row = $(row);
		if(!row.length)
			return;

		var options = this.options;

		//create extra cells if row has less than columns.
		while(row.children().length < options.colMap.length)
			row.append($("<div>"));

		//Happens a lot: DON'T USE JQUERY (VERY SLOW).
		var cells = row.children();
		for(var i = 0; i < cells.length; ++i)
		{
			var cell = cells[i];
			var cInfo = options.colMap[i] || options.defaultColConfig;
			cell.style.width = isNaN(cInfo._ui.curSize) ? cInfo._ui.curSize : cInfo._ui.curSize + "px";//if size is just a number assume pixels.
			cell.classList.add(options.classes.gridCell);
			
			//if the tabindex hasn't been set outside, then default to -1 (navkey/click access only...no tabbing between cells).
			if(!cell.getAttribute("tabindex"))
				cell.setAttribute("tabindex", -1);

			//aria stuff
			cell.setAttribute("role", "gridcell");
			cell.id = "dgrid-cell-id-" + (++$.ibi.ibxDataGrid._cellId);
		}

		//set row options and add to grid...refresh so columnIndent is correct.
		var rowData = row.data("ibxDataGridRow");
		row.attr("tabindex", -1);
		this._grid.ibxWidget("add", row, sibling, before);

		//add header in correct location.
		var sibData = $(sibling).data("ibxDataGridRow") || {header:null};
		this._rowHeaderBar.ibxWidget("add", rowData.header, sibData.header, before);

		//padding has to be always added to the end of the bar.
		var padding = this._rowHeaderPadding = this._rowHeaderPadding || $("<div>").css({"flex":"0 0 auto", "width":"1px", "height":"100px"});
		this._rowHeaderBar.append(padding);
		
		//next time a selection happens on grid, reacquire the selectable children.
		this._sm.updateSelectableCache();
	},
	addRows:function(rows, sibling, before)
	{
		for(var i = 0; i < rows.length; ++i)
			this.addRow(rows[i], sibling, before, false);
	},
	removeRow:function(row)
	{
		var row = (row instanceof Object) ? row : this.getRow(row);
		$(row).each(function(idx, row)
		{
			var widget = $(row).detach().data("ibxDataGridRow");
			widget.header.detach();
			widget.indentColumn = -1;
		}.bind(this));
	},
	removeAll:function()
	{
		this.removeRow("*");
	},
	_onSplitterResize:function(e, resizeInfo)
	{
		var el1Width = resizeInfo.el1.outerWidth();
		var cInfo = resizeInfo.el1.data("ibxDataGridCol");
		if(cInfo)
			this.setColumnWidth(cInfo._ui.idx, el1Width);
	},
	_onGridScroll:function(e)
	{
		var scrollX = this._grid.prop("scrollLeft");
		var scrollY = this._grid.prop("scrollTop");
		this._colHeaderBar.prop("scrollLeft", scrollX);
		this._rowHeaderBar.prop("scrollTop", scrollY);
	},
	_onGridSelChange:function(e)
	{
		var eType = e.type;
		var selInfo = e.originalEvent.data;
		if((eType == "ibx_beforeselchange") && !this.options.rowSelect && (selInfo.anchor !== selInfo.focus) && selInfo.selected)
		{
			//Handle selection in rows and columns...not done for rowSelect (obviously).
			var posAnchor = this.getCellPos(selInfo.anchor);
			var posFocus = this.getCellPos(selInfo.focus);
			var selCol = (posAnchor.column == posFocus.column) && (posAnchor.column != -1) && (posFocus.column != -1);
			var selRow = (posAnchor.row == posFocus.row) && (posAnchor.row != -1) && (posFocus.row != -1);
			if(selCol || selRow)
			{
				selInfo.items = selInfo.items.map(function(idx, el)
				{
					var ret = null;
					if(selCol && (this.getCellPos(el).column == posAnchor.column))
						ret = el;
					else
					if(selRow  && (this.getCellPos(el).row == posAnchor.row))
						ret = el;
					return ret;
				}.bind(this));
			}
		}
	},
	_setOption:function(key, value)
	{
		var changed = this.options[key] != value;
		var options = this.options;
		if(key == "colMap" && value)
		{
			//merge existing with new and default col info.
			var colMap = [];
			$.each(value, function(idx, colConfig)
			{
				var curColConfig = options.colMap[idx];
				colMap.push($.extend({}, options.defaultColConfig, curColConfig, colConfig));
			}.bind(this));
			options.colMap = colMap;
			this.updateHeaders("column");
			return;
		}
		else
		if(key == "defaultColConfig")
			value = $.extend({}, options.defaultColConfig, value);
		else
		if(key == "selType")
		{
			this._sm.option("type", value);
			value = "none";
		}
		else
		if(key == "rowSelect")
			this._sm.option("rowSelect", value);
		else
		if(key == "toggleSelection")
			this._sm.option("toggleSelection", value);
		this._super(key, value);
	},
	_refresh:function()
	{
		var options = this.options;
		this._colHeaderBar.ibxToggleClass("dgrid-header-bar-hidden", !options.showColumnHeaders);
		this._rowHeaderBar.ibxToggleClass("dgrid-header-bar-hidden", !options.showRowHeaders);
		this._super();
		this.getRow().ibxDataGridRow("refresh");
	},
});
$.ibi.ibxDataGrid._cellId = 0;

/******************************************************************************
	FLEX GRID
******************************************************************************/
$.widget("ibi.ibxFlexGrid", $.ibi.ibxHBox, 
{
	options:
	{
		"columnCount":12,
		"wrap":true,
		"childSizing":"border"
	},
	_widgetClass:"ibx-flex-grid",
	_create:function()
	{
		this._super();
	},
	_destroy:function()
	{
		this.remove(".ibx-flex-grid-cell");
		this._super();
	},
	remove:function(el, destroy, refresh)
	{
		this.children().removeAttr("data-grid-row data-grid-col data-grid-span").ibxRemoveClass("ibx-flex-grid-cell");
		this._super(el, destroy, refresh);
	},
	_colSize:-1,
	colSize:function()
	{
		return this._colSize;
	},
	row:function(row)
	{
		return this.children(sformat("[data-grid-row='{1}']", row));
	},
	column:function(col)
	{
		return this.children(sformat("[data-grid-col='{1}']", col));
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var colSize = this._colSize = (100/options.columnCount);
		var curRow = 0;
		var spanCount = 0;
		this.element.children().each(function(idx, cell)
		{
			cell = $(cell);
			if(spanCount >= options.columnCount)
			{
				curRow++;
				spanCount = 0;
			}
			colSpan = cell.data("ibxColSpan") || 1;
			var cellClasses = sformat("ibx-flex-grid-cell ibx-flex-grid-span-{1}", colSpan);
			var width = (colSpan * colSize);
			cell.ibxAddClass(cellClasses).css("width", sformat("{1}%", width));
			cell.attr({"data-grid-row": curRow, "data-grid-col": spanCount, "data-grid-span": colSpan});
			spanCount += colSpan;
		}.bind(this));
	}
});
$.ibi.ibxFlexGrid.statics = 
{
};
//# sourceURL=grid.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/propgrid.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.64 $:

/******************************************************************************
	PROPERTY GRID
******************************************************************************/
$.widget("ibi.ibxPropertyGrid", $.ibi.ibxDataGrid,
{
	options:
	{
		selType:"none",
		colMap:[{title:"Property", size:"15em", justify:"start"}, {title:"Value", size:"flex", justify:"start"}],
		showRowHeaders:false,
		indentColumn:0,
		props:null,
		aria:
		{
			label:"Property Grid"	
		}
	},
	_widgetClass:"ibx-property-grid",
	_create:function()
	{
		this._super();
		this.options.colMap[0].title = ibx.resourceMgr.getString("IBX_PGRID_COL_TITLE");
		this.options.colMap[1].title = ibx.resourceMgr.getString("IBX_PGRID_COL_VALUE");
		
		this.element.data("ibiIbxDataGrid", this);
		this._sm.option({focusResetOnBlur:true, rubberBand:false, rubberBandPartialSelect:false});
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		aria.label = ibx.resourceMgr.getString("IBX_PGRID_LABEL");
		return aria;
	},
	_buildPropTree:function(props, allRows)
	{
		var rows = [];
		for(var i = 0; props && i < props.length; ++i)
		{
			var prop = props[i];
			var row = $("<div>").ibxDataGridRow().ibxAddClass("pgrid-row").data("ibxProp", prop);
			var ui = this._createUI(prop);
			row.append([ui.nameCell, ui.editorCell]);
			rows.push(row);
			allRows.push(row);

			var children = this._buildPropTree(prop.props, allRows);
			row.ibxDataGridRow("addRow", children).ibxDataGridRow({"expanded":prop.expanded});
		}
		return rows;
	},
	_createUI:function(prop)
	{
		var ui = null;
		var event = this.element.dispatchEvent("ibx_propcreate", prop, false, true);	
		if(!event.isDefaultPrevented())
		{
			var uiType = $.ibi.ibxPropertyGrid.uiTypes[prop.uiType] || ibxTextProperty;
			ui = new uiType(prop, this.element);
			this.element.dispatchEvent("ibx_propcreated", prop, false, false);	
		}
		else
			ui = event.data.ui;
		return ui;
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		if(key == "props")
		{
			this.removeRow();
			var allRows = [];
			this._buildPropTree(value, allRows);
			this.addRows(allRows);
			this.updateHeaders();
			this.refresh();
		}
		this._super(key, value);
	},
});

$.ibi.ibxPropertyGrid.uiTypes = {"ibxProperty":ibxProperty};
$.ibi.ibxPropertyGrid.extendProperty = function(baseProp, propType, uiType)
{
	ibx.inPropCtor = true;
	var p = propType.prototype = new baseProp();
	ibx.inPropCtor = false;
	p.constructor = propType;
	propType.base = baseProp.prototype;
	$.ibi.ibxPropertyGrid.uiTypes[uiType] = propType;
	return p;
};

/********************************************************************************
 * BASE CLASS FOR IBX PROPERTY UI
********************************************************************************/
function ibxProperty(prop, grid)
{
	Object.call(this);
	if(ibx.inPropCtor) return;
	prop.ui = this;
	this.prop = prop;
	this.grid = grid;
	this.createUI();
	this.update();
}
var _p = ibxProperty.prototype = new Object();
_p.prop = null;
_p.grid = null;
_p.nameCell = null;
_p.editorCell = null;
_p.editor = null;
_p.displayValue = null;
_p.isEditing = function(){return this._valueCell.is(".pgrid-prop-editing");};
_p.createUI = function()
{
	var prop = this.prop;
	this.nameCell = this._createNameCell().ibxAddClass(["pgrid-cell","pgrid-name-cell"]);
	this.nameCell.attr("tabindex", 0).data("ibxProp", prop);

	this.editorCell = this.__createEditorCell().ibxAddClass(["pgrid-cell", "pgrid-editor-cell"]);
	this.editorCell.attr("tabindex", 0).data("ibxProp", prop);

	this.editor = this._createEditor().ibxAddClass("pgrid-editor").attr("tabindex", -1).data("ibxProp", prop);
	this.editor.on("keydown", this._onEditorKeyEvent.bind(this));
	this.editorCell.append(this.editor);
};
_p._createNameCell = function()
{
	return $("<div>").ibxLabel();
};
_p.__createEditorCell = function()
{
	//by default focus the actual editor when cell get's focus.
	return $("<div>").ibxHBox({focusDefault:true, align:"center"}).on("keydown keyup", this._onEditorCellKeyEvent.bind(this));
};
_p._createEditor = function()
{
	return $("<div>").ibxHBox({align:"center", nameRoot:true}).ibxAddClass("pgrid-prop");
};
_p._onEditorCellKeyEvent = function(e)
{
	if(e.type == "keyup" && e.keyCode == $.ui.keyCode.ENTER)
		this.editor.focus();
	else
	if(e.type == "keydown" && e.keyCode == $.ui.keyCode.ESCAPE)
		this.editorCell.focus();
};
_p._onEditorKeyEvent = function(e)
{
	if(e.type == "keydown" && e.keyCode != $.ui.keyCode.ESCAPE)
		e.stopPropagation();
}
_p._updateValue = function(newValue)
{
	var event = this.grid.dispatchEvent("ibx_propbeforeupdate", {"prop":this.prop, "newValue":newValue}, false, true);
	if(!event.isDefaultPrevented())
	{
		this.prop.value = event.data.newValue;
		this.grid.dispatchEvent("ibx_propupdated", {"prop":this.prop, "newValue":this.prop.value}, false, true);
	}
	else
		this.update();
	return this.prop.value;
};
_p.update = function()
{
	var prop = this.prop;
	this.nameCell.ibxWidget({text:this.prop.displayName}).prop("title", prop.nameTip);
	this.editorCell.prop("title", prop.valueTip || prop.value);
	this.editorCell.ibxWidget("option", "disabled", (prop.enabled === false) || false);
	this.editorCell.ibxWidget("option", "aria.label", ibx.resourceMgr.getString("IBX_PGRID_EDIT_CELL_LABEL") + (prop.valueTip || prop.nameTip));
};
/********************************************************************************
 * IBX PROPERTY UI FOR BASIC LABEL/GROUPING/SEPARATING
********************************************************************************/
function ibxLabelProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxLabelProperty, "label");
_p._createEditor = function()
{
	var prop = this.prop;
	var editor = ibxLabelProperty.base._createEditor.call(this);
	editor.text(prop.value);
	return editor.ibxAddClass("pgrid-prop-label");
};
_p.update = function()
{
	ibxLabelProperty.base.update.call(this);
	this.editor.attr("tabindex", "");
};
/********************************************************************************
 * IBX PROPERTY UI FOR BASIC TEXT ENTRY
********************************************************************************/
function ibxTextProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxTextProperty, "text");
_p._createEditor = function()
{
	return $("<div>").ibxEditable({editOnFocus:true}).on("focus blur ibx_canceledit ibx_changed ibx_textchanging", this._onEditEvent.bind(this)).ibxAddClass("pgrid-prop-text");
};
_p._onEditEvent = function(e)
{
	var eType = e.type;
	if(eType == "ibx_textchanging")
	{
		var newValue = e.originalEvent.data.newValue;
		this._updateValue(newValue);
	}
	else
	if(eType == "ibx_canceledit")
	{
		this.prop.value = e.originalEvent.data;
		this.update();
	}
};
_p.update = function()
{
	var prop = this.prop;
	ibxTextProperty.base.update.call(this);
	this.editor.text(prop.value);
};
/********************************************************************************
 * IBX PROPERTY UI FOR BUTTON
********************************************************************************/
function ibxButtonProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxButtonProperty, "button");
_p._createEditor = function()
{
	return $("<div>").ibxButton({align:"center"}).on("click", this._onButtonEvent.bind(this)).ibxAddClass("pgrid-prop-button");
};
_p._onButtonEvent = function(e)
{
	this._updateValue(this.prop.value);
};
_p.update = function()
{
	var prop = this.prop;
	ibxButtonProperty.base.update.call(this);
	return this.editor.ibxWidget("option", {text:this.prop.displayValue});
};
/********************************************************************************
 * IBX PROPERTY UI FOR CHECK BUTTON
********************************************************************************/
function ibxCheckBoxProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxCheckBoxProperty, "checkbox");
_p._createEditor = function()
{
	return $("<div>").ibxCheckBoxSimple().on("ibx_change", this._onCheckEvent.bind(this)).ibxAddClass("pgrid-prop-checkbox");
};
_p._onCheckEvent = function(e)
{
	var checked = $(e.target).ibxWidget("option", "checked");
	this._updateValue(checked);
};
_p.update = function()
{
	var prop = this.prop;
	ibxCheckBoxProperty.base.update.call(this);
	return this.editor.ibxWidget("option", {text:this.prop.displayValue, checked:this.prop.value});
};
/********************************************************************************
 * IBX PROPERTY UI FOR SWITCH
********************************************************************************/
function ibxSwitchProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxCheckBoxProperty, ibxSwitchProperty, "switch");
_p._createEditor = function()
{
	return $("<div>").ibxSwitch().on("ibx_change", this._onCheckEvent.bind(this)).ibxAddClass("pgrid-prop-switch");
};
_p.update = function()
{
	var prop = this.prop;
	ibxSwitchProperty.base.update.call(this);
	this.editor.ibxWidget("option", {text:this.prop.displayValue, checked:this.prop.value});
};
/********************************************************************************
 * IBX PROPERTY UI FOR RADIO GROUP
********************************************************************************/
function ibxRadioGroupProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxRadioGroupProperty, "radiogroup");
_p._createEditor = function()
{
	return $("<div>").ibxRadioGroup({wrap:false}).on("ibx_change", this._onChangeEvent.bind(this)).ibxAddClass("pgrid-prop-radiogroup");
};
_p._onChangeEvent = function(e)
{
	//will get a lot of ibx_change events from the child radio buttons...th displayValue represents the actual button group.
	if(this.editor.is(e.target))
	{
		var value = this.editor.ibxWidget("userValue");
		this._updateValue(value);
	}
};
_p.update = function()
{
	ibxRadioGroupProperty.base.update.call(this);

	var prop = this.prop;
	var editor = this.editor;
	var grpName = editor.ibxWidget("option", "name");
	var vals = prop.values;

	editor.ibxWidget("remove").ibxWidget("userValue", prop.value);
	for(var i = 0; i < vals.length; ++i)
	{
		var val = vals[i];
		var btn = $("<div class='pgrid-prop-radio-button' tabindex='-1'>").ibxRadioButtonSimple({text:val.displayValue, userValue:val.value});
		editor.ibxWidget("add", btn);
	}
};
/********************************************************************************
 * IBX PROPERTY UI FOR SELECT PICKER
********************************************************************************/
function ibxSelectProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxSelectProperty, "select");
_p._createEditor = function()
{
	var prop = this.prop;
	var editor = $("<div>").ibxSelect({multiSelect:prop.multiSelect}).on("ibx_change", this._onSelectEvent.bind(this));
	var openBtn = editor.find(".ibx-select-open-btn");
	openBtn.ibxWidget("option", "iconPosition", "top");
	return editor.ibxAddClass("pgrid-prop-select");
};
_p._onSelectEvent = function(e)
{
	var value = $(e.target).ibxWidget("userValue");
	this._updateValue(value);
};
_p.update = function()
{
	ibxSelectProperty.base.update.call(this);

	var prop = this.prop;
	var value = prop.value;//need to save because adding items resets the userValue?
	var editor = this.editor;
	editor.ibxWidget("removeControlItem");
	var vals = prop.values;
	for(var i = 0; i < vals.length; ++i)
	{
		var val = vals[i];
		var selItem = null;
		if(prop.multiSelect)
			selItem = $("<div>").ibxSelectCheckItem({text:val.displayValue, userValue:val.value});
		else
			selItem = $("<div>").ibxSelectItem({text:val.displayValue, userValue:val.value});
		editor.ibxWidget("addControlItem", selItem);
	}
	editor.ibxWidget("userValue", value);
};
/********************************************************************************
 * IBX PROPERTY UI FOR MENU BUTTON
********************************************************************************/
function ibxMenuProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxMenuProperty, "menu");
_p._createEditor = function()
{
	var editor = $("<div>").ibxMenuButton({showArrow:true}).on("ibx_select", this._onMenuSelect.bind(this));
	this.menu = editor.ibxWidget("option", "menu");
	return editor.ibxAddClass("pgrid-prop-select-menu");
};
_p._onMenuSelect = function(e)
{
	var prop = this.prop;
	var menuItem = $(e.originalEvent.data);
	var value = menuItem.ibxWidget("userValue");
	this._updateValue(value);
};
_p.update = function()
{
	ibxMenuProperty.base.update.call(this);
	var prop = this.prop;
	var menu = this.menu.ibxWidget("remove");
	for(var i = 0; i < prop.values.length; ++i)
	{
		var propValue = prop.values[i];
		var menuItem = $("<div>").ibxMenuItem({labelOptions:{text:propValue.displayValue}, userValue:propValue.value});
		menu.ibxWidget("add", menuItem);
	}
	this.editor.ibxWidget("option", "text", prop.displayValue);
};
/********************************************************************************
 * IBX PROPERTY UI FOR SELECT MENU BUTTON
********************************************************************************/
function ibxSelectMenuProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxSelectMenuProperty, "selectmenu");
_p.__createEditorCell = function()
{
	var editorCell = ibxSelectMenuProperty.base.__createEditorCell.call(this);
	return editorCell;
};
_p._createEditor = function()
{
	var editor = $("<div>").ibxSelectMenuButton().on("ibx_selchange", this._onMenuChange.bind(this));
	this.menu = editor.ibxWidget("option", "menu");
	return editor.ibxAddClass("pgrid-prop-select-menu");
};
_p._onMenuChange = function(e)
{
	var prop = this.prop;
	var value = e.originalEvent.data;
	if(prop.multiSelect)
		this._updateValue(value);
	else
	if(value.selected)
		this._updateValue(value);
};
_p.update = function()
{
	ibxSelectMenuProperty.base.update.call(this);
	var prop = this.prop;
	var menu = this.menu.ibxWidget("remove");
	for(var i = 0; i < prop.values.length; ++i)
	{
		var propValue = prop.values[i];
		var menuItem = $("<div>").ibxSelectMenuItem({text:propValue.displayValue, userValue:propValue.value});
		menu.ibxWidget("add", menuItem);
	}
	this.editor.ibxWidget("option", {defaultText:prop.displayValue, multiSelect:prop.multiSelect, userValue:prop.value});
};
/********************************************************************************
 * IBX PROPERTY UI FOR SLIDER
********************************************************************************/
function ibxSliderProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxSliderProperty, "slider");
_p._createEditor = function()
{
	var prop = this.prop;
	var slider = this.slider = $("<div tabindex='-1'>").ibxHSlider().ibxAddClass("pgrid-prop-slider-ctrl").on("ibx_change", this._onSliderEvent.bind(this));
	var sliderValue = this.sliderValue = $("<div>").ibxHBox({align:"center", justify:"center"}).ibxAddClass("pgrid-prop-slider-value");
	var editor = ibxSliderProperty.base._createEditor.call(this);
	editor.ibxWidget("option", {focusDefault:true}).ibxWidget("add", [sliderValue[0], slider[0]]);
	return editor.ibxAddClass("pgrid-prop-slider");
};
_p._onSliderEvent = function(e, data)
{
	var value = data.value;
	this._updateValue(value);
	this.sliderValue.text(this.prop.value);
};
_p.update = function()
{
	ibxSliderProperty.base.update.call(this);

	var prop = this.prop;
	this.slider.ibxWidget("option",
	{
		min:prop.valueMin,
		max:prop.valueMax,
		step:prop.step,
		value:prop.value, //must be set after min/max/step, or spinner will always round value to whole number.
		minTextPos:"center",
		maxTextPos:"center",
		popupValue:false,
	});
	this.sliderValue.text(prop.value);
};
/********************************************************************************
 * IBX PROPERTY UI FOR RANGE SLIDER
********************************************************************************/
function ibxRangeSliderProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxRangeSliderProperty, "rangeslider");
_p._createEditor = function()
{
	var prop = this.prop;
	var slider = this.slider = $("<div tabindex='-1'>").ibxHRange().ibxAddClass("pgrid-prop-slider-ctrl").on("ibx_change", this._onSliderEvent.bind(this));
	var sliderValue = this.sliderValue = $("<div>").ibxHBox({align:"center", justify:"center"}).ibxAddClass("pgrid-prop-slider-value");
	var sliderValue2 = this.sliderValue2 = $("<div>").ibxHBox({align:"center", justify:"center"}).ibxAddClass("pgrid-prop-slider-value");
	var editor = ibxRangeSliderProperty.base._createEditor.call(this);
	editor.ibxWidget("option", {focusDefault:true}).ibxWidget("add", [sliderValue[0], slider[0], sliderValue2[0]]);
	return editor.ibxAddClass("pgrid-prop-slider");
};
_p._onSliderEvent = function(e, data)
{
	var value = {"low":data.value, "high":data.value2};
	this._updateValue(value);
	this.sliderValue.text(value.low);
	this.sliderValue2.text(value.high);
};
_p.update = function()
{
	ibxSliderProperty.base.update.call(this);

	var prop = this.prop;
	this.slider.ibxWidget("option",
	{
		value:prop.value.low,
		value2:prop.value.high,
		min:prop.valueMin,
		max:prop.valueMax,
		step:prop.step,
		minTextPos:"center",
		maxTextPos:"center",
		popupValue:false,
	});
	this.sliderValue.text(prop.value.low);
	this.sliderValue2.text(prop.value.high);
};
/********************************************************************************
 * IBX PROPERTY UI FOR SPINNER
********************************************************************************/
function ibxSpinnerProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxSpinnerProperty, "spinner");
_p._createEditor = function()
{
	return $("<div>").ibxSpinner().on("ibx_change", this._onSpinnerEvent.bind(this)).ibxAddClass("pgrid-prop-spinner");
};
_p._onSpinnerEvent = function(e, data)
{
	var value = data.value;
	this._updateValue(value);
};
_p.update = function()
{
	ibxSliderProperty.base.update.call(this);

	var prop = this.prop;
	this.editor.ibxWidget("option",
	{
		value:prop.value || 0,
		min:prop.valueMin || 0,
		max:prop.valueMax || 100,
		step:prop.step || 1,
	});
};
/********************************************************************************
 * IBX PROPERTY UI FOR DATE
********************************************************************************/
function ibxDateProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxDateProperty, "date");
_p._createEditor = function()
{
	var prop = this.prop;
	this.datePicker = $("<div>").ibxDatePicker({type:"inline"}).on("ibx_change", this._onDateChange.bind(this));
	var editor = $("<div>").ibxMenuButton({showArrow:true});
	editor.ibxWidget("add", this.datePicker);
	return editor.ibxAddClass("pgrid-prop-date");
};
_p._onDateChange = function(e, data)
{
	this._updateValue(data.date);
	this.update();
};
_p.update = function()
{
	var prop = this.prop;
	ibxProperty.prototype.update.call(this);

	var fmt = prop.format || "mm/dd/yy";
	this.datePicker.ibxWidget("option", {date:prop.value, dateFormat:fmt});
	this.editor.ibxWidget("option", "text", prop.value);
};
/********************************************************************************
 * IBX PROPERTY UI FOR COLOR PICKER
********************************************************************************/
function ibxColorPickerProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxColorPickerProperty, "colorpicker");
_p._popup = null;
_p._createEditor = function()
{
	var colorPicker = this.colorPicker = $("<div tabindex='0'>").ibxColorPicker({setOpacity:false}).on("ibx_colorchange", this._onColorChange.bind(this));
	var menu = this.menu = $("<div class='pgrid-color-picker-menu'>").ibxMenu().ibxWidget("add", colorPicker);
	menu.on("ibx_close", this._onMenuClose.bind(this)).on("ibx_beforeopen", this._onBeforeMenuOpen.bind(this));
	var editor = $("<div>").ibxMenuButton({"menu":menu, "glyphClasses":"pgrid-color-picker-swatch"});
	var swatch = this.swatch = editor.find(".ibx-label-glyph");
	return editor.ibxAddClass("pgrid-prop-color-picker");
};
_p._onBeforeMenuOpen = function(e)
{
	var prop = this.prop;
	this.colorPicker.ibxWidget("option", {"color":prop.value.color, "opacity": prop.value.opacity ? prop.value.opacity : 1, "setOpacity": prop.value.opacity});
};
_p._onColorChange = function(e)
{
	var data = e.originalEvent.data;
	var prop = this.prop;
	prop.value.color = data.color;
	prop.value.opacity = data.opacity;
	this._updateValue(prop.value)
	this.editor.ibxWidget({text:prop.value.color});
	this.swatch.css({"backgroundColor": prop.value.color, "opacity": prop.value.opacity || 1});
};
_p._onMenuClose = function(e)
{
	//this makes sure when user clicks outside of popup this properly loses focus (stopEditing).
	this.editor.focus();
};
_p.update = function()
{
	ibxColorPickerProperty.base.update.call(this);
	var prop = this.prop;
	this.editor.ibxWidget("option", "text", prop.value.color).attr("title", ibx.resourceMgr.getString("IBX_PGRID_COLOR_PICKER_LABEL") + prop.value.color);
	this.swatch.css({"backgroundColor": prop.value.color, "opacity": prop.value.opacity || 1});
	var prop = this.prop;
};
/********************************************************************************
 * IBX PROPERTY UI FOR BORDER
********************************************************************************/
function ibxBorderProperty(prop, grid)
{
	ibxProperty.call(this, prop, grid);
	if(ibx.inPropCtor) return;
}
var _p = $.ibi.ibxPropertyGrid.extendProperty(ibxProperty, ibxBorderProperty, "border");
_p._createEditor = function()
{
	var editor = ibxBorderProperty.base._createEditor.call(this);
	editor.ibxWidget("option", "focusDefault", true);

	var ctrls = ibx.resourceMgr.getResource(".pgrid-prop-border-editor-template", false).children();
	editor.ibxWidget("add", ctrls);
	ibx.bindElements(editor);

	var widget = editor.data("ibxWidget");
	this.spinnerWidth = widget.spinnerWidth.on("ibx_change", this._onWidthChange.bind(this));
	this.btnStyle = widget.btnStyle.on("ibx_uservaluechanged", this._onStyleChange.bind(this));
	this.btnColor = widget.btnColor;
	this.swatch = this.btnColor.find(".ibx-label-glyph");
	this.colorMenu = widget.colorMenu;
	this.colorMenu.on("ibx_close", this._onMenuClose.bind(this)).on("ibx_beforeopen", this._onBeforeMenuOpen.bind(this));
	this.colorPicker = widget.colorPicker.on("ibx_colorchange", this._onColorChange.bind(this));
	return editor.ibxAddClass("pgrid-prop-border");
};
_p._onWidthChange = function(e, data)
{
	this.prop.value.width = data.value + "px";
	this._updateValue(this.prop.value);
	this.update();
};
_p._onStyleChange = function(e)
{
	var value = e.originalEvent.data;
	this.prop.value.style = value;
	this._updateValue(this.prop.value);
	this.update();
},
_p._onBeforeMenuOpen = function(e)
{
	var cInfo = this.prop.value.color;
	this.colorPicker.ibxWidget("option", {"color":cInfo.color, "opacity": cInfo.opacity ? cInfo.opacity : 1, "setOpacity": cInfo.opacity});
};
_p._onColorChange = function(e)
{
	var data = e.originalEvent.data;
	var cInfo = this.prop.value.color;
	cInfo.color = data.color;
	cInfo.color.opacity = data.opacity;
	this._updateValue(this.prop.value)
	this.update();
	this.editor.ibxWidget({text:cInfo.color});
	this.swatch.css({"backgroundColor": cInfo.color, "opacity": cInfo.opacity || 1});
};
_p._onMenuClose = function(e)
{
	//this makes sure when user clicks outside of popup this properly loses focus (stopEditing).
	this.editor.focus();
};

_p.update = function()
{
	var prop = this.prop;
	var cInfo = prop.value.color;
	this.spinnerWidth.ibxWidget("option", {value:parseInt(prop.value.width, 10)});
	this.btnStyle.ibxWidget("userValue", prop.value.style).css({borderStyle:prop.value.style, borderColor:cInfo.color, borderWidth:"2px"});

	this.swatch.css({"backgroundColor": cInfo.color, "opacity": cInfo.opacity || 1});
	this.btnColor.ibxWidget("option", {text:cInfo.color});
	this.btnColor.attr("title", ibx.resourceMgr.getString("IBX_PGRID_COLOR_PICKER_LABEL") + cInfo.color);
	ibxBorderProperty.base.update.call(this);
};
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/splitter.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.15 $:

$.widget("ibi.ibxSplitter", $.ibi.ibxWidget, 
{
	options:
	{
		"orientation":"vertical",
		"resize":"both",
		"locked":false,
		"autoReset":true,
		"el1":null,
		"el2":null,
	},
	_widgetClass:"ibx-splitter",
	_create:function()
	{
		this._super();
		this._fnSplitterMouseEvent = this._onSplitterMouseEvent.bind(this);//must save for later removal because of bind.
		this.element.on("mousedown dblclick", this._fnSplitterMouseEvent);
	},
	_onSplitterMouseEvent:function(e)
	{
		var options = this.options;
		var bVertical = (options.orientation == "vertical");
		var eType = e.type;

		//locked so no action taken.
		if(options.locked)
			return;

		var el1 = options.el1 ? $(options.el1) : this.element.prevAll(":visible").first();
		var el2 = options.el2 ? $(options.el2) : this.element.nextAll(":visible").first()

		if(eType == "mousedown")
		{
			if(!this._initialized)
			{
				//save initial sizes for dblclick reset.
				this._e1Info = {el:el1, width:el1.outerWidth(), height:el1.outerHeight()};
				this._e2Info =  {el:el2, width:el2.outerWidth(), height:el2.outerHeight()};
				this._initialized = true;
			}

			el1.ibxAddClass("ibx-splitter-sizing");
			el2.ibxAddClass("ibx-splitter-sizing");
			$(document.body).ibxAddClass(bVertical ? "ibx-body-splitter-v" : "ibx-body-splitter-h").css("pointerEvents", "none");
			$(document).on("mouseup mousemove", this._fnSplitterMouseEvent);
			this._eLast = e;
			this._trigger("resizestart", null, { "el1":el1, "el2":el2});
		}
		else
		if(eType == "mouseup")
		{
			el1.ibxRemoveClass("ibx-splitter-sizing");
			el2.ibxRemoveClass("ibx-splitter-sizing");
			$(document.body).ibxRemoveClass("ibx-body-splitter-v ibx-body-splitter-h").css("pointerEvents", "");
			$(document).off("mouseup mousemove", this._fnSplitterMouseEvent);
			delete this._eLast;
			this._trigger("resizeend", null, { "el1":el1, "el2":el2});
		}
		else
		if(eType == "mousemove")
		{
			
			var oe = e.originalEvent;
			var s1= bVertical ? el1.width() : el1.height();
			var s2 = bVertical ? el2.width() : el2.height();
			var m1 = parseInt(el1.css(bVertical ? "min-width" : "min-height"), 10);
			var m2 = parseInt(el2.css(bVertical ? "min-width" : "min-height"), 10);
			var dx = e.screenX - this._eLast.screenX;
			var dy = e.screenY - this._eLast.screenY;

			var s1Val = bVertical ? (s1+dx) : (s1+dy);
			s1Val = s1Val <= m1 ? 0 : s1Val;

			var s2Val = bVertical ? (s2-dx) : (s2-dy);
			s2Val = s2Val <= m2 ? 0 : s2Val;

			//don't let either side get smaller than 0 or min-width (min-height) calculated above
			if(s1Val <= 0 || s2Val <= 0)
				return;

			//set the actual widths
			if(options.resize == "both" || options.resize == "first")
				bVertical ? el1.width(s1Val).css("flex", "0 0 auto") : el1.height(s1Val).css("flex", "0 0 auto");

			if(options.resize == "both" || options.resize == "second")
				bVertical ? el2.width(s2Val).css("flex", "0 0 auto") : el2.height(s2Val).css("flex", "0 0 auto");

			this._trigger("resize", null, { "el1": el1, "el2": el2, "dx": dx, "dy": dy });
			this._eLast = e;
		}
		else
		if(eType == "dblclick" && this.options.autoReset)
			this.reset();
	},
	_destroy:function()
	{
		this._super();
		this.reset()
		this.element.ibxRemoveClass("ibx-splitter-v ibx-splitter-h");
	},
	reset:function()
	{
		var options = this.options;
		var el1 = this.element.prevAll(":visible").first();
		var el2= this.element.nextAll(":visible").first();
		
		if(options.resize == "both" || options.resize == "first")
			el1.css(this._e1Info);

		if(options.resize == "both" || options.resize == "second")
			el2.css(this._e2Info);
			
		this._trigger("reset", null, {"el1": el1, "el2": el2});
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var bVertical = (options.orientation == "vertical");
		this.element.ibxToggleClass("ibx-splitter-locked", options.locked);
		this.element.ibxRemoveClass("ibx-splitter-v ibx-splitter-h").ibxAddClass(bVertical ? "ibx-splitter-v" : "ibx-splitter-h");
	}
});
$.widget("ibi.ibxHSplitter", $.ibi.ibxSplitter, {options:{orientation:"horizontal"}, _widgetClass:"ibx-splitter-horizontal"});
$.widget("ibi.ibxVSplitter", $.ibi.ibxSplitter, {options:{orientation:"vertical"}, _widgetClass:"ibx-splitter-vertical"});
$.ibi.ibxSplitter.statics = 
{
}
//# sourceURL=splitter.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/label.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.65 $:

$.widget("ibi.ibxLabel", $.ibi.ibxFlexBox, 
{
	options:
	{
		"text":"",
		"textWrap":false,
		"textAlign":"",
		"textIsHtml":false,
		"textElClass":"ibx-label-text",
		"iconPosition":"left",
		"icon":"",
		"iconClasses":"ibx-label-icon",
		"glyph":"",
		"glyphClasses":"",
		"glyphElClass":"ibx-label-glyph",
		"glyphElSpacerClass":"ibx-glyph-spacer",

		"for":null, //make labels work like <label>...focus target on click.

		/*label overlays...array of objects: {"position":"xx", "glyph":"xx", "glyphClasses":"xx", "icon":"xx", "iconClasses":"xx"}*/
		"overlays":[],

		/*ibxFlexBox default options*/
		"inline":true,
		"wrap":false,
		"justify":"start",
		"align":"center",
	},
	_widgetClass:"ibx-label",
	_text:null,
	_icon:null,
	_glyph:null,
	_create:function()
	{
		this._super();
		var options = this.options;

		//handle the for option
		this.element.on("focus mousedown", this._onLabelEvent.bind(this));

		//alternate to data-ibxp-text...direct text node children can be used to set the text.
		options.text = options.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");

		//add the sub-elements
		this._glyph = $("<div>").ibxAddClass(options.glyphElClass);
		this._text = $("<div>").ibxAddClass(options.textElClass);
		this.element.append(this._glyph, this._text);
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);
		accessible ? this._glyph.attr("aria-hidden", true) : this._glyph.removeAttr("aria-hidden");
		if(options.for)
		{
			var target = $(options.for);
			var id = this.element.prop("id");
			accessible ? target.attr("aria-labelledby", id) : target.removeAttr("aria-labelledby", id);
		}
		return aria;
	},
	_destroy:function()
	{
		this._super();
		this._glyph.remove();
		this._text.remove();
		this.element.ibxRemoveClass("icon-left icon-top icon-right icon-bottom");
	},
	isEditing:function()
	{
		return this._text.is(".ibx-content-editing");
	},
	startEditing:function(editOptions)
	{
		this._text.ibxEditable().ibxEditable("startEditing", editOptions);
	},
	stopEditing:function(revertToOriginal)
	{
		if(this._text.is(".ibx-editable"))
			this._text.ibxEditable("stopEditing", revertToOriginal);

	},
	_onLabelEvent:function(e)
	{
		var options = this.options;
		if(options.for)
		{
			$(options.for).focus();
			e.preventDefault();
		}
	},
	_refresh:function()
	{
		var options = this.options;
		var lastOptions = this._lastOptions || {};

		var glyphVisible = options.glyph || options.glyphClasses;

		//only update if changed
		if(options.icon != lastOptions.icon)
			this._glyph.ibxRemoveClass(lastOptions.iconClasses).ibxAddClass(options.iconClasses).css("backgroundImage", options.icon ? sformat("url('{1}')", options.icon) : "");

		//only update if changed
		if(options.glyph != lastOptions.glyph || options.glyphClasses != lastOptions.glyphClasses)
			this._glyph.html(options.glyph);	
		this._glyph.ibxRemoveClass(lastOptions.glyphClasses).ibxAddClass(options.glyphClasses).ibxAddClass(options.glyphElClass);
		this._glyph.css("display", (!glyphVisible && !options.icon) ? "none" : "");

		//only update if changed
		if(options.text != lastOptions.text)
			options.textIsHtml ? this._text.html(options.text) : this._text.text(options.text);
		this._text.ibxRemoveClass(lastOptions.textElClass).ibxAddClass(options.textElClass).css({"text-align":options.textAlign, "white-space":options.textWrap ? "" : "nowrap"});

		//[IBX-131] flexbox align center doesn't work correctly in IE with text wrapping...must be set to stretch and then center text automatically.
		//this causes an inconsistency with other browsers...ie will center text when wrapped other won't.  
		//SO EXPLICITLY TELL USERS TO SPECIFY THE TEXT-ALIGN THEY WANT IF WRAPPING IS ON AND WIDTH IS FIXED.
		if(ibxPlatformCheck.isIE)
		{
			if(options.align == "center" && options.textWrap == true && (options.iconPosition == "top" || options.iconPosition == "bottom"))
				this._text.css("alignSelf", "stretch").css("textAlign", options.textAlign || "center");
			else
				this._text.css("alignSelf", "");
		}

		//add appropriate spacer classes
		this._glyph.ibxToggleClass(this.options.glyphElSpacerClass, !!((options.icon || options.glyph || options.glyphClasses) && options.text));

		//general options maintenance
		this.element.ibxRemoveClass("icon-left icon-top icon-right icon-bottom");
		this.element.ibxAddClass("icon-" + options.iconPosition);
		this.element.ibxToggleClass("ibx-label-no-icon", !glyphVisible && !options.icon).ibxToggleClass("ibx-icon-only", !glyphVisible && !options.text);

		//handle overlays
		this._glyph.children(".ibx-label-overlay-frame").remove();
		for(var i = 0; i < options.overlays.length; ++i)
		{
			var overlay = options.overlays[i];
			var elFrame = $("<label class='ibx-label-overlay-frame'>").ibxAddClass(overlay.position);
			this._glyph.append(elFrame);
			
			var elOverlay = null;
			if(overlay.icon)
				elOverlay = $(sformat("<img class='ibx-label-overlay {1}' src='{2}'/>", overlay.iconClasses || "ibx-overlay-image", overlay.icon));
			else	
				elOverlay = $("<span class='ibx-label-overlay'>").ibxAddClass(overlay.glyphClasses).text(overlay.glyph);

			elFrame.append(elOverlay);
		}


		//save the current option values...this is to optimize the next refresh
		this._lastOptions = $.extend({}, options);
		this._super();
	}
});
$.ibi.ibxLabel.statics = 
{
};
//# sourceURL=label.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/tree.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.93 $:

$.widget("ibi.ibxTreeSelectionManager", $.ibi.ibxSelectionManager,
{
	"options":
	{
		"type":"single",
		"toggleSelection":false,
		"escClearSelection":true,
	},
	_onMouseEvent:function(e)
	{
		//clicking on the node's button...or if the node is editing...then don't do normal selection stuff!
		var target = $(e.target);
		var nodeBtn = target.is(".tnode-btn");
		var isEditing = this.mapToSelectable(e.target).ibxWidget("isEditing");
		if(!nodeBtn && !isEditing)
			this._super(e);
	},
	_onKeyDown:function(e)
	{
		if([$.ui.keyCode.LEFT, $.ui.keyCode.RIGHT].indexOf(e.keyCode) == -1)
		{
			var nodeLabel = this.mapToSelectable(e.target);
			var isEditing = nodeLabel.ibxWidget("isEditing");
			if(!isEditing)
				this._super(e);
		}
	},
	mapToSelectable:function(el)
	{
		el = $(el).map(function(idx, el)
		{
			el = $(el);
			el = el.is(".ibx-tree-node") ? el.children(".tnode-label") : el.closest(".tnode-label", this.element);
			return el[0];
		}.bind(this));
		return el;
	},
	mapFromSelectable:function(el)
	{
		return $(el).closest(".ibx-tree-node", this.element);
	},
});

$.widget("ibi.ibxTree", $.ibi.ibxVBox, 
{
	options:
	{
		"navKeyRoot":true,
		"navKeyDir":"vertical",
		"navKeyResetFocusOnBlur":false,
		"focusDefault":true,
		"selType":"single",
		"showRootNodes":true,
		"singleClickExpand":false,
		"inline":true,
		"align":"stretch",
		"aria":
		{
			"role":"tree",
		}
	},
	_widgetClass:"ibx-tree",
	_create:function()
	{
		this._super();
		this.element.ibxMutationObserver({"listen":true, "subtree":true}).on("ibx_nodemutated", this._onChildrenChange.bind(this));
		this.element.ibxTreeSelectionManager();
		this.add(this.children());
	},
	_destroy:function()
	{
		this._super();
	},
	add:function(el, elSibling, before, refresh)
	{
		$(el).ibxAddClass("tnode-root");
		this._super(el, elSibling, before, refresh);
	},
	remove:function(el, destroy, refresh)
	{
		this.children().filter(el).ibxRemoveClass("tnode-root");
		this._super(el, destroy, refresh);
	},
	rootNodes:function()
	{
		return this.children(".tnode-root");
	},
	_onChildrenChange:function(e)
	{
		var mRecs = e.originalEvent.data;
		$(mRecs).each(function(idx, rec)
		{
			$(rec.addedNodes).each(function(idx, el)
			{
				var widget = $(el).data("ibxWidget");
				if(!widget || !widget.element.is(".ibx-tree-node"))
					return;
				widget.refreshIndent(null, true);
			}.bind(this));
		}.bind(this));
	},
	treeNodes:function(selector)
	{
		return this.element.find(selector || ".ibx-tree-node");
	},
	refresh:function(withChildren)
	{
		this._super();
		if(withChildren)
			this.element.find(".ibx-tree-node").ibxWidget("refresh");
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var children = this.children();
		children.each(function(idx, child)
		{
			var childWidget = $(child).data("ibxWidget");
			childWidget.option("virtualParent", !options.showRootNodes);
		}.bind(this));
		this.element.ibxSelectionManager("option", "type", options.selType);
	}
});

$.widget("ibi.ibxTreeNode", $.ibi.ibxVBox, 
{
	options:
	{
		"virtualParent":false, //used for root nodes mostly...hides this node and makes children look like peers (not indented).
		"labelOptions":{},
		"btnCollapsed":"tnode-btn-collapsed",
		"btnExpanded":"tnode-btn-expanded",
		"expanded":false,
		"container":false,
		"indent":null, //can override the default indent for this node

		"align":"stretch",

		"aria":{}
	},
	_widgetClass:"ibx-tree-node",
	_createWidget:function(options, element)
	{
		//set the static default tree indent...do it this way so we can define via css.
 		if($.ibi.ibxTreeNode.defaultIndent === null)
		{
			var tmp = $("<div class='tnode-indent' style='display:none'>");
			tmp.appendTo("body");
			$.ibi.ibxTreeNode.defaultIndent = parseFloat(tmp.css("paddingLeft"));
			tmp.remove();
		}
		this._super(options, element);
	},
	_create:function()
	{
		var options = this.options;
		this._super();
		this.nodeLabel = $("<div tabindex='-1' class='tnode-label'>").ibxLabel().appendTo(this.element).data("ibxTreeNode", this.element);
		this.nodeLabel.on("keydown click dblclick", this._onNodeLabelEvent.bind(this));
		options.labelOptions.text = options.labelOptions.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");

		this.btnExpand = $("<div class='tnode-btn'>").prependTo(this.nodeLabel).on("mousedown click", this._onBtnExpandClick.bind(this));

		//add the markup children correctly.
		this._childBox = $("<div class='tnode-children'>").ibxVBox().appendTo(this.element);
		var nodes = this.element.children(".ibx-tree-node");
		options.container = options.container || nodes.length;//children from markup turn this into a container by default.
		this.add(nodes);
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		var options = this.options;
		var ariaOptions = 
		{
			"accessible": accessible,
			"role":"treeitem",
			"level": this.depth() + 1,
		}
		options.container ? (ariaOptions.expanded = this.expanded()) : null;
		this.nodeLabel.ibxWidget("option", "aria", ariaOptions);
		return aria;
	},
	_destroy:function()
	{
		this._super();
	},
	children:function(selector)
	{
		return this._childBox.ibxWidget("children", selector || ".ibx-tree-node");
	},
	add:function(el, elSibling, before, refresh)
	{
		this._childBox.ibxWidget("add", el, elSibling, before, refresh);
		$(el).data("ibxTreeParent", this.element[0]);
		if(refresh)
			this.refresh();
	},
	remove:function(el, destroy, refresh)
	{
		this.children().filter(el).removeData("ibxTreeParent");
		this._childBox.ibxWidget("remove", el, destroy, refresh);
		if(refresh)
			this.refresh();
	},
	isEditing:function()
	{
		return this.nodeLabel.is(".ibx-content-editing");
	},
	startEditing:function(editOptions)
	{
		this.nodeLabel.data("ibxWidget")._text.ibxEditable().ibxEditable("startEditing", editOptions);
	},
	stopEditing:function(revertToOriginal)
	{
		if(this.nodeLabel.is(".ibx-editable"))
			this.nodeLabel.ibxEditable("stopEditing", revertToOriginal);

	},
	depth:function()
	{
		return this.element.parents(".ibx-tree-node:not(.tnode-virtual-parent)").length;	
	},
	tree:function()
	{
		return this.element.closest(".ibx-tree")[0];
	},
	parentNode:function()
	{
		var parent = this.element.data("ibxTreeParent");
		return parent ? parent : null;
	},
	hasChildren:function()
	{
		return !!this._childBox.children(".ibx-tree-node").length;
	},
	singleClickExpand:function()
	{
		return $(this.tree()).ibxWidget("option", "singleClickExpand");
	},
	_onNodeLabelEvent:function(e)
	{
		var options = this.options;
		var eType = e.type;

		var ibxType = "ibx_" + eType;
		var ibxEvent = this.element.dispatchEvent(ibxType, e, true, true);
		if(!ibxEvent.isDefaultPrevented())
		{
			if(eType == "click" && this.singleClickExpand())
				this.toggleExpanded();
			else
			if(eType == "dblclick")
				this.toggleExpanded();
			else
			if(eType == "keydown")
			{
				if(this.nodeLabel.ibxWidget("isEditing"))
				{
					e.stopPropagation();
					return;
				}
				if(e.keyCode === $.ui.keyCode.RIGHT)
				{
					if(!this.expanded())
						this.toggleExpanded(true);
					else
						this.children().first().find(".tnode-label").first().focus();
				}
				else
				if(e.keyCode === $.ui.keyCode.LEFT)
				{
					if(this.expanded())
						this.toggleExpanded(false);
					else
						$(this.parentNode()).children(".tnode-label").first().focus();
				}
			}
		}
	},
	_onBtnExpandClick:function(e)
	{
		if(e.type == "click")
			this.toggleExpanded();
		e.stopPropagation();//click/mousedown on button should not change tree selection...this stops that
	},
	toggleExpanded:function(expand)
	{
		expand = (expand === undefined) ? !this.options.expanded : expand;
		this.expanded(expand);
	},
	expanded:function(expanded)
	{
		if(expanded === undefined)
			return this.options.expanded;

		//only expand containers...stops unneeded refreshes!
		if(this.options.container)
			this.option("expanded", expanded);
	},
	_onExpanded:$.noop,
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = (this.options[key] != value);
		if(key == "expanded" && changed && options.container)
		{
			var tree = this.tree();
			var eType = value ? "ibx_beforeexpand" : "ibx_beforecollapse";
			var evt = this.element.dispatchEvent(eType, null, true, true, tree);
			if(!evt.defaultPrevented)
			{
				this._super(key, value);
				eType = value ? "ibx_expand" : "ibx_collapse";
				this.element.dispatchEvent(eType, null, true, false, tree);
				this._onExpanded(value);
			}
		}
		else
			this._super(key, value);
	},
	isRoot:function()
	{
		return this.element.is(".tnode-root");
	},
	refresh:function(withChildren)
	{
		this._super();
		if(withChildren && this.options.expanded)
			this.children().ibxWidget("refresh", true);
	},
	refreshIndent:function(depth, withChildren)
	{
		var newDepth = depth || this.depth();
		var options = this.options;
		var indent = (options.indent !== null) ? options.indent : $.ibi.ibxTreeNode.defaultIndent;
		this.nodeLabel.css("paddingLeft", newDepth * indent);
		this.setAccessibility();
		if(withChildren)
			this.children().ibxWidget("refreshIndent", depth, withChildren);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var children = this.children();
		var showLabel = (options.container && options.virtualParent) ? false : true;

		this.refreshIndent();//indent this node correctly under parent.

		this.nodeLabel.ibxWidget("option", options.labelOptions).css("display", !showLabel ? "none" : "");
		this.element.ibxToggleClass("tnode-virtual-parent", options.virtualParent).ibxToggleClass("tnode-is-container", options.container).ibxToggleClass("tnode-expanded", options.expanded);
		this.element.ibxToggleClass("tnode-has-parent", !!this.element.data("ibxTreeParent"));
		this.btnExpand.ibxToggleClass("tnode-btn-root", this.isRoot()).ibxRemoveClass([options.btnCollapsed, options.btnExpanded]);
		if(options.container)
			(options.expanded) ? this.btnExpand.ibxAddClass(options.btnExpanded) : this.btnExpand.ibxAddClass(options.btnCollapsed);
	}
});
$.ibi.ibxTreeNode.defaultIndent = null;


$.widget("ibi.ibxTreeBrowser", $.ibi.ibxVBox, 
{
	options:
	{
		"swipeNavigation":true,
		"scrollChildren":true,
		"navKeyRoot":true,
		"navKeyDir":"vertical",
		"navKeyResetFocusOnBlur":false,
		"focusDefault":true,
		"selType":"single",
		"inline":true,
		"align":"stretch",
		"aria":
		{
			"role":"tree",
		}
	},
	_widgetClass:"ibx-tree-browser",
	_create:function()
	{
		this._super();
		var options = this.options;
		this.element.ibxMutationObserver({"listen":true, "subtree":true}).on("ibx_nodemutated", this._onChildrenChange.bind(this));
		this.element.ibxAddClass("ibx-tree").on("swiperight", this._onTreeSwipeEvent.bind(this)).ibxTreeSelectionManager();
		this.add(this.children());
	},
	_destroy:function()
	{
		this._super();
	},
	add:function(el, elSibling, before, refresh)
	{
		var curRoot = this.children(".tnode-root").ibxRemoveClass("tnode-root");
		this.remove(curRoot);
		
		$(el).ibxAddClass("tnode-root");
		this._super(el, elSibling, before, refresh);
		this.element.ibxSelectionManager("deselectAll", true, true).ibxSelectionManager("selected", el, true).ibxSelectionManager("focus", el, true);
		$(el).ibxTreeNode("expanded", true).ibxTreeNode("refreshIndent", 0, true);
		this.refresh();
	},
	remove:function(el, destroy, refresh)
	{
		this.children().ibxRemoveClass("tnode-root");
		this._super(el, destroy, refresh);
	},
	_onChildrenChange:function(e)
	{
		var mRecs = e.originalEvent.data;
		$(mRecs).each(function(idx, rec)
		{
			$(rec.addedNodes).each(function(idx, el)
			{
				var widget = $(el).data("ibxWidget");
				if(!widget || !widget.element.is(".ibx-tree-node"))
					return;
				widget.refreshIndent(null, true);
			}.bind(this));
		}.bind(this));
	},
	_onTreeSwipeEvent:function(e)
	{
		if(this.options.swipeNavigation)
			this.children(".tnode-root").ibxWidget("expanded", false);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		this.children(".tnode-root").ibxToggleClass("tnode-scroll-children", options.scrollChildren);
	}
});

$.widget("ibi.ibxTreeBrowserNode", $.ibi.ibxTreeNode, 
{
	options:
	{
	},
	_widgetClass:"ibx-tree-browser-node",
	_create:function()
	{
		var options = this.options;
		this._super();
		this.element.data("ibiIbxTreeNode", this);
		this.nodeLabel.on("swipeleft", this._onNodeLabelEvent.bind(this));
		this.add(this.children());
	},
	_destroy:function()
	{
	},
	_onNodeLabelEvent:function(e)
	{
		var tree = $(this.tree());
		if(e.type == "dblclick" && this.options.isRoot)
			return;
		else
		if(e.type == "swipeleft" && tree.ibxWidget("option", "swipeNavigation"))
			this.expanded("false");
		this._super(e);
	},
	_onExpanded:function(expanded)
	{
		var tree = $(this.tree()).data("ibxWidget");
		if(expanded)
		{
			this.element.after("<div class='ibx-tree-node-placeholder'>");//replace this node with a placeholder
			tree.add(this.element);//make this node the tree root
		}
		else
		{
			tree.remove(this.element);//correctly removes this from tree...like .tnode-root
			var parent = this.element.data("ibxTreeParent");//get it's current  parent
			$(parent).ibxWidget("add", this.element, ".ibx-tree-node-placeholder").ibxWidget("remove", ".ibx-tree-node-placeholder");//add back and kill placeholder.
			tree.add(parent);//move up a level...make parent the root.
		}
	},
	_setOption:function(key, value)
	{
		//can't collapse the top tree node...nowhere to run to, baby...nowhere to hide!
		if(key == "expanded" && this.isRoot() && !this.parentNode())
			value = true;
		this._super(key, value);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var isRoot = this.isRoot();

		///move the expand/collapse button depending on whether it's the root node.
		isRoot ? this.btnExpand.prependTo(this.nodeLabel) : this.btnExpand.appendTo(this.nodeLabel);
	}
});

//# sourceURL=tree.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/progress.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.42 $:

/******************************************************************************
	PROGRESS WIDGET
******************************************************************************/
$.widget("ibi.ibxProgressBar", $.ibi.ibxHBox, 
{
	options:
	{
		"minVal":0,
		"maxVal":100,
		"curVal":0,

		"markerClasses":"",

		"showProgText":false,
		"progText":"",
		"progTextClasses":"",
		"progArea":"body",

		//flexbox options
		"inline":true,
		"align":"stretch",

		"aria":
		{
			"role":"progressbar",
			"live":"assertive",
		},
	},
	_widgetClass:"ibx-progress-bar",
	_create:function()
	{
		this._super();
		this.progText = $("<div class='ibx-progress-label'>").ibxHBox({align:"stretch", justify:"end"});
		this.progMarker = $("<div class='ibx-progress-marker ibx-progress-marker-start-end'>").ibxHBox({align:"stretch"});
		this.element.append(this.progMarker);
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		var options = this.options;

		aria.valuemin = options.minVal;
		aria.valuemax = options.maxVal;
		aria.valuenow = options.curVal;
		aria.describedby = aria.describedby || this.progText.prop("id");

		var progArea = $(options.progArea);
		(accessible && this.inProgress()) ? progArea.attr("aria-busy", true) : progArea.removeAttr("aria-busy");

		return aria;
	},
	_destroy:function()
	{
		this._super();
		this.progText.ibxWidget("destroy").ibxRemoveClass("ibx-progress-label");
		this.progMarker.ibxWidget("destroy").ibxRemoveClass("ibx-progress-marker-start-end, ibx-progress-marker-end-start, ibx-progress-complete");
	},
	inProgress:function()
	{
		var options = this.options;
		return (options.curVal > options.minVal && options.curVal < options.maxVal);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;

		this._trigger("format_value", null, {"curValue": options.curVal});
		this.progText.text(options.showProgText ? (options.progText || options.curVal) : "");

		var flex = (options.curVal >= options.maxVal) ? 1 : ((options.curVal - options.minVal)/(options.maxVal - options.minVal));
		this.progMarker.css("flex-grow", flex).ibxAddClass(options.markerClasses).ibxToggleClass("ibx-progress-marker-complete", (flex == 1));
		this.progText.css("flex-grow", 1-flex).ibxAddClass(options.progTextClasses);
	
		this.element.append(this.progMarker, this.progText);
	}
});

$.widget("ibi.ibxIndeterminateProgressBar", $.ibi.ibxProgressBar, 
{
	options:
	{
	},
	_widgetClass:"ibx-indeterminant-progress-bar",
	_create:function()
	{
		this._super();
	},
	_idTimer:null,
	start:function(nTime)
	{
		this.stop();
		window.setInterval(this._onProgress.bind(this))
	},
	stop:function(e)
	{
		window.clearInterval(this._idTimer);
		this._idTimer = null;
	},
	_onProgress:function()
	{
	},
	inProgress:function()
	{
		var options = this.options;
		return (options.curVal > options.minVal && options.curVal < options.maxVal);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
	}
});

/******************************************************************************
	WAITING WIDGET
******************************************************************************/
$.widget("ibi.ibxWaiting", $.ibi.ibxLabel, 
{
	options:
	{
		"waiting":false,
		"stretch":false,
		"align":"center",
		"justify":"center",
		"iconPosition":"top",
		"glyphClasses":"fa fa-spin fa-spinner",
		"text":"",
		"textWrap":true,
		"textAlign":"center",
		"aria":
		{
			"role":"alert",
			"live":"polite",
			"relevant":"all",
			"valuemin":0,
			"valuemax":100,
		}
	},
	_widgetClass:"ibx-waiting",
	_create:function()
	{
		this._super();
		this.element.attr("tabIndex", 0);
		this.element.on("mousedown mouseup mousemove click keydown keyup keypress", function(e){e.preventDefault();e.stopPropagation();});
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		var options = this.options;
		aria.describedby = aria.describedby || this._text.prop("id");
		var waitArea = $(options.waitArea || this.element.parent());
		(accessible && options.waiting) ? waitArea.attr("aria-busy", true) : waitArea.removeAttr("aria-busy");
		return aria;
	},
	_destroy:function()
	{
		this._super();
	},
	message:function(msg, isHtml)
	{
		if(msg)
		{
			//do directly so as not to interrupt animation of icon/glyph.  If we set this via
			//the regular ibxLabel options it will cause a refresh which will restart animation.
			this.options.text = msg;
			this.options.textIsHtml = isHtml;
			isHtml ? this._text.html(msg) : this._text.text(msg);
			return this.element;
		}
		else
			return this.options.text;
	},
	_waitElement:null,
	_startDate:null,
	startDate:function()
	{
		return this._startDate;
	},
	start:function(el, message)
	{
		this.stop();

		el = $(el || this._waitElement || document.body);

		//kill any existing wait on the specified element.
		var waitInfo = el.data("ibxWaitingInfo");
		if(waitInfo)
			waitInfo.ibxWaiting.ibxWidget("stop");

		//create and attach new waitInfo to new element.
		waitInfo = {initPos:el.css("position"),	ibxWaiting:this.element};
		if(waitInfo.initPos == "static")
			el.css("position", "relative");
		el.data("ibxWaitingInfo", waitInfo).append(this.element);

		this._waitElement = el[0];
		this.options.waiting = true;
		this._startDate = new Date();
		this.option("text", message);
		window.requestAnimationFrame(this._doWait.bind(this));
	},
	stop:function()
	{
		this.element.detach();
		var waitElem = $(this._waitElement);
		if(waitElem.length)
		{
			var waitInfo = waitElem.data("ibxWaitingInfo");
			waitElem.css("position", waitInfo.initPos).removeData("ibxWaitingInfo");
		}

		this.options.waiting = false;
		this._startDate = null;
	},
	_doWait:function(timestampe)
	{
		var options = this.options;
		if(options.waiting)
		{
			var event = this.element.dispatchEvent("ibx_waiting", this._startDate, false, true);
			if(event.isDefaultPrevented())
				this.waitStop();
			else
				window.requestAnimationFrame(this._doWait.bind(this));
		}
	},
	_refresh:function()
	{
		var options = this.options;
		this._glyph.ibxToggleClass("wait-stretch", options.stretch)
		this._super();
	}
});

/******************************************************************************
	COMBINDED WAITING PROGRESS WIDGET
******************************************************************************/
$.widget("ibi.ibxWaitingProgressBar", $.ibi.ibxWaiting, 
{
	options:
	{
		showProgress:true,
		progOptions:{},
	},
	_widgetClass:"ibx-waiting-progress-bar",
	_create:function()
	{
		this._super();
		this.progress = $("<div>").ibxProgressBar();
		this.element.append(this.progress);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		this.progress.css("display", options.showProgress ? "" : "none").ibxWidget("option", options.progOptions);
	}
});


ibx.waitStart = function(el, message)
{
	var waiting = $();
	var global = !el;
	$(el || "body").each(function(message, idx, el)
	{
		el = $(el);

		//kill any current waiting with this element.
		ibx.waitStop(el);

		//make a new wait widget and start 'er up!
		var waitTemp = $("<div>").ibxAddClass(global ? "ibx-waiting-global" : null).ibxWaiting();
		waitTemp.ibxWidget("start", el, message);
		waiting = waiting.add(waitTemp);
	}.bind(this, message));
	return waiting;
};
ibx.waitStop = function(el)
{
	$(el || "body").filter(":data('ibxWaitingInfo')").each(function(idx, el)
	{
		el = $(el);
		var waitInfo = el.data("ibxWaitingInfo");
		waitInfo.ibxWaiting.ibxWidget("stop");
	});
};

//# sourceURL=progress.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/text.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.58 $:

$.widget("ibi.ibxTextField", $.ibi.ibxFlexBox,
{
	options:
		{
			"text": "",
			"autoSize": false,
			"readonly": false,
			"size": 0,
			"maxLength": 0,
			"autoComplete": "off",
			"autoCorrect": "off",
			"autoCapitalize": "off",
			"spellCheck": "off",
			"placeholder": "",
			"required": false,
			"ctrlType": "text",
			"fnFormat": null,
			"textAlign": "",
			"textOverflow": "",

			"focusDefault":true,

			/*ibxFlexBox default options*/
			"inline": true,
			"wrap": "false",
			"align": "center",

			"aria":
			{
			}
		},
	_widgetClass: "ibx-text-field",
	_valueOnFocus: null,
	_create: function ()
	{
		this._super();
		this.options.text = this.options.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");
		this._textInput = $('<input tabIndex="-1" type="' + this.options.ctrlType + '"></input>');
		this._textInput.on("blur", this._onTextInputBlur.bind(this)).on("focus", this._onTextInputFocus.bind(this));
		this._textInput.on("keydown", this._onTextInputKeyDown.bind(this)).on("input", this._onTextInputInput.bind(this));
		this.element.append(this._textInput);
		this.element.on("ibx_change", function(e)
		{
			if (this.options.autoSize)
				this._setAutoSize();
		}.bind(this));
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);
		accessible ? this._textInput.attr("role", "textbox").ibxAriaId() : this._textInput.removeAttr("role").removeIbxAriaId();
		accessible ? this._textInput.attr("aria-label", aria.label || options.text || this.element.attr("title") || ibx.resourceMgr.getString("IBX_TEXT_INPUT_LABEL")) : this._textInput.removeAttr("aria-label");
		accessible ? this._textInput.attr("aria-labelledby", aria.labelledby) : this._textInput.removeAttr("aria-label");
		return aria;
	},
	_init:function()
	{
		this._super();
		this._setValue(this.options.text, true);
	},
	_setValue: function (value, bFormat)
	{
		this.options.text = bFormat && this.options.fnFormat ? this.options.fnFormat(value) : value;
		this.refresh();
		this._trigger("change", null, {"text": this.options.text});
	},
	value:function(value, bFormat)
	{
		if(value === undefined)
			return this.options.text;
		else
			this._setValue(value, bFormat);
	},
	selectAll: function ()
	{
		this._textInput.select();
	},
	_setAutoSize: function ()
	{
		var val = this._textInput.val();
		var scrollWidth;
		var curMax = this._textInput.css("max-width");
		this._textInput.css('max-width', '0px');
		if (val.length == 0)
		{
			var placeholder = this._textInput.prop('placeholder');
			if (placeholder.length == 0)
				scrollWidth = "10em";
			else
			{
				this._textInput.val(placeholder);
				scrollWidth = this._textInput[0].scrollWidth + "px";
				this._textInput.val("");
			}
		}
		else
			scrollWidth = this._textInput[0].scrollWidth + "px";
		this._textInput.css('min-width', scrollWidth).css("max-width", curMax);
	},
	_onTextInputFocus: function (event)
	{
		this._focusVal = this.options.text;
	},
	_onTextInputBlur: function ()
	{
		var newVal = this._textInput.val();
		if (newVal != this._focusVal)
			this._setValue(newVal, true);
	},
	_onTextInputKeyDown: function (e)
	{
		if (e.which == $.ui.keyCode.ENTER) // enter
		{
			var newVal = this._textInput.val();
			this._focusVal = newVal;
			this._setValue(newVal, true);
			this._trigger("action", e, {"text": this.options.text});
			this.doCommandAction("trigger");
			e.preventDefault();
		}
		else
		if(!$.ibi.ibxWidget.isNavKey(e))
			this._trigger("textchanging", e, {"text": this.options.text});
	},
	_onTextInputInput: function (e)
	{
		var value = this._textInput.val();
		if (this.options.text != value)
		{
			this.options.text = value;
			this._trigger("textchanged", e, {"text": value});
		}
	},
	format: function (fnFormat)
	{
		if (fnFormat)
		{
			this.options.fnFormat = fnFormat.bind(this);
			this._setValue(this.options.text, true);
			this.refresh();
		}
		else
			return this.options.fnFormat;
	},
	_destroy: function ()
	{
		this._super();
		this._textInput.remove();
	},
	_refresh: function ()
	{
		this._super();

		this._textInput.attr("type", this.options.ctrlType);
		this._textInput.val(this.options.text);
		this._textInput.prop("readonly", this.options.readonly ? 'true' : '');
		if (this.options.size != 0)
			this._textInput.attr("size", this.options.size);
		else
			this._textInput.removeAttr("size");
		if (this.options.maxLength != 0)
			this._textInput.attr("maxlength", this.options.maxLength);
		else
			this._textInput.removeAttr("maxlength");

		this._textInput.attr("autocomplete", this.options.autoComplete);
		this._textInput.attr("autocorrect", this.options.autoCorrect);
		this._textInput.attr("autocapitalize", this.options.autoCapitalize);
		this._textInput.attr("spellcheck", this.options.spellCheck != "off" ? "true" : "false");

		this.options.placeholder = this.options.placeholder.toString();//must cooerce to string...'0' would not set value.
		if (this.options.placeholder)
			this._textInput.attr("placeholder", this.options.placeholder);
		else
			this._textInput.removeAttr("placeholder");
		if (this.options.required)
			this._textInput.attr("required");
		else
			this._textInput.removeAttr("required");
		if (this.options.textAlign)
			this._textInput.css("text-align", this.options.textAlign);
		else
			this._textInput.css("text-align", "");
		if (this.options.textOverflow)
			this._textInput.css("text-overflow", this.options.textOverflow);
		else
			this._textInput.css("text-overflow", "");
		if (this.options.autoSize)
		{
			this.element.ibxAddClass('txt-auto-size');
			this._setAutoSize();
		}
		else
			this.element.ibxRemoveClass('txt-auto-size');

		this._textInput.css("width", this.options.autoSize ? "1px" : "");
	}
});
//# sourceURL=text.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/textarea.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.55 $:
$.widget("ibi.ibxTextArea", $.ibi.ibxFlexBox,
{
	options:
	{
		"cols": "",
		"rows": "",
		"maxlength": "",
		"text": "",
		"readonly": "",
		"maxLength": "",
		"autoComplete": "off",
		"autoCorrect": "off",
		"autoCapitalize": "off",
		"spellCheck": "off",
		"placeholder": "",
		"required": "",
		"fnFormat": null,
		"textWrap": "",
		"textAlign": "",

		/*ibxFlexBox default options*/
		"inline": true,
		"wrap": false,
		"align": "stretch",

		"focusDefault":true,

		"aria":
		{
			"multiline":true,
		}
	},
	_widgetClass: "ibx-text-area",
	_valueOnFocus: null,
	_create: function ()
	{
		this._super();
		this.options.text = this.options.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");
		this._textArea = $('<textarea tabIndex="-1" class="ibx-text-area-ctrl"></textarea>').css("flex", "1 1 auto");
		this._textArea.on("blur", this._onTextAreaBlur.bind(this)).on("focus", this._onTextAreaFocus.bind(this));
		this._textArea.on("input", this._onTextAreaInput.bind(this)).on("keydown", this._onTextAreaKeyDown.bind(this));
		this._setValue(this.options.text, true);
		this.element.append(this._textArea);
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);
		accessible ? this._textArea.attr("role", "textbox") : this._textArea.removeAttr("role");
		accessible ? this._textArea.attr("aria-multiline", true) : this._textArea.removeAttr("aria-multiline");
		accessible ? this._textArea.attr("aria-label", aria.label || options.text || this.element.attr("title") || ibx.resourceMgr.getString("IBX_TEXT_INPUT_LABEL")) : this._textInput.removeAttr("aria-label");
		accessible ? this._textArea.attr("aria-labelledby", aria.labelledby) : this._textArea.removeAttr("aria-label");
		return aria;
	},
	_setOption: function (key, value)
	{
		this._super(key, value);
		if (key == "text" && this._textArea) // only do this after create
			this._setValue(value, true);
	},
	scrollTop: function(scroll)
	{
		if(scroll === undefined)
			return this._textArea.prop("scrollTop");
		else
			this._textArea.prop("scrollTop", scroll);
	},
	scrollLeft: function(scroll)
	{
		if(scroll === undefined)
			return this._textArea.prop("scrollLeft");
		else
			this._textArea.prop("scrollLeft", scroll);
	},
	_setValue: function (value, bFormat)
	{
		this.options.text = bFormat && this.options.fnFormat ? this.options.fnFormat(value) : value;
		this.refresh();
		this._trigger("change", null, {"text": this.options.text});
	},
	value:function(val, bFormat)
	{
		if(val === undefined)
			return this.options.text;
		else
			this._setValue(val, bFormat);
	},
	selectAll: function ()
	{
		this._textArea.select();
	},
	_onTextAreaFocus: function ()
	{
		this._focusVal = this.options.text;
	},
	_onTextAreaBlur: function ()
	{
		var newVal = this._textArea.val();
		if (newVal != this._focusVal)
			this._setValue(newVal, true);
	},
	_onTextAreaKeyDown: function (e)
	{
		if(!$.ibi.ibxWidget.isNavKey(e))
			this._trigger("textchanging", e, {"text": this.options.text});
		
		//[HOME-1050]Stop enter from closing dialog...put it here because I can't see why this would ever propagate.
		if(e.keyCode == $.ui.keyCode.ENTER)
			e.stopPropagation();
	},
	_onTextAreaInput: function (e)
	{
		var value = this._textArea.val();
		if (this.options.text != value)
		{
			this.options.text = value;
			this._trigger("textchanged", e, {"text": value});
		}
	},
	format: function (fnFormat)
	{
		if (fnFormat)
		{
			this.options.fnFormat = fnFormat.bind(this);
			this._setValue(this.options.text, true);
			this.refresh();
		}
		else
			return this.options.fnFormat;
	},
	_destroy: function ()
	{
		this._super();
		this._textArea.remove();
	},
	_refresh: function ()
	{
		this._super();

		if (this.options.cols)
			this._textArea.attr("cols", this.options.cols);
		else
			this._textArea.removeAttr("cols");
		if (this.options.rows)
			this._textArea.attr("rows", this.options.rows);
		else
			this._textArea.removeAttr("rows");
		if (this.options.maxlength)
			this._textArea.attr("maxlength", this.options.maxlength);
		else
			this._textArea.removeAttr("maxlength");

		this._textArea.val(this.options.text);
		this._textArea.prop("readonly", this.options.readonly ? 'true' : '');
		if (this.options.maxLength)
			this._textArea.attr("maxlength", this.options.maxLength);
		else
			this._textArea.removeAttr("maxlength");
		if (this.options.placeholder)
			this._textArea.attr("placeholder", this.options.placeholder);
		else
			this._textArea.removeAttr("placeholder");
		if (this.options.required)
			this._textArea.attr("required");
		else
			this._textArea.removeAttr("required");

		if (this.options.textWrap)
			this._textArea.attr("wrap", this.options.textWrap);
		else
			this._textArea.attr("wrap", "off");
		
		if (this.options.textAlign)
			this._textArea.css("text-align", this.options.textAlign);
		else
			this._textArea.css("text-align", "");

		this._textArea.attr("autocomplete", this.options.autoComplete);
		this._textArea.attr("autocorrect", this.options.autoCorrect);
		this._textArea.attr("autocapitalize", this.options.autoCapitalize);
		this._textArea.attr("spellcheck", this.options.spellCheck != "off" ? "true" : "false");
	}
});
//# sourceURL=textarea.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/richedit.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.94 $:
$.widget("ibi.ibxRichEdit", $.ibi.ibxIFrame, 
{
	options:
	{
		"defaultDropHandling":true,
		"defaultFont":null,
		"aria":
		{
			"role":"region",
		}
	},
	_widgetClass:"ibx-rich-edit",
	_create:function()
	{
		//save any content before super, so we can set it as the text of the rich edit after create.
		var createContent = this.element.html();
		this.element.empty();
		this._super();

		this.element.on("ibx_dragover ibx_drop", this._onDragEvent.bind(this));
		if(createContent)
			this.insertHTML(createContent);
		this._iFrame.on("focusin", this._onIFrameEvent.bind(this));
	},
	_destroy:function()
	{
		this._super();
	},
	_init:function()
	{
		this._super();
	},
	_onIFrameEvent:function(e)
	{
		this._super(e);
		var cd = this.contentDocument();
		if(e.type == "load")
		{
			cd.designMode = "On";
			cd.body.contentEditable = true;
			cd.body.spellcheck = false;
			cd.body.style.fontFamily = this.options.defaultFont;

			$(cd).on("focusin selectionchange", this._onRichEditDocEvent.bind(this));

			//set the content if this is created from markup and there is html inside the ibxRichEdit markup.
			var content = this.element.data("createContent");
			if(content)
			{
				this.insertHTML(content.content, content.isHTML, content.replace, content.select);
				this.element.removeData("createContent");
			}
		}
		else
		if(e.type == "focusin" && this._iFrame.is(e.target))
			cd.body.focus();
	},
	_currange:null,
	selection:function(nStart, nEnd)
	{
		if(!arguments.length)
			return this._currange;

		var doc = this.contentDocument();
		var sel = doc.getSelection();
		range = doc.createRange();
		range.setStart(doc.body, nStart);
		range.setEnd(doc.body, nEnd);
		sel.addRange(range);
	},
	_onRichEditDocEvent:function(e)
	{
		var doc = this.contentDocument();
		if(e.type == "focusin" && ibxPlatformCheck.isIE && this._currange)
		{
			this._restoringSelection = true;
			var sel = doc.getSelection();
			sel.removeAllRanges();
			sel.addRange(this._currange);
			this._restoringSelection = false;
		}
		else
		if(e.type == "selectionchange" && this._iFrame.is(document.activeElement) && !this._restoringSelection)
		{
			var sel = doc.getSelection();
			this._currange = sel.rangeCount ? sel.getRangeAt(0) : null;
			this.element.dispatchEvent(e.originalEvent);
		}
	},
	_onDragEvent:function(e)
	{
		if(!this.options.defaultDropHandling)
			return;

		var dt = e.originalEvent.dataTransfer;
		var data = dt.items["text/html"];
		var isHtml = !!data;

		data =  isHtml ? data : dt.items["text/plain"];
		if(!data)
			return;

		var eType = e.type;
		if(eType == "ibx_dragover")
		{
			dt.dropEffect = "copy";
			e.preventDefault();
		}
		else
		if(eType == "ibx_drop")
			(isHtml) ? this.insertHTML(data, true, true) : this.insertText(data, true, true);
	},
	execCommand:function(cmd, value, withUI)
	{
		var cd = this.contentDocument();
		if(cd)
		{
			if(ibxPlatformCheck.isIE)
				this.contentDocument().body.focus();
			cd.execCommand(cmd, withUI, value);
		}
	},
	commandEnabled:function(cmd){return this.contentDocument().queryCommandEnabled(cmd);},
	commandState:function(cmd){return this.contentDocument().queryCommandState(cmd);},
	commandValue:function(cmd){return this.contentDocument().queryCommandValue(cmd);},
	styleWithCSS:function(css){this.execCommand("styleWithCSS", css);},
	defaultParagraphSeparator:function(sep){this.execCommand("defaultParagraphSeparator", sep);},
	removeFormat:function(){this.execCommand("removeFormat");},
	undo:function(){this.execCommand("undo");},
	redo:function(){this.execCommand("redo");},
	selectAll:function(){this.execCommand("selectAll");},
	deselectAll:function(collapseToStart)
	{
		//IE - of course, the selection is removed when focus is lost...so restore, if needed, before collapse.
		var selection = this.contentDocument().getSelection();
		if(!selection.rangeCount && ibxPlatformCheck.isIE)
			selection.addRange(this._currange || document.createRange());
		collapseToStart ? selection.collapseToStart() : selection.collapseToEnd();
	},
	cut:function(){this.execCommand("Cut");},
	copy:function(){this.execCommand("Copy");},
	paste:function(){this.execCommand("Paste");},
	del:function(){this.execCommand("Delete");},
	bold:function(){this.execCommand("Bold");},
	italic:function(){this.execCommand("Italic");},
	underline:function(){this.execCommand("Underline");},
	strikeThrough:function(){this.execCommand("strikeThrough");},
	subscript:function(){this.execCommand("subscript");},
	superscript:function(){this.execCommand("superscript");},
	foreColor:function(color){this.execCommand("foreColor", color);},
	backColor:function(color){this.execCommand("backColor", color);},
	indent:function(){this.execCommand("indent");},
	outdent:function(){this.execCommand("outdent");},
	unlink:function(href){this.execCommand("unlink", href);},
	justify:function(justify){this.execCommand($.ibi.ibxRichEdit.justify[justify]);},
	fontName:function(name){this.execCommand("fontName", name);},
	fontSize:function(size)
	{
		if(isNaN(parseInt(size, 10)))
			size = $.ibi.ibxRichEdit.fontSize[size];
		this.execCommand("fontSize", size);
	},
	createLink:function(href){this.execCommand("createLink", href);},
	insertList:function(ordered){this.execCommand(ordered ? "insertOrderedList" : "insertUnorderedList");},
	insertHTML:function(html, select, selReplace, focus){this.insertContent(html, true, select, selReplace, focus);},
	insertText:function(text, select,  selReplace, focus){this.insertContent(text, false, select, selReplace, focus);},
	insertContent:function(content, isHTML, select, selReplace, focus)
	{
		/*NOTE: chrome/ff could use insertHTML/insertText...ie doesn't support this, so normalize to a solution that works the same across browsers*/
		//get selections and create proper node for insertion.
		var doc = this.contentDocument();
		if(!doc || (doc.readyState != "complete"))
		{
			this.element.data("createContent", {"content":content, "isHTML":isHTML, "replace":selReplace, "select":select});
			return;
		}

		//nice...ie must have body focused for selections to work...awesome Microsoft!
		var focusItem = document.activeElement;
		if(ibxPlatformCheck.isIE)
			this.element[0].focus();

		//now do the actual insertion
		var selection = doc.getSelection();
		var range = null;
		if(selection && selection.rangeCount)
			range = selection.getRangeAt(0);
		else
		{
			range = doc.createRange();
			range.setStart(doc.body, 0);
		}

		var node = isHTML ? $.parseHTML(content, doc)[0] : doc.createTextNode(content);

		//remove existing selected content if desired.
		if(selReplace)
			range.deleteContents();

		//insert the new node at end of current selection/caret.
		range.collapse(false);
		try
		{
			range.insertNode(node);
		}
		catch(ex)
		{
		}
		
		//OK, so...IE and Chrome are fine with addRange causing a selection of new node...Firefox needs to collapse the range, as it seems to add it automatically...OMG what a nightmare!
		if(select)
			selection.addRange(range);
		else
			range.collapse(false);

		//focus if desired
		if(focus)
			this.element[0].focus();
		else
		if(!focus && ibxPlatformCheck.isIE)
			focusItem.focus();
		return;
	},
	cmdState:function()
	{
		var state = {};
		state.undo = this.commandEnabled("undo");
		state.redo = this.commandEnabled("redo");
		state.selectAll = this.commandEnabled("selectAll");
		state.cut = this.commandEnabled("cut");
		state.copy = this.commandEnabled("copy");
		state.paste = this.commandEnabled("paste");
		state.delete = this.commandEnabled("delete");
		state.bold = this.commandState("bold");
		state.italic = this.commandState("italic");
		state.underline = this.commandState("underline");
		state.strikethrough	= this.commandState("strikethrough");
		state.superscript = this.commandState("superscript");
		state.subscript = this.commandState("subscript");
		state.fontName = this.commandValue("fontName") || ""; //of course IE will return null sometimes.
		state.fontSize = this.commandValue("fontSize") || 3;

		state.justify = "left";
		state.justify = ibx.coercePropVal(this.commandState("justifyLeft")) ? "left" : state.justify;
		state.justify = ibx.coercePropVal(this.commandState("justifyCenter")) ? "center" : state.justify;
		state.justify = ibx.coercePropVal(this.commandState("justifyRight")) ? "right" : state.justify;
		state.justify = ibx.coercePropVal(this.commandState("justifyFull")) ? "full" : state.justify;
		if((state.justify == "justify") && ibxPlatformCheck.isFirefox)
			state.justify = "full";//normalize Firefox..it returns 'justify'.


		//of course, IE returns integers for the color values...seriously??
		state.foreColor = this.commandValue("foreColor");
		state.backColor = this.commandValue("backColor");
		if(ibxPlatformCheck.isIE)
		{
			var fmt = "rgb({1}, {2}, {3})";
			var iClr = state.foreColor;
			state.foreColor =  sformat(fmt, (iClr & 0xFF), ((iClr & 0xFF00)>>8), ((iClr & 0xFF0000)>>16));
			iClr = state.backColor;
			state.backColor =  sformat(fmt, (iClr & 0xFF), ((iClr & 0xFF00)>>8), ((iClr & 0xFF0000)>>16));
		}

		return state;
	},
	_refresh:function()
	{
		var options = this.options;
		this._super();
	}
});
$.ibi.ibxRichEdit.fontSize = 
{
	"xx-small":1,
	"x-small":2,
	"small":3,
	"medium":4,
	"large":5,
	"x-large":6,
	"xx-large":7
};
$.ibi.ibxRichEdit.justify = 
{
	"left":"justifyLeft",
	"center":"justifyCenter",
	"right":"justifyRight",
	"full":"justifyFull"
};


/**
 * @namespace ibi.ibxEditable
 * @class
 * @classdesc Allows in-place editing of any elligable element (div/span/etc)
 * @param {object} options The initial options for the widget.
 * @example var myWidget = $(element).ibxEditable(options);
 */
$.widget("ibi.ibxEditable", $.Widget, 
{
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @name options
	 * @description Configuration options for widget.
	 * @property {object} options
	 * @property {boolean} options.spellcheck Should the element spell check its content .
	 * @property {boolean} options.autocomplete Should the element attempt to autocomplete while entering content.
	 * @property {boolean} options.autocapitalize Should the element attempt to capitalize while entering content.
	 * @property {boolean} options.autocorrect Should the element attempt to correct 'errors' while entering content.
	 * @property {boolean} options.multiLine Allow enter key to create a new line.
	 * @property {boolean} options.selectAll Should all contents be selected when entering edit mode.
	 * @property {boolean} options.insertBrOnReturn Should element use a &lt;br> for line breaks.
	 * @property {keycode} options.commitKey What key press should signify a commit of the current editing.
	 * @property {keycode} options.cancelKey What key press should signify a cancel of the current editing.
	 * @property {boolean} options.commitOnBlur Should the element commit the current text when blurred.
	 */
	options:
	{
		"startEditing":false,
		"spellcheck":false,
		"autocomplete":false,
		"autocapitalize":false,
		"autocorrect":false,
		"multiLine":false,
		"selectAll":true,
		"insertBrOnReturn":true,
		"commitKey":$.ui.keyCode.ENTER,
		"cancelKey":$.ui.keyCode.ESCAPE,
		"editOnFocus":false,
		"commitOnBlur":true,

		"aria":
		{
			"role":"textbox"
		}
	},
	_onElementEventBound:null,
	_create:function()
	{
		this.element.data("ibiIbxWidget", this);//polymorphism to ibxWidget
		this.element.ibxAddClass("ibx-editable");
		this.element.ibxMutationObserver({subtree:true, characterData:true, characterDataOldValue:true});
		this.element.on("keydown focus blur ibx_nodemutated", this._onElementEvent.bind(this));
		this._super();
		this.refresh();
	},
	setAccessibility:$.ibi.ibxWidget.prototype.setAccessibility,
	_setAccessibility:function(accessible, aria)
	{
		options = this.options;
		aria.multiline = options.multiLine ? true : null;
		aria.autocomplete = options.autocomplete ? true : null;
		return aria;	
	},
	_init:function()
	{
		this._super();
		var options = $.extend(true, {}, this.options, ibx.getIbxMarkupOptions(this.element));
		this.option(options);
		if(this.options.startEditing)
			this.startEditing();
	},
	_lastValue:null,
	_onElementEvent:function(e)
	{
		var options = this.options;
		var isEditing = this.isEditing();

		if(e.type == "focus" && !isEditing && options.editOnFocus)
			this.startEditing();
		else
		if(isEditing)
		{
			if(e.type == "keydown")
			{
				var isCancel = e.keyCode == options.cancelKey;
				var isCommit = e.keyCode == options.commitKey;
				if(isCancel || isCommit)
				{
					this.stopEditing(isCancel);
					e.preventDefault();
					e.stopPropagation();
				}
				if(!options.multiLine && e.keyCode === $.ui.keyCode.ENTER)
					e.preventDefault();
			}
			else
			if(e.type == "blur")
			{
				if(options.commitOnBlur)
					this.stopEditing();
			}
			else
			if(e.type == "ibx_nodemutated")
			{
				var mr = e.originalEvent.data[0];
				var value = mr.oldValue;
				var newValue = mr.target.textContent;

				if(value != newValue)
				{
					//let people know the value is changing...they can stop it from happening.
					var event = this.element.dispatchEvent("ibx_textchanging", {"value":value, "newValue":newValue}, true, true);
					if(event.isDefaultPrevented())
						mr.target.textContent = value;//revert to current value
				}
			}
		}
	},
	_preEditValue:null,
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @description Get the original value before editing.
	 */
	preEditValue:function()
	{
		return this._preEditValue;
	},
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @description Is this control in edit mode.
	 */
	isEditing:function()
	{
		return this.element.is(".ibx-content-editing");
	},
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @description Start editing the element's content.
	 * @param {object} editOptions The runtime options to use when editing.  Will overlay the widget's options.
	 */
	startEditing:function(editOptions)
	{
		if(!this.isEditing())
		{
			var evt = this.element.dispatchEvent("ibx_startediting", this.element.text(), true, true);
			if(evt.isDefaultPrevented())
				return;

			this._preEditValue = this.element.html();//save the current text for possible reversion.
			var options = $.extend({contentEditable:true}, this.options, editOptions); 
			this.option(options);
			this.element.prop(options).ibxAddClass("ibx-content-editing").focus();
			if(options.selectAll)
				document.getSelection().selectAllChildren(this.element[0]);
			this.element.ibxMutationObserver("option", {listen:true});
			this.refresh();
		}
	},
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @description Stop editing the element's content.
	 * @param {boolean} revertToOriginal Should the original value (text before editing) be restored.  Essentially a "cancel".
	 * @fires Event:ibx_changed The event's data member will have the new text
	 */
	stopEditing:function(revertToOriginal)
	{
		if(this.isEditing())
		{
			var evt = this.element.dispatchEvent("ibx_stopediting", this.element.text(), true, true);
			if(evt.isDefaultPrevented())
				return;

			this.element.ibxMutationObserver("option", {listen:false});

			//if any seletion, remove it when finished editing.
			var sel = document.getSelection();
			sel.removeAllRanges();

			//cleanup and let world know we're done.
			this.element.ibxRemoveClass("ibx-content-editing").prop("contentEditable", false);
			if(revertToOriginal)
			{
				this.element.html(this._preEditValue);
				this.element.dispatchEvent("ibx_canceledit", this.element.text(), true, false);
			}
			else
			{
				var event = this.element.dispatchEvent("ibx_changed", this.element.text(), true, true);
				if(event.isDefaultPrevented())
					this.element.html(this._preEditValue);
			}
			this.refresh();
		}
	},
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @description Set the text content of the element.
	 * @param {string} text  The text to set into the element.
	 * @fires Event:ibx_changed The event's data member will have the new text
	 */
	text:function(text)
	{
		this.element.text(text);
		this.element.dispatchEvent("ibx_changed", text, true, false);
	},
	/**
	 * @memberof ibi.ibxEditable.prototype
	 * @description Set the html content of the element.
	 * @param {string} html  The html to set into the element.
	 * @fires Event:ibx_changed The event's data member will have the new text
	 */
	html:function(html)
	{
		this.element.html(html);
		this.element.dispatchEvent("ibx_changed", html, true, false);
	},
	refresh:function()
	{
		this.setAccessibility(ibx.accessible && this.isEditing);
	},
});
//# sourceURL=richedit.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/spinner.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.25 $:

/******************************************************************************
	SPINNER
******************************************************************************/
$.widget("ibi.ibxSpinner", $.ibi.ibxTextField, 
{
	options:
	{
		"value": 0,
		"min" :0,
		"max" :100,
		"step" :1,
		"precision":3,
		"fnFormat":null,
		"fnUnformat":null,
		"validKeys":[9, 37, 38, 39, 40, 8, 46, 187, 189, 190],
		"btnGroupClass":"ibx-spinner-btn-grp",
		"btnUpClass":"ibx-spinner-btn-up",
		"btnUpOptions":
		{
		},
		"btnDownClass":"ibx-spinner-btn-down",
		"btnDownOptions":
		{
		},
		"aria":{}
	},
	_widgetClass:"ibx-spinner",
	_create:function()
	{
		this._btnUp = $("<div>").ibxButton().on("mousedown mouseup mouseout", this._onSpinBtnEvent.bind(this));
		this._btnDown = $("<div>").ibxButton().on("mousedown mouseup mouseout", this._onSpinBtnEvent.bind(this));
		this._btnBox = $("<div>").ibxVButtonGroup().append(this._btnUp, this._btnDown);

		this._super();
		this._textInput.css('width', '1px');
		this._textInput.ibxAddClass("ibx-spinner-text-input");
		this.element.on("ibx_textchanging", this._onTextChanging.bind(this)).append(this._btnBox);
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);
		var attr = 
		{
			"role":"spinbutton",
			"aria-valuemin":options.min,
			"aria-valuemax":options.max,
			"aria-valuenow":options.value,
		};
		accessible ? this._textInput.attr(attr) : this._textInput.removeAttr("aria-valuemin aria-valuemax aria-valuenow");
		this._btnUp.ibxButton("option", "aria.hidden", true);
		this._btnDown.ibxButton("option", "aria.hidden", true);
		return aria;
	},
	_init: function ()
	{
		this._super();
		var options = this.options;
		this._btnUp.ibxAddClass(options.btnUpClass);
		this._btnDown.ibxAddClass(options.btnDownClass);
		this._btnBox.ibxAddClass(options.btnGroupClass);
		this._setValue(options.value);
	},
	_destroy: function ()
	{
		this._btnBox.remove();
		this._super();
	},
	_intervalId: null,
	_bUp: true,
	_cleared: false,
	_onSpinBtnEvent:function(e)
	{
		if(e.type == "mouseup" || e.type == "mouseout")
		{
			this.element.dispatchEvent("ibx_spinend", null, true, false);
			clearInterval(this._intervalId);
			this._intervalId = null;
			this._cleared = true;
		}
		else
		if(e.type == "mousedown")
		{
			this._onTextInputBlur(e); // just in case user typed a value
			this.element.dispatchEvent("ibx_spinstart", null, true, false);
			this._cleared = false;
			this._bUp = $(e.currentTarget).hasClass(this.options.btnUpClass);
			this._stepSpinner(this._bUp);
			setTimeout(function(e)
			{
				if (!this._cleared)
				{
					if (this._intervalId)
						clearInterval(this._intervalId);
					this._intervalId = setInterval(this._onPressTimer.bind(this), 100);
				}
			}.bind(this), 200);
		}
	},
	_onPressTimer:function(e)
	{
		this._stepSpinner(this._bUp);
	},
	_onTextInputKeyDown: function (e)
	{
		this._super(e);
		if(e.keyCode == $.ui.keyCode.UP)
		{
			this._stepSpinner(true);
			e.preventDefault();
		}
		else
		if(e.keyCode == $.ui.keyCode.DOWN)
		{
			this._stepSpinner(false);
			e.preventDefault();
		}
	},
	_onTextInputBlur: function (e)
	{
		var value = this._setValue(this._textInput.val());
		if (this.options.value != value)
			this._trigger("textchanged", e, this.element);
	},
	_onTextChanging: function(e, text)
	{
		if(!jQuery.isNumeric(e.key) && this.options.validKeys.indexOf(e.keyCode) == -1)
			e.preventDefault();
	},
	_stepSpinner: function (bUp)
	{
		var info = this._getInfo();
		info.value += bUp ? info.step : -info.step;
		this._setValue(info.value);
		this.refresh();
	},
	_adjustStep: function (val, min, max, step)
	{
		var lower = Math.min(Math.floor((val - min) / step) * step + min, max);
		var higher = Math.min(Math.ceil((val - min) / step) * step + min, max);

		if (val - lower < higher - val)
			return lower;
		else
			return higher;
	},
	setValue:function(value)
	{
		this.setValue(value);
	},
	_setValue: function(value)
	{
		var options = this.options;
		var curVal = options.value;
		var fnFormat = options.fnFormat || this._fnFormat.bind(this);
		var fnUnformat = options.fnUnformat || this._fnUnformat.bind(this);

		value = fnUnformat(value);
		if(value == options.value)
			return;
		else
		if(value === NaN)
			value = options.min;

		value = Math.max(value, options.min);
		value = Math.min(value, options.max);
		var value = this._adjustStep(value, options.min, options.max, options.step);

		var isFloat = !!(options.step % 1) 
		this.options.value = value = (isFloat ? Number(value.toFixed(options.precision)) : value);
		this.options.text = fnFormat(value);
		this.refresh();
		if(value != curVal)
			this._trigger("change", null, this._getInfo());
		return value;
	},
	_getInfo: function ()
	{
		var options = this.options;
		return { elem: this.element, value: options.value, min: this.options.min, max: this.options.max, step: this.options.step};
	},
	_fnFormat:function(value)
	{
		return value;
	},
	_fnUnformat:function(value)
	{
		return Number(String(value).replace(/[^0-9.+\-]*/g, ""));
	},
	_setOption:function(key, value)
	{
		this._super(key, value);
		if(key == "value")
			this._setValue(value);
	},
	_refresh: function ()
	{
		var options = this.options;
		this._super();
		if (this._btnBox)
			this._btnBox.ibxWidget('refresh');
	}
});
$.ibi.ibxSpinner.statics = 
{
};


//# sourceURL=spinner.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/button.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.77 $:

//////////////////////////////////////////////////////////////////////////
$.widget("ibi.ibxButton", $.ibi.ibxLabel,
{
	options:
	{
		"iconPosition": "left",
		"justify":"center",
		"aria":{"role":"button"}
	},
	_widgetClass: "ibx-button",
	_create: function ()
	{
		this._super();
		this.element.on("keydown keyup", this._onKeyEvent.bind(this)).on("click", this._onButtonClickEvent.bind(this));
	},
	_destroy: function ()
	{
		this._super();
	},
	_onButtonClickEvent:function(e)
	{
		this.doCommandAction("trigger");
	},
	_onKeyEvent: function (e)
	{
		if(e.type == "keydown")
		{
			if(e.keyCode === $.ui.keyCode.ENTER || e.keyCode === $.ui.keyCode.SPACE)
				this.element.ibxAddClass("ibx-button-active");
		}
		else
		if(e.type == "keyup")
		{
			if(e.keyCode === $.ui.keyCode.ENTER || e.keyCode === $.ui.keyCode.SPACE)
			{
				//[IBX-81] without this, then keydown to activate a navKeyRoot was autofocusing a button and the keyup was trigger click.
				//clearly this is wrong and should only happen if the button got the keydown first.
				var isActive = this.element.hasClass("ibx-button-active");
				if(isActive)
					this.element.trigger("click");
				this.element.ibxRemoveClass("ibx-button-active");
			}
		}
		this.setAccessibility();
	},
	_refresh: function ()
	{
		this._super();
	}
});

//just a simple button...essentially a label with some event handling.
$.widget("ibi.ibxButtonSimple", $.ibi.ibxButton,
{
	options:{},
	_widgetClass:"ibx-button-simple",
	_create:function()
	{
		this._super();
		this.element.ibxRemoveClass("ibx-button");
	}
});

//just a simple button for invoking the standard file browser dialog.
$.widget("ibi.ibxButtonBrowse", $.ibi.ibxButton,
{
	options:
	{
		"multiple":false,
		"accept":""
	},
	_widgetClass:"ibx-button-browse",
	_create:function()
	{
		this._super();
		this._btnBrowse = $("<input type='file'/>").on("change", this._onBrowseBtnChange.bind(this));
		this.element.on("click", this._onBrowseBtnClick.bind(this));
	},
	_onBrowseBtnClick:function(e)
	{
		this._btnBrowse.prop("value", "");
		this._btnBrowse.click();
	},
	_onBrowseBtnChange:function(e)
	{
		e.files = this.files();
		this._trigger("change", e);
	},
	files:function()
	{
		var files = this._btnBrowse.prop("files");
		return this.options.multiple ?  files : files[0];
	},
	_refresh:function()
	{
		this._super();
		this._btnBrowse.prop("accept", this.options.accept);
		this.options.multiple ? this._btnBrowse.attr("multiple", "true") : this._btnBrowse.removeAttr("multiple");
	}
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
$.widget("ibi.ibxCheckBox", $.ibi.ibxLabel,
{
	options:
		{
			"checked": false,
			"hideCheck": true,
			"group": "",
			"aria":
			{
				"role":"checkbox",
			}
		},
	_widgetClass: "ibx-check-box",
	_create: function ()
	{
		this._check = $("<input type='checkbox' class='ibx-native-input'></input>");
		this.add(this._check, this.children()[0], true);
		this.element.on("click", this._onClick.bind(this));
		this.element.on("keyup", this._onKeyEvent.bind(this)).ibxAddClass("ibx-can-toggle");
		this._super();
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		aria.checked = this.options.checked;
		return aria;
	},
	_destroy:function()
	{
		$.ibi.ibxRadioGroup.removeControl(this.options.group, this.element[0]);
		this._check.remove();
		this._super();
	},
	_init: function ()
	{
		this._super();
	},
	userValue: function (value)
	{
		return this._super(value);
	},
	_onKeyEvent: function (e)
	{
		if(e.keyCode === $.ui.keyCode.ENTER || e.keyCode === $.ui.keyCode.SPACE)
			this.element.trigger('click');
	},
	_onClick: function (e)
	{
		if (this.options.disabled || this.options.group && this.options.checked)
			return;
		this.checked((this.options.group) ? true : !this.options.checked);
		this.doCommandAction("trigger");
	},
	checked: function (value)
	{
		if (typeof (value) == "undefined")
			return this.options.checked;
		this.option("checked", value);
		return this;
	},
	_setOption: function (key, value)
	{
		var changed = this.options[key] != value;
		if(key == "checked" && changed)
		{
			if (!this._trigger("beforechange"))
				return;
			this._super(key, value);
			this._trigger("change");
			this.doCommandAction("checked", value);
		}
		else
		if(key == "group")
		{
			if(this.options.group != value)
				$.ibi.ibxRadioGroup.removeControl(this.options.group, this.element[0]);
			this._super(key, value);
			if(value)
				$.ibi.ibxRadioGroup.addControl(value, this.element[0]);
		}
		else
			this._super(key, value);
	},
	_refresh: function ()
	{
		this._super();
		if (this.options.hideCheck)
			this._check.hide();
		else
			this._check.show();
		this.element.ibxToggleClass("hide-check", this.options.hideCheck);

		this._check.prop('checked', this.options.checked);
		this.element.ibxToggleClass("checked", this.options.checked);

		(this.options.disabled) ? this._check.prop("disabled", true) : this._check.removeProp("disabled");

		this._text.removeAttr("for");
		this._glyph.removeAttr("for");
	}
});
$.widget("ibi.ibxCheckBoxSimple", $.ibi.ibxCheckBox,
{
	options:
	{
		showMarker: true,
		markerClass: "ibx-check-box-simple-marker",
	},
	_widgetClass: "ibx-check-box-simple",
	_create: function ()
	{
		this._marker = $("<div>").appendTo(this.element);
		this._super();
	},
	_setOption: function (key, value)
	{
		if (key === "markerClass")
		{
			this._marker.ibxRemoveClass(sformat("{1} {2}-check {3}-uncheck", this.options.markerClass, this.options.markerClass, this.options.markerClass));
			if (!value)
				value = "ibx-check-box-simple-marker";
		}
		return this._super(key, value);
	},
	_refresh: function ()
	{
		this._super();
		if (this.options.showMarker)
			this._marker.show();
		else
			this._marker.hide();

		this.element.ibxRemoveClass("ibx-check-box");
		this._marker.ibxRemoveClass(sformat("{1} {2}-check {3}-uncheck", this.options.markerClass, this.options.markerClass, this.options.markerClass));
		this._marker.ibxAddClass(sformat((this.options.checked ? "{1} {2}-check" : "{1} {2}-uncheck"), this.options.markerClass, this.options.markerClass));
	}
});

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
$.widget("ibi.ibxRadioButton", $.ibi.ibxCheckBox,
{
	options:
	{
		"aria":{"role":"radio"}
	},
	_widgetClass: "ibx-radio-button",
	_create: function ()
	{
		this._super();
		this._check.attr('type', 'radio');
	},
	_refresh: function ()
	{
		this._super();
	}
});

$.widget("ibi.ibxRadioButtonSimple", $.ibi.ibxRadioButton,
{
	options:
	{
		showMarker: true,
		markerClass: "ibx-radio-button-simple-marker",
	},
	_widgetClass: "ibx-radio-button-simple",
	_create: function ()
	{
		this._marker = $("<div>").appendTo(this.element);
		this._super();
	},
	_setOption: function (key, value)
	{
		if (key === "markerClass")
		{
			this._marker.ibxRemoveClass(sformat("{1} {2}-check {3}-uncheck", this.options.markerClass, this.options.markerClass, this.options.markerClass));
			if (!value)
				value = "ibx-radio-button-simple-marker";
		}
		return this._super(key, value);
	},
	_refresh: function ()
	{
		this._super();

		if (this.options.showMarker)
			this._marker.show();
		else
			this._marker.hide();

		this.element.ibxRemoveClass("ibx-check-box ibx-radio-button");
		this.element.ibxToggleClass("checked", this.options.checked);

		this._marker.ibxRemoveClass(sformat("{1} {2}-check {3}-uncheck", this.options.markerClass, this.options.markerClass, this.options.markerClass));
		this._marker.ibxAddClass(sformat((this.options.checked ? "{1} {2}-check" : "{1} {2}-uncheck"), this.options.markerClass, this.options.markerClass));
	}
});

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
$.widget("ibi.ibxSwitch", $.ibi.ibxCheckBox,
{
	options:
		{
			"switchPosition": "left",
			"spacerElClass": "ibx-switch-spacer",
			"switchElClass": "ibx-switch-ctrl",
		},
	_widgetClass: "ibx-switch",
	_create: function ()
	{
		this._spacer = $("<div>").ibxAddClass(this.options.spacerElClass);
		this._switch = $("<div><div class='ibx-switch-slider round'></div></div>").ibxAddClass(this.options.switchElClass);
		this._super();
		this.add(this._spacer, this.children()[0], true);
		this.add(this._switch, this.children()[0], true);
	},
	_destroy: function ()
	{
		this._super();
		this._spacer.remove();
		this._switch.remove();
	},
	_refresh: function ()
	{
		this._super();
		this.element.ibxRemoveClass("ibx-check-box");
		this._spacer.ibxAddClass(this.options.spacerElClass);
		this._switch.ibxAddClass(this.options.switchElClass);
	}
});

//////////////////////////////////////////////////////////////////////////
$.widget("ibi.ibxButtonGroup", $.ibi.ibxFlexBox,
{
	options:
	{
		role: "group",
		navKeyRoot:true,


		name: "",
		form: "",
		align: "stretch",
		wrap: false,
		groupSelection: false,
	},
	_widgetClass: "ibx-button-group",
	_group: null,
	_create: function ()
	{
		this._onGroupChangeBound = this._onGroupChange.bind(this);
		this._super();
	},
	_init: function ()
	{
		if (!this.options.name)
		{
			var id = this.element.attr("id");
			if (!id)
				this.element.uniqueId();
			this.options.name = this.element.attr("id");
		}
		var btns = this.element.children(".ibx-button, .ibx-check-box, .ibx-check-box-simple, .ibx-radio-button-simple").prop("tabindex", -1);
		this.add(btns);
		this._super();
	},
	children:function(selector)
	{
		return this._super(selector || ".ibx-button, .ibx-check-box, .ibx-check-box-simple, .ibx-radio-button-simple");
	},
	add:function(el, sibling, before, refresh)
	{
		this._super(el, sibling, before, refresh);

		if(this._group)
		{
			el = $(el).filter(".ibx-button, .ibx-check-box, .ibx-check-box-simple, .ibx-radio-button-simple");
			el.each(function(idx, el)
			{
				el = $(el);
				el.ibxAddClass("ibx-button-group-member");
				el.ibxWidget("option", "group", this._group.ibxWidget("option", "name"));
				this._group.ibxWidget("addControl", el[0]);
			}.bind(this));
			this.refresh();
		}
	},
	remove:function(el, destroy, refresh)
	{
		if(this._group)
		{
			el = $(el).filter(".ibx-button, .ibx-check-box, .ibx-check-box-simple, .ibx-radio-button-simple");
			el.each(function(idx, el)
			{
				el = $(el);
				el.ibxRemoveClass("ibx-button-group-member");
				this._group.ibxWidget("removeControl", el[0]);
			}.bind(this));
			this.refresh();
		}

		this._super(el, destroy, refresh);
	},
	_createGroupSelection: function ()
	{
		if (this._group)
			return;

		this._group = $('<div>');
		this._group.hide();
		this.element.append(this._group);
		this._group.ibxRadioGroup({ name: this.options.name, form: this.options.form });
		this._group.on('ibx_change', this._onGroupChangeBound.bind(this));
		this.add(this.element.children(".ibx-widget").not(this._group));
	},
	_removeGroupSelection: function ()
	{
		if (!this._group)
			return;

		this.remove(this.element.children(".ibx-widget").not(this._group));
		this._group.off('ibx_change', this._onGroupChangeBound.bind(this));
		this._group.remove();
		this._group = null;
	},
	_onGroupChangeBound: null,
	_onGroupChange: function (e, data)
	{
		this._trigger("change", null, data);
	},	
	selectNext: function ()
	{
		if (this._group)
			this._group.ibxWidget("selectNext");
	},
	selectPrevious: function ()
	{
		if (this._group)
			this._group.ibxWidget("selectPrevious");
	},
	selected: function (element)
	{
		if (this._group)
			return this._group.ibxWidget("selected", element);
		else
			return null;
	},
	group: function ()
	{
		return this._group;
	},
	_fixFirstLast: function ()
	{
		var all = this.element.children(".ibx-widget:not(:displayNone)").not(this._group);
		all.ibxRemoveClass("ibx-button-group-first ibx-button-group-last");
		all.first().ibxAddClass("ibx-button-group-first");
		all.last().ibxAddClass("ibx-button-group-last");
	},
	_refresh: function ()
	{
		this._super();
		this.options.groupSelection ? this._createGroupSelection() : this._removeGroupSelection();
		this.element.ibxRemoveClass("ibx-button-group-horizontal ibx-button-group-vertical");
		this.element.ibxAddClass(this.options.direction == "row" ? "ibx-button-group-horizontal" : "ibx-button-group-vertical");
		this._fixFirstLast();
	}
});

$.widget("ibi.ibxHButtonGroup", $.ibi.ibxButtonGroup, { options: { direction: "row"} });
$.widget("ibi.ibxVButtonGroup", $.ibi.ibxButtonGroup, { options: { direction: "column" } });

$.widget("ibi.ibxSelectionButtonGroup", $.ibi.ibxButtonGroup, { options: { groupSelection: true } });
$.widget("ibi.ibxHSelectionButtonGroup", $.ibi.ibxSelectionButtonGroup, { options: { direction: "row" } });
$.widget("ibi.ibxVSelectionButtonGroup", $.ibi.ibxSelectionButtonGroup, { options: { direction: "column" } });

//# sourceURL=button.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/slider.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.46 $:

$.widget("ibi.ibxSlider", $.ibi.ibxGrid,
{
	options:
	{
		"value": 50,
		"min": 0,
		"max": 100,
		"step": 1,
		"precision":3,
		"lock": false,
		"popupValue": false,
		"orientation": "horizontal",
		"flipLayout": false,
		"edge": "inside",
		"markerShape": "rectangle",
		"minTextPos": "none",
		"maxTextPos": "none",
		"valueTextPos": "none",
		//"textPosition": "none",
		"fnFormat": null,
		"inline":true,
		"align": "center",
		"cols": "auto 1fr auto",
		"rows": "auto 1fr auto",
		"align": "stretch",
		"wantResize": true,
		"focusDefault":true,

		"aria":
		{
			"role":"region",
			"label": ibx.resourceMgr.getString("IBX_STR_SLIDER")
		}
	},
	_widgetClass: "ibx-slider",
	_create: function ()
	{
		this._super();
		this._labelMin = $('<div class="ibx-slider-label-min">').ibxLabel({ 'justify': 'center' });
		this._labelMax = $('<div class="ibx-slider-label-max">').ibxLabel({ 'justify': 'center' });
		this._labelValue = $('<div class="ibx-slider-label-value">').ibxLabel({ 'justify': 'center' });

		this._sliderWrapper = $('<div class="ibx-slider-wrapper">');

		this._sliderBodyStart = $('<div class="ibx-slider-body ibx-slider-body-start">');
		this._sliderBodyEnd = $('<div class="ibx-slider-body ibx-slider-body-end">');
		this._sliderWrapper.append(this._sliderBodyStart, this._sliderBodyEnd);
		this._slider = $('<div tabindex="0" class="ibx-slider-marker ibx-slider-marker-one">');
		this._slider.hide();
		this._sliderWrapper.append(this._slider);
		this.element.append(this._sliderWrapper);
		this.element.append(this._labelValue, this._labelMin, this._sliderWrapper, this._labelMax);
		this._fnSliderMouseEvent = this._onSliderMouseEvent.bind(this);
		this.element.on("mousedown", this._fnSliderMouseEvent);
		this._slider.on("keydown", this._onSliderKeyDown.bind(this));
		
		window.setTimeout(
		function()
		{
			this._initializingSlider = true;
			this._initSlider();
			this._initializingSlider = false;
		}.bind(this), 1);
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);

		//thumb needs to actually be a slider too for ie/firefox.
		var attrs = 
		{
			"role":"slider",
			"aria-valuemin":options.min,
			"aria-valuemax":options.max,
			"aria-valuenow":options.value,
			"aria-labelledby":aria.labelledby,
			"aria-label":sformat(ibx.resourceMgr.getString("IBX_STR_SLIDER_DEF_LABEL"), options.min, options.max)
		}
		accessible ? this._slider.attr(attrs) : this._slider.removeAttr("aria-valuemin aria-valuemax aria-valuenow aria-valuetext role");

		this._labelMin.ibxWidget("option", "aria.hidden", accessible ? true : null);
		this._labelMax.ibxWidget("option", "aria.hidden", accessible ? true : null);
		this._labelValue.ibxWidget("option", "aria.hidden", accessible ? true : null);
		return aria;
	},
	_init: function ()
	{
		this._super();
		var options = this.options;
		if (options.value < options.min)
			options.value = options.min;
		if (options.value > options.max)
			options.value = options.max;
		options.value = this._adjustStep(options.value, options.min, options.max, options.step);
		this.element.on("ibx_resize", this._onResize.bind(this));
	},
	_initSlider: function ()
	{
		if (this._destroyed)
			return;
		this._setValue("" + this.options.value, this.info());
		this._slider.show();
	},
	_setValue: function (value, data)
	{
		this.refresh();
		if(!this._initializingSlider)
			this._trigger("change", null, data);
	},
	_onResize: function ()
	{
		this.refresh();
	},
	_activeSlider: null,
	_focusSlider: function (e)
	{
		this._activeSlider = this._slider;
		this._slider.ibxAddClass('ibx-slider-marker-move');
		var info = this.info();
		this._moveSlider(e);
		this._slider.focus();
	},
	_moveSlider: function (e)
	{
		if (!this.options.lock)
		{
			var info = this.info();
			this.options.value = this._posMarker(e, info.value, info.min, info.max);
			this._setValue("" + this.options.value, this.info());
			this._showPopup();
		}
	},
	_onSliderMouseEvent: function (e)
	{
		switch (e.type)
		{
			case "mousedown":
				{
					this._focusSlider(e);
					e.preventDefault();
					if (this._trigger("start", null, this.info()))
					{
						$(document.body).css("pointerEvents", "none");
						$(document).on("mouseup mousemove", this._fnSliderMouseEvent);
					}
				}
				break;
			case "mouseup":
				{
					this._hidePopup();
					$(document.body).css("pointerEvents", "");
					$(document).off("mouseup mousemove", this._fnSliderMouseEvent);
					this._activeSlider.ibxRemoveClass('ibx-slider-marker-move');
					e.preventDefault();
					this._trigger("end", null, this.info());
				}
				break;
			case "mousemove":
				{
					this._moveSlider(e);
					e.preventDefault();
				}
				break;
			default:
				break;
		}
	},
	_stepSlider: function (bLeft)
	{
		if (!this.options.lock)
		{
			var info = this.info();
			if (bLeft)
			{
				info.value -= info.step;
				if (info.value < info.min)
					info.value = info.min;
			}
			else
			{
				info.value += info.step;
				if (info.value > info.max)
					info.value = info.max;
			}
			this.options.value = this._adjustStep(info.value, info.min, info.max, info.step);
			this._setValue("" + this.options.value, this.info());
		}
	},
	_onSliderKeyDown : function (e)
	{
		var isSlide = false;
		if(eventMatchesShortcut("LEFT", e) || eventMatchesShortcut("DOWN", e)) //decrease position
		{
			e.stopPropagation();
			e.preventDefault();
			this._activeSlider = $(e.target);
			this._stepSlider(true);
			isSlide = true;
		}
		else
		if(eventMatchesShortcut("RIGHT", e) || eventMatchesShortcut("UP", e)) //increase position
		{
			e.stopPropagation();
			e.preventDefault();
			this._activeSlider = $(e.target);
			this._stepSlider(false);
			isSlide = true;
		}
	},
	_posMarker: function (e, value, min, max)
	{
		var offset = this._sliderWrapper.offset();
		var posX = offset.left - $(window).scrollLeft();
		var posY = offset.top - $(window).scrollTop();

		var mouseX = e.pageX - $(window).scrollLeft();
		var mouseY = e.pageY - $(window).scrollTop();
		var outerWidth = this._sliderWrapper.outerWidth();
		var outerHeight = this._sliderWrapper.outerHeight();
		var value = this.options.value;
		var flipLayout = this.options.flipLayout;

		if (this.options.orientation == "horizontal")
		{
			if (mouseX <= posX)
				value = flipLayout ? max : min;
			else if (mouseX >= posX + outerWidth)
				value = flipLayout ? min : max;
			else
				value = ((mouseX - posX) * (max - min)) / outerWidth + min;
		}
		else
		{
			if (mouseY <= posY)
				value = flipLayout ? min : max;
			else if (mouseY >= posY + outerHeight)
				value = flipLayout ? max : min;
			else
				value = ((posY + outerHeight - mouseY) * (max - min)) / outerHeight + min;
		}

		return this._adjustStep(value, min, max, this.options.step);
	},
	format: function (fnFormat)
	{
		if (fnFormat)
			this.options.fnFormat = fnFormat.bind(this);
		else
			this.options.fnFormat = null;

		this._labelMin.ibxWidget('option', 'text', this._getFormattedText("min"));
		this._labelMax.ibxWidget('option', 'text', this._getFormattedText("max"));
		this._labelValue.ibxWidget('option', 'text', this._getFormattedText("value"));
		this.refresh();
	},
	_getFormattedText: function (val)
	{
		if (this.options.fnFormat)
		{
			return this.options.fnFormat(val, this.info());
		}
		else
		{
			switch (val)
			{
				default:
				case 'value': return '' + this.options.value;
				case 'min': return '' + this.options.min;
				case 'max': return '' + this.options.max;
			}
		}
	},
	info: function ()
	{
		var options = this.options;
		var isFloat = (options.step % 1) 
		var value =  isFloat ? Number(options.value.toFixed(options.precision)) : parseInt(options.value, 10)
		return { elem: this.element, value: value, min: this.options.min, max: this.options.max, step: this.options.step};
	},
	_adjustStep: function (val, min, max, step)
	{
		var lower = Math.min(Math.floor((val - min) / step) * step + min, max);
		var higher = Math.min(Math.ceil((val - min) / step) * step + min, max);

		if (val - lower < higher - val)
			return lower;
		else
			return higher;
	},
	_destroy: function ()
	{
		this._super();
	},
	_flipLayout: function (val)
	{
		if (this.options.flipLayout)
		{
			switch (val)
			{
				case 1: return 3;
				case 2: return 2;
				case 3: return 1;
				default: return val;
			}
		}
		else
			return val;
	},
	_showPopup: function ()
	{
		if (!this.options.popupValue)
			return;

		//create and open the popup...has to be opened before positioned.
		this._popup = this._popup || $('<div class="ibx-slider-popup"></div>').ibxPopup({autoClose:false, destroyOnClose:false});
		this._popup.ibxPopup("open")

		//put it at the right spot
		var my = this.options.orientation == 'horizontal' ? 'center bottom' : 'left center';
		var at = this.options.orientation == 'horizontal' ? 'center top-10px' : 'right+10px center';
		this._popup.position({ 'my': my, 'at': at, 'of': this._activeSlider });

		//set its value correctly.
		var info = this.info();
		this._popup.html(((this._activeSlider == this._slider) ? info.value : info.value2));
	},
	_hidePopup: function ()
	{
		if (!this.options.popupValue)
			return;

		if (this._popup)
			this._popup.ibxPopup("close");
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = options[key] != value;
		this._super(key, value);
		if(key == "value" && changed && !this._initializingSlider)
			this._trigger("change", null, this.info());
	},
	_refresh: function ()
	{
		this._labelMin.ibxWidget('option', 'text', this._getFormattedText("min"));
		this._labelMax.ibxWidget('option', 'text', this._getFormattedText("max"));
		this._labelValue.ibxWidget('option', 'text', this._getFormattedText("value"));

		var horiz = this.options.orientation == "horizontal";
		var info = this.info();

		var flipLayout = this.options.flipLayout;
		var wrapperStart = 2;
		var wrapperEnd = 2;

		switch (this.options.minTextPos)
		{
			default:
			case 'none':
				this._labelMin.hide();
				this._labelMin.data('ibxRow', horiz ? 2 : this._flipLayout(3));
				this._labelMin.data('ibxCol', horiz ? this._flipLayout(1) : 2);

				if (horiz)
					wrapperStart = 1;
				else
					wrapperEnd = 3;
				break;
			case 'start':
				this._labelMin.data('ibxRow', horiz ? 1 : this._flipLayout(3));
				this._labelMin.data('ibxCol', horiz ? this._flipLayout(1) : 1);

				this._labelMin.show();
				if (horiz)
					wrapperStart = 1;
				else
					wrapperEnd = 3;
				break;
			case 'center':
				this._labelMin.data('ibxRow', horiz ? 2 : this._flipLayout(3));
				this._labelMin.data('ibxCol', horiz ? this._flipLayout(1) : 2);

				this._labelMin.show();
				if (horiz)
					wrapperStart = 2;
				else
					wrapperEnd = 2;
				break;
			case 'end':
				this._labelMin.data('ibxRow', horiz ? 3 : this._flipLayout(3));
				this._labelMin.data('ibxCol', horiz ? this._flipLayout(1) : 3);

				this._labelMin.show();
				if (horiz)
					wrapperStart = 1;
				else
					wrapperEnd = 3;
				break;

		}

		switch (this.options.maxTextPos)
		{
			default:
			case 'none':
				this._labelMax.hide();
				this._labelMax.data('ibxRow', horiz ? 2 : this._flipLayout(1));
				this._labelMax.data('ibxCol', horiz ? this._flipLayout(3) : 2);
				if (horiz)
					wrapperEnd = 3;
				else
					wrapperStart = 1;
				break;
			case 'start':
				this._labelMax.data('ibxRow',horiz ? 1 : this._flipLayout(1));
				this._labelMax.data('ibxCol', horiz ? this._flipLayout(3) : 1);

				this._labelMax.show();
				if (horiz)
					wrapperEnd = 3;
				else
					wrapperStart = 1;
				break;
			case 'center':
				this._labelMax.data('ibxRow', horiz ? 2 : this._flipLayout(1));
				this._labelMax.data('ibxCol', horiz ? this._flipLayout(3) : 2);

				this._labelMax.show();
				if (horiz)
					wrapperEnd = 2;
				else
					wrapperStart = 2;
				break;
			case 'end':
				this._labelMax.data('ibxRow', horiz ? 3 : this._flipLayout(1));
				this._labelMax.data('ibxCol', horiz ? this._flipLayout(3) : 3);
				this._labelMax.show();
				if (horiz)
					wrapperEnd = 3;
				else
					wrapperStart = 1;
				break;

		}

		valueStart = 1;
		valueEnd = 3;
		if (flipLayout)
		{
			var save = valueStart;
			valueStart = this._flipLayout(valueEnd);
			valueEnd = this._flipLayout(save);
		}


		switch (this.options.valueTextPos)
		{
			default:
			case 'none':
				this._labelValue.hide();
				this._labelValue.data('ibxRow', horiz ? 1 : 2);
				this._labelValue.data('ibxCol', horiz ? 2 : 1);

				break;
			case 'start':
				this._labelValue.data('ibxRow', horiz ? 1 : (valueStart + '/span ' + (valueEnd - valueStart + 1)));
				this._labelValue.data('ibxCol', horiz ? (valueStart + '/span ' + (valueEnd - valueStart + 1)) : 1);

				this._labelValue.show();
				break;
			case 'end':
				this._labelValue.data('ibxRow', horiz ? 3 : (valueStart + '/span ' + (valueEnd - valueStart + 1)));
				this._labelValue.data('ibxCol', horiz ? (valueStart + '/span ' + (valueEnd - valueStart + 1)) : 3);

				this._labelValue.show();
				break;

		}

		if (flipLayout)
		{
			var save = wrapperStart;
			wrapperStart = this._flipLayout(wrapperEnd);
			wrapperEnd = this._flipLayout(save);
		}

		this._sliderWrapper.data('ibxRow', horiz ? '2' : (wrapperStart + '/span ' + (wrapperEnd - wrapperStart + 1)));
		this._sliderWrapper.data('ibxCol', horiz ? (wrapperStart + '/span ' + (wrapperEnd - wrapperStart + 1)) : '2');

		this._super();

		this._slider.css('right', '').css('left', '').css('top', '').css('bottom', '');
		this._sliderBodyStart.css('top', '').css('left', '');
		this._sliderBodyEnd.css('top', '').css('left', '');

		if (horiz)
		{
			this.options.direction = "row";
			this._sliderWrapper.ibxRemoveClass('ibx-slider-vertical');
			this._sliderWrapper.ibxAddClass('ibx-slider-horizontal');
			var middleValue = Math.ceil((info.value - info.min) * (this._sliderWrapper.outerWidth() - (this.options.edge == "center" ? 0 : this._slider.outerWidth())) / (info.max - info.min) - (this.options.edge == "center" ? (this._slider.outerWidth() / 2) : 0)) + 'px';
			this._slider.css(flipLayout ? 'right' : 'left', middleValue);
			this._slider.css('top', Math.ceil((this._sliderWrapper.outerHeight() - this._slider.outerHeight()) / 2) + "px");
			this.element.ibxRemoveClass('ibx-slider-vertical');
			this.element.ibxAddClass('ibx-slider-horizontal');
			this._labelMin.ibxRemoveClass('ibx-slider-vertical');
			this._labelMin.ibxAddClass('ibx-slider-horizontal');
			this._labelMax.ibxRemoveClass('ibx-slider-vertical');
			this._labelMax.ibxAddClass('ibx-slider-horizontal');
			this._labelValue.ibxRemoveClass('ibx-slider-vertical');
			this._labelValue.ibxAddClass('ibx-slider-horizontal');
			this._sliderBodyStart.ibxRemoveClass('ibx-slider-body ibx-slider-body-vertical-start');
			this._sliderBodyStart.ibxAddClass('ibx-slider-body ibx-slider-body-horizontal-start');
			this._sliderBodyStart.css('top', Math.ceil((this._sliderWrapper.outerHeight() - this._sliderBodyStart.outerHeight()) / 2) + "px");
			this._sliderBodyStart.css(flipLayout ? 'right' : 'left', this._sliderWrapper.outerWidth() - middleValue);
			this._sliderBodyEnd.ibxRemoveClass('ibx-slider-body ibx-slider-body-vertical-end');
			this._sliderBodyEnd.ibxAddClass('ibx-slider-body ibx-slider-body-horizontal-end');
			this._sliderBodyEnd.css('top', Math.ceil((this._sliderWrapper.outerHeight() - this._sliderBodyEnd.outerHeight()) / 2) + "px");
			this._sliderBodyEnd.css(flipLayout ? 'right' : 'left', middleValue);
		}
		else
		{
			this.options.direction = "column";
			this.options.iconPosition = "bottom";
			this._sliderWrapper.ibxRemoveClass('ibx-slider-horizontal');
			this._sliderWrapper.ibxAddClass('ibx-slider-vertical');
			var middleValue = Math.ceil((info.value - info.min) * (this._sliderWrapper.outerHeight() - (this.options.edge == "center" ? 0 : this._slider.outerHeight())) / (info.max - info.min) - (this.options.edge == "center" ? (this._slider.outerHeight() / 2) : 0)) + 'px';
			this._slider.css(flipLayout ? 'top' : 'bottom', middleValue);
			this._slider.css('left', Math.ceil((this._sliderWrapper.outerWidth() - this._slider.outerWidth()) / 2) + "px");
			this.element.ibxRemoveClass('ibx-slider-horizontal');
			this.element.ibxAddClass('ibx-slider-vertical');
			this._labelMin.ibxRemoveClass('ibx-slider-horizontal');
			this._labelMin.ibxAddClass('ibx-slider-vertical');
			this._labelMax.ibxRemoveClass('ibx-slider-horizontal');
			this._labelMax.ibxAddClass('ibx-slider-vertical');
			this._labelValue.ibxRemoveClass('ibx-slider-horizontal');
			this._labelValue.ibxAddClass('ibx-slider-vertical');
			this._sliderBodyStart.ibxRemoveClass('ibx-slider-body ibx-slider-body-horizontal-start');
			this._sliderBodyStart.ibxAddClass('ibx-slider-body ibx-slider-body-vertical-start');
			this._sliderBodyStart.css('left', Math.ceil((this._sliderWrapper.outerWidth() - this._sliderBodyStart.outerWidth()) / 2) + "px");
			this._sliderBodyStart.css(flipLayout ? 'top' : 'bottom', this._sliderWrapper.outerWidth() - middleValue);
			this._sliderBodyEnd.ibxRemoveClass('ibx-slider-body ibx-slider-body-horizontal-end');
			this._sliderBodyEnd.ibxAddClass('ibx-slider-body ibx-slider-body-vertical-end');
			this._sliderBodyEnd.css('left', Math.ceil((this._sliderWrapper.outerWidth() - this._sliderBodyEnd.outerWidth()) / 2) + "px");
			this._sliderBodyEnd.css(flipLayout ? 'top' : 'bottom', middleValue);
		}

		this._slider.ibxRemoveClass('ibx-slider-marker-round locked');
		if (this.options.lock)
			this._slider.ibxAddClass('locked');
		if (this.options.markerShape == 'circle')
			this._slider.ibxAddClass('ibx-slider-marker-round');
	}
});

$.widget("ibi.ibxHSlider", $.ibi.ibxSlider, { options: { orientation: "horizontal"} });
$.widget("ibi.ibxVSlider", $.ibi.ibxSlider, { options: { orientation: "vertical", navKeyDir:"vertical", aria:{orientation:"vertical"} } });


$.widget("ibi.ibxRange", $.ibi.ibxSlider,
{
	options:
	{
		"value2": 0,
		"lock2": false,
		"markerShape2": "",
		"aria":
		{
			"label": ibx.resourceMgr.getString("IBX_STR_SLIDER_RANGE")
		},

		"navKeyKeys":
		{
			"hprev":"CTRL+LEFT",
			"hnext":"CTRL+RIGHT",
			"vprev":"CTRL+UP",
			"vnext":"CTRL+DOWN",
		},
	},
	_widgetClass: "ibx-range",
	_create: function ()
	{
		this._super();
		this._sliderRangeBody = $('<div class="ibx-slider-body ibx-slider-range-body">');
		this._sliderRangeBody.insertBefore(this._slider);
		this._slider2 = $('<div tabindex="0" class="ibx-slider-marker ibx-slider-marker-two">');
		this._slider2.hide();
		this._sliderWrapper.append(this._slider2);
		this._slider2.on("keydown", this._onSliderKeyDown.bind(this));
		
		var options = this.options;
		if (options.value < options.min)
			options.value = options.min;
		if (options.value > options.max)
			options.value = options.max;
		options.value = this._adjustStep(options.value, options.min, options.max, options.step);
		if (options.value2 > options.max)
			options.value2 = options.max;
		if (options.value2 < options.value)
			options.value2 = options.value;
		options.value2 = this._adjustStep(options.value2, options.value, options.max, options.step);
	},
	_setAccessibility:function(accessible, aria)
	{
		this._super(accessible, aria);
		var options = this.options;

		//thumb needs to actually be a slider too for ie/firefox.
		var attrs = 
		{
			"role":"slider",
			"aria-valuemin":options.min,
			"aria-valuemax":options.max,
			"aria-valuenow":options.value2,
			"aria-valuetext":sformat(ibx.resourceMgr.getString("IBX_STR_SLIDER_RANGE_VAL_HIGH"), options.value2),
			"aria-label":sformat(ibx.resourceMgr.getString("IBX_STR_SLIDER_RANGE_DEF_LABEL"), options.min, options.max)
		}
		accessible ? this._slider.attr("aria-label", sformat(ibx.resourceMgr.getString("IBX_STR_SLIDER_RANGE_DEF_LABEL"), options.min, options.max)) : null;
		accessible ? this._slider.attr("aria-valuetext", sformat(ibx.resourceMgr.getString("IBX_STR_SLIDER_RANGE_VAL_LOW"), options.value)) : null;
		accessible ? this._slider2.attr(attrs) : this._slider2.removeAttr("aria-valuemin aria-valuemax aria-valuenow aria-valuetext role");
		return aria;
	},
	_initSlider: function ()
	{
		if (this._destroyed)
			return;
		this._super();
		this._setValue("" + this.options.value + "," + this.options.value2, this.info());
		this._slider2.show();
	},
	_focusSlider: function (e)
	{
		if (this.options.lock)
			this._activeSlider = this._slider2;
		else if (this.options.lock2)
			this._activeSlider = this._slider;
		else
		{
			if (e.target == this._slider[0])
			{
				if (this.options.value == this.options.value2 && this.options.value == this.options.min)
					this._activeSlider = this._slider2;
				else
					this._activeSlider = this._slider;
			}
			else if (e.target == this._slider2[0])
			{
				if (this.options.value == this.options.value2 && this.options.value == this.options.max)
					this._activeSlider = this._slider;
				else
					this._activeSlider = this._slider2;
			}
			else
			{

				var offset1 = this._slider.offset();
				var posX1 = offset1.left - $(window).scrollLeft();
				var posY1 = offset1.top - $(window).scrollTop();

				var offset2 = this._slider2.offset();
				var posX2 = offset2.left - $(window).scrollLeft();
				var posY2 = offset2.top - $(window).scrollTop();

				var mouseX = e.pageX - -$(window).scrollLeft();
				var mouseY = e.pageY - -$(window).scrollTop();

				if (this.options.orientation == "horizontal")
				{
					if (Math.abs(mouseX - posX1) < Math.abs(mouseX - posX2))
						this._activeSlider = this._slider;
					else
						this._activeSlider = this._slider2;
				}
				else
				{
					if (Math.abs(mouseY - posY1) < Math.abs(mouseY - posY2))
						this._activeSlider = this._slider;
					else
						this._activeSlider = this._slider2;
				}
			}
		}

		this._activeSlider.ibxAddClass('ibx-slider-marker-move');
		var info = this.info();
		this._moveSlider(e);
		this._activeSlider.focus();
	},
	_moveSlider: function (e)
	{
		if (this._activeSlider.is(this._slider) && this.options.lock)
			return;
		if (this._activeSlider.is(this._slider2) && this.options.lock2)
			return;

		var info = this.info();
		if (this._activeSlider.is(this._slider2))
		{
			this.options.value2 = this._posMarker(e, info.value2, info.min, info.max);
			if (this.options.value2 < this.options.value)
				this.options.value2 = this.options.value;
		}
		else
		{
			this.options.value = this._posMarker(e, info.value, info.min, info.max);
			if (this.options.value > this.options.value2)
				this.options.value = this.options.value2;
			this.options.value = this.options.value;
		}
		this._setValue("" + this.options.value + "," + this.options.value2, this.info());
		this._showPopup();
	},
	_stepSlider: function (bLeft)
	{
		if (this._activeSlider.is(this._slider) && this.options.lock)
			return;
		if (this._activeSlider.is(this._slider2) && this.options.lock2)
			return;

		var info = this.info();
		if (bLeft)
		{
			if (this._activeSlider.is(this._slider))
			{
				info.value -= info.step;
				if (info.value < info.min)
					info.value = info.min;
				this.options.value = this.options.value = this._adjustStep(info.value, info.min, info.max, info.step);
			}
			else
			{
				info.value2 -= info.step;
				if (info.value2 < info.value)
					info.value2 = info.value;
				this.options.value2 = this._adjustStep(info.value2, info.min, info.max, info.step);
			}
		}
		else
		{
			if (this._activeSlider.is(this._slider))
			{
				info.value += info.step;
				if (info.value > info.value2)
					info.value = info.value2;
				this.options.value = this.options.value = this._adjustStep(info.value, info.min, info.max, info.step);
			}
			else
			{
				info.value2 += info.step;
				if (info.value2 > info.max)
					info.value2 = info.max;
				this.options.value2 = this._adjustStep(info.value2, info.min, info.max, info.step);
			}
		}

		this._setValue("" + this.options.value + "," + this.options.value2, this.info());
	},
	_getFormattedText: function (val)
	{
		if (this.options.fnFormat)
		{
			return this.options.fnFormat(val, this.info());
		}
		else
		{
			switch (val)
			{
				default:
				case 'value': return '' + this.options.value + ',' + this.options.value2;
				case 'min': return '' + this.options.min;
				case 'max': return '' + this.options.max;
			}
		}
	},
	info: function ()
	{
		var info = this._super();
		var options = this.options;
		var isFloat = (options.step % 1) 
		info.value2 = isFloat ? Number(options.value2.toFixed(options.precision)) : parseInt(options.value2, 10);
		return info;
	},
	_destroy: function ()
	{
		this._super();
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = options[key] != value;
		this._super(key, value);
		if(key == "value2" && changed && !this._initializingSlider)
			this._trigger("change", null, this.info());
	},
	_refresh: function ()
	{
		this._super();

		var info = this.info();
		var flipLayout = this.options.flipLayout;

		this._slider2.css('left', '').css('right', '').css('top', '').css('bottom', '');
		this._sliderRangeBody.css('top', '').css('bottom', '').css('left', '').css('right', '').css('width', '').css('height', '');

		if (this.options.orientation == "horizontal")
		{
			this._slider2.css(flipLayout ? 'right' : 'left', Math.ceil((info.value2 - info.min) * (this._sliderWrapper.outerWidth() - (this.options.edge == "center" ? 0 : this._slider2.outerWidth())) / (info.max - info.min) - (this.options.edge == "center" ? (this._slider2.outerWidth() / 2) : 0)) + 'px');
			this._slider2.css('top', Math.ceil((this._sliderWrapper.outerHeight() - this._slider2.outerHeight()) / 2) + "px");
			this._sliderRangeBody.ibxRemoveClass('ibx-slider-body ibx-slider-range-body-vertical');
			this._sliderRangeBody.ibxAddClass('ibx-slider-body ibx-slider-range-body-horizontal');
			this._sliderRangeBody.css('top', Math.ceil((this._sliderWrapper.outerHeight() - this._sliderRangeBody.outerHeight()) / 2) + "px");
		}
		else
		{
			this._slider2.css(flipLayout ? 'top' : 'bottom', Math.ceil((info.value2 - info.min) * (this._sliderWrapper.outerHeight() - (this.options.edge == "center" ? 0 : this._slider2.outerHeight())) / (info.max - info.min) - (this.options.edge == "center" ? (this._slider2.outerHeight() / 2) : 0)) + 'px');
			this._slider2.css('left', Math.ceil((this._sliderWrapper.outerWidth() - this._slider2.outerWidth()) / 2) + "px");
			this._sliderRangeBody.ibxRemoveClass('ibx-slider-body ibx-slider-range-body-horizontal');
			this._sliderRangeBody.ibxAddClass('ibx-slider-body ibx-slider-range-body-vertical');
			this._sliderRangeBody.css('left', Math.ceil((this._sliderWrapper.outerWidth() - this._sliderRangeBody.outerWidth()) / 2) + "px");
		}

		this._slider2.ibxRemoveClass('ibx-slider-marker-round locked');
		if (this.options.lock2)
			this._slider2.ibxAddClass('locked');
		var markerShape = this.options.markerShape2 ? this.options.markerShape2 : this.options.markerShape;
		if (markerShape == 'circle')
			this._slider2.ibxAddClass('ibx-slider-marker-round');

		var s = flipLayout ? this._slider2 : this._slider;
		var s2 = flipLayout ? this._slider : this._slider2;

		if (this.options.orientation == "horizontal")
		{
			this._sliderRangeBody.css(flipLayout ? 'right' : 'left', this._slider.css(flipLayout ? 'right' : "left"));
			this._sliderRangeBody.css('width', (parseFloat(this._slider2.css(flipLayout ? 'right' : "left"), 10) + this._slider2.outerWidth() - parseFloat(this._slider.css(flipLayout ? 'right' : "left"), 10)) + "px");
		}
		else
		{
			this._sliderRangeBody.css(flipLayout ? 'top' : 'bottom', this._slider.css(flipLayout ? 'top' : "bottom"));
			this._sliderRangeBody.css('height', (parseFloat(this._slider2.css(flipLayout ? 'top' : "bottom"), 10) + this._slider2.outerHeight() - parseFloat(this._slider.css(flipLayout ? 'top' : "bottom"), 10)) + "px");
		}

	}
});

$.widget("ibi.ibxHRange", $.ibi.ibxRange, { options: { orientation: "horizontal" } });
$.widget("ibi.ibxVRange", $.ibi.ibxRange, { options: { orientation: "vertical", navKeyDir:"vertical", aria:{orientation:"vertical"} } });

$.widget("ibi.ibxLeftRange", $.ibi.ibxRange,
{
	options:
	{
		aria:{}
	},
	_create: function ()
	{
		this._super();
		this.options.value = this.options.min;
	},
	_initSlider: function ()
	{
		if (this._destroyed)
			return;
		this._super();
		this._slider.hide();
	},
	_focusSlider: function (e)
	{
		this._activeSlider = this._slider2;
		this._activeSlider.ibxAddClass('ibx-slider-marker-move');
		var info = this.info();
		this._moveSlider(e);
		this._activeSlider.focus();
	},
});

$.widget("ibi.ibxRightRange", $.ibi.ibxRange,
{
	_create: function ()
	{
		this._super();
		this.options.value2 = this.options.max;
	},
	_initSlider: function ()
	{
		if (this._destroyed)
			return;
		this._super();
		this._slider2.hide();
	},
	_focusSlider: function (e)
	{
		this._activeSlider = this._slider;
		this._activeSlider.ibxAddClass('ibx-slider-marker-move');
		var info = this.info();
		this._moveSlider(e);
		this._activeSlider.focus();
	},
});

$.widget("ibi.ibxHLeftRange", $.ibi.ibxLeftRange, { options: { orientation: "horizontal" } });
$.widget("ibi.ibxHRightRange", $.ibi.ibxRightRange, { options: { orientation: "horizontal" } });
$.widget("ibi.ibxVLeftRange", $.ibi.ibxLeftRange, { options: { orientation: "vertical", navKeyDir:"vertical", aria:{orientation:"vertical"} } });
$.widget("ibi.ibxVRightRange", $.ibi.ibxRightRange, { options: { orientation: "vertical", navKeyDir:"vertical", aria:{orientation:"vertical"} } });


//# sourceURL=slider.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/popup.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.65 $:

$.widget("ibi.ibxPopup", $.ibi.ibxWidget, 
{
	options:
	{
		"focusRoot":true,
		"focusDefault":".ibx-default-focused",
		"focusOnOpen":true,
		"modal":false,
		"autoClose":true,
		"movable":false,
		"moveHandle":null,
		"moveConstrainToWindow":true,
		"resizable":false,
		"resizeHandles":null,
		"escapeToClose":true,
		"destroyOnClose":true,
		"effect":"none",
		"closeOnTimer":-1,
		"refocusLastActiveOnClose":true,

		"autoPosition":true,
		"position":
		{
			/* for my/at position values see: http://api.jqueryui.com/position/ */
			"my":"center",
			"at":"center",
			"of":window,
			"collision":"flip",
			"using":null,
			"within":null,
		},
		"aria":
		{
		}
	},
	_widgetClass:"ibx-popup",
	_create:function()
	{
		var options = this.options;
		this.element.ibxAddClass("pop-closed").prop("tabIndex", -1).css("position", "absolute").on("keydown", this._onPopupKeyEvent.bind(this));
		this._onPopupWindowResizeBound = this._onPopupWindowResize.bind(this);
		$(window).on("resize", this._onPopupWindowResizeBound);
		this._super();
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		aria.hidden = this.isOpen() ? false : true;
		return aria;
	},
	_destroy:function()
	{
		this._super();
		var options = this.options;
		this.element.ibxRemoveClass("pop-closed pop-modal pop-top").off("mousedown");
		this.element.ibxRemoveClass($.ibi.ibxPopup.statics.effect[options.effect]);
		if(options.movable)
			this.element.draggable("destroy");
		if(options.resizable)
			this.element.resizable("destroy");

		$(window).off("resize", this._onPopupWindowResizeBound);
	},
	_onPopupKeyEvent:function(e)
	{
		if(this.options.escapeToClose && e.keyCode == $.ui.keyCode.ESCAPE)
			this.close("cancel");
		e.stopPropagation();
	},
	_onPopupWindowResize:function(e)
	{
		if(this.isOpen() && this.options.autoPosition && (window === e.target))
			this.element.position(this.options.position);
	},
	isClosing:function()
	{
		return this.element.hasClass("pop-closing");
	},
	isOpening:function()
	{
		return this.element.hasClass("pop-opening");
	},
	isOpen:function()
	{
		return !this.element.hasClass("pop-closed");
	},
	open:function(openInfo)
	{
		//[IBX-121][PD-839]trying to open the popup when closing...this will cause an open from the close, when complete.
		if(this.isClosing())
		{
			this._openFromClose = true;
			return;
		}

		if(!this.isOpen() && this._trigger("beforeopen", null, openInfo))
		{
			//we are fully open...no longer interested in transition events.
			this.element.on("transitionend", function(e)
			{
				//we are now fully open.
				this.element.ibxRemoveClass("pop-opening").off("transitionend");
				this._openFromClose = false;

				//auto close the dialog after the specified time.
				if(options.closeOnTimer >= 0)
				{
					window.setTimeout(function()
					{
						this.close();
					}.bind(this), options.closeOnTimer);
				}
			
				if(this._closeFromOpen)
					this.close();

			}.bind(this));

			var options = this.options;

			//save currently active element for refocusing on close.
			//[IA-8479] IE11 (some installs) have a problem with activeElement in iframe documents.  So, the if check will basically
			//just force the activeElement to document.body if document.activeElement is not correct.
			if(document.activeElement instanceof HTMLElement)
				this._elPrevActive = document.activeElement;
			else
				this._elPrevActive = document.body;

			//move the popup to the body so it can be top level...and position it correctly.
			this.element.data("ibxPopupParent", this.element.parent()).appendTo(document.body);

			//if not autoPosition, first time position, next leave where last closed.
			var curPos = this.element.data("ibxPopupLastPos");
			if(!options.autoPosition && curPos)
				this.element.css({top:curPos.top, left:curPos.left});
			else
				this.element.position(options.position);

			//tell manager to open the popup.
			this.element.ibxAddClass("pop-opening");
			this._trigger("popup_mgr_open", null, this.element);

			//we're visible so focus...auto-focusing of children now happens in ibxWidget.
			this.setAccessibility();
			if(options.focusOnOpen)
				this.element.focus();

			//let people know we are fully open
			this._trigger("open");
		}
	},
	close:function(closeInfo)
	{
		/****
			[HOME-1073][IBX-121][PD-839]...see 'open' function above for corollary
			trying to close the popup when opening...this will cause a close from the open, when complete.
			this is needed because the popup is transitioning between open/close is happening, so the popup manager is trying to close
			this popup, but it can't because it's not fully open yet.  We stack the open/close so that when it has fully completed
			the transition, it will then do the stacked (open/close) action.
		****/
		if(this.isOpening())
		{
			this._closeFromOpen = true;
			return;
		}

		if(this.isOpen() && this._trigger("beforeclose", null, closeInfo))
		{
			//we are fully closed...no longer interested in transition events.
			this.element.on("transitionend", function(e)
			{
				this._closeFromOpen = false;

				//destroy on close, if desired, or put popup back under it's original parent.
				if(!this._destroyed && this.options.destroyOnClose)
				{
					this.destroy();
					this.element.remove();
				}
				else
				{
					this.element.data("ibxPopupLastPos", this.element.position()).css({top:"", left:""});
					this.element.appendTo(this.element.data("ibxPopupParent") || document.body);
					this.element.ibxRemoveClass("pop-closing").off("transitionend");
				}
				
				//allow popup to do cleanup
				this.popupClosed();
				
				//user tried to open popup while it was closing...open it now that it's fully closed.
				if(this._openFromClose)
					this.open();

			}.bind(this));

			//[IBX-87] Don't refocus if close is from a mouse event...let browser focus wherever was clicked on.
			//ALSO, check for pop-top, because if we aren't the topmost popup, then we shouldn't be resetting focus.  Think menu item opening dialog.
			if(!(closeInfo instanceof MouseEvent) && this.element.is(".pop-top") && this.options.refocusLastActiveOnClose && this._elPrevActive)
				this._elPrevActive.focus();
			delete this._elPrevActive;

			this.element.ibxAddClass("pop-closing");
			this._trigger("popup_mgr_close", null, this.element);
			this._trigger("close", null, closeInfo);
			this.setAccessibility();
		}
	},
	popupClosed:$.noop,
	_refresh:function()
	{
		this._super();
		var options = this.options;
		this.element.ibxAddClass($.ibi.ibxPopup.statics.effect[options.effect]);
		options.modal ? this.element.ibxAddClass("pop-modal") : this.element.ibxRemoveClass("pop-modal");

		//turn draggable on/off
		if(options.movable)
			this.element.draggable({handle:options.moveHandle, "containment": this.options.moveConstrainToWindow ? "window" : null});
		else
		if(this.element.is(".ui-draggable"))
			this.element.draggable("destroy");

		//turn resizable on/off
		if(options.resizable)
			this.element.resizable({handles:options.resizeHandles});
		else
		if(this.element.is(".ui-resizable"))
			this.element.resizable("destroy");

		this.element.on("resizestart resizestop dragstart dragstop", function(e)
		{
			//[IBX-78] make resize/move work when content has iframes...stop pointer events so they don't eat the events.
			var frames = this.element.find("iframe");
			frames.css("pointerEvents", (e.type == "resizestart" || e.type == "dragstart") ? "none" : "NONE");
		}.bind(this));
	}
});


/******************************************************************************
	MANAGER OF HIDING/SHOWING POPUPS...STACKING MODALS, ETC.
******************************************************************************/
function ibxPopupManager()
{
	$(window).on("ibx_popup_mgr_open ibx_popup_mgr_close", ibxPopupManager.onPopupEvent.bind(this));
	window.addEventListener("mousedown", ibxPopupManager.onWindowEvent.bind(this), true);
	window.addEventListener("keydown", ibxPopupManager.onWindowEvent.bind(this), true);
	this._gp = $("<div class='ibx-popup-glass-pane'>").on("mousedown mouseup click", function(e){e.preventDefault();e.stopPropagation();});
}
ibxPopupManager._openPopups = $();//array of currently open ixbPoups
ibxPopupManager.autoDisableIFrames = true;//no pointer events for iframes
ibxPopupManager.onPopupEvent = function(e, popup)
{
	var popup = $(popup);

	//remove existing .pop-top as we're going to reset it
	$(".ibx-popup").ibxRemoveClass("pop-top");

	var topPop = ibxPopupManager.getOpenPopups().not(popup).first();//find the top popup excluding the one in question
	var eType = e.type;
	if(eType == "ibx_popup_mgr_open")
	{
		var topZ = topPop.zIndex() || popup.zIndex();
		popup.ibxAddClass("pop-top");
		popup.css("zIndex", topZ + 1000);
		popup.ibxRemoveClass("pop-closed");
		topPop = popup;

		//manage the currently open popups
		ibxPopupManager._openPopups = ibxPopupManager._openPopups.add(popup);
	}
	else
	if(eType == "ibx_popup_mgr_close")
	{
		popup.ibxAddClass("pop-closed");
		topPop.ibxAddClass("pop-top");

		//manage the currently open popups
		ibxPopupManager._openPopups = ibxPopupManager._openPopups.not(popup);
	}

	//now, find the topmost modal popup...if there is one, stick the glass pane behind it, and stop mouse events
	var topModal = ibxPopupManager.getOpenPopups(".pop-modal").first();
	if(topModal.length)
	{
		var zIndex = topModal.zIndex() - 10;
		this._gp.css("zIndex", zIndex);
		$("html > body").append(this._gp);
	}
	else
		this._gp.css("zIndex", "").detach();

	//[IBX-66]if desired, kill all pointer events on background iframes.
	if(ibxPopupManager.autoDisableIFrames)
	{
		//[IBX-198] have to turn pointer-events back on for topmost popup iframes.
		$("iframe").ibxToggleClass("ibx-popup-disabled-iframe", !!topPop.length);
		topPop.find("iframe").ibxRemoveClass("ibx-popup-disabled-iframe");
	}
};
ibxPopupManager.onWindowEvent = function(e)
{
	if(e.eventPhase == 1)
	{
		if(e.type == "mousedown")
		{
			//if we clicked on a popup, then close all higher zIndex popups
			var popup = $(e.target).closest(".ibx-popup");
			if(popup.length)
			{
				var zMin = popup.zIndex() + 1;
				ibxPopupManager.closeOpenPopups("", zMin, Infinity, false, e);
				return;
			}

			//otherwise, if any modals are open, then attempt to close any popups above the top modal, or
			//the modal itself if it's autoClose
			var modal = ibxPopupManager.getOpenPopups(":openModalPopup").first();
			if(modal.length)
			{
				var zMin = modal.zIndex() + 1;//add one so the modal isn't included in the get open popups.
				popup = ibxPopupManager.getOpenPopups(":autoClose", zMin);
				if(popup.length)
					popup.ibxWidget("close", e);
				else
				if(modal.ibxWidget("option", "autoClose"))
					modal.ibxWidget("close", e);
				return;
			}

			//finally, close all open autoClose popups
			ibxPopupManager.closeOpenPopups(null, null, null, false, e);
		}
		else
		if(e.type == "keydown")
		{
		}
	}
};
ibxPopupManager.getOpenPopups = function(filter, zMin, zMax)
{
	var pattern = sformat("{1}:openPopup({2}, {3})", (filter || ""), zMin, zMax);
	var popups = ibxPopupManager._openPopups.filter(pattern).sort(fnSortZIndex);
	return popups;
};
ibxPopupManager.closeOpenPopups = function(filter, zMin, zMax, forceClose, closeData)
{
	//close all open popups within z limits...and only do autoClose unless forceClose is specified.
	var openPopups = ibxPopupManager.getOpenPopups((!forceClose ? ":autoClose" : "") + (filter || ""), zMin, zMax);
	if(openPopups.length)
		openPopups.ibxWidget("close", closeData);
};

$.ibi.ibxPopup.statics = 
{
	effect:
	{
		none:"pop-effect-none",
		fade:"pop-effect-fade",
		scale:"pop-effect-scale",
		blind:"pop-effect-blind"
	},
	popupManager:new ibxPopupManager(),
};

//# sourceURL=popup.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/dialog.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.47 $:

$.widget("ibi.ibxDialog", $.ibi.ibxPopup, 
{
	options:
	{
		"nameRoot":true,
		"type":"std plain", //predefines: std and plain/error/warning/information/question
		"autoSize":true,
		"modal":true,
		"autoClose":false,
		"movable":true,
		"buttons":"okcancel",
		"closeButton":true,
		"closeButtonClasses":"",
		"defaultAction":".ibx-dialog-ok-button",
		"effect":"fade",
		"captionOptions":{},
		
		"aria":
		{
			"role":"dialog"
		}
	},
	_widgetClass:"ibx-dialog",
	_create:function()
	{
		this._super();
		this._loadWidgetTemplate(".ibx-dialog-template");

		var options = this.options;
		options.moveHandle = this.titleBox;
		this.element.on("keydown", this._onDialogKeyDown.bind(this));
		this.titleClose.on("click", this.close.bind(this, "cancel"));
		this.btnApply.on("click", this.apply.bind(this));
		this.btnCancel.on("click", this.close.bind(this, "cancel"));
		this.btnOK.on("click", this.close.bind(this, "ok"));
		this.btnNo.on("click", this.close.bind(this, "no"));
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		if(!aria.labelledby)
			aria.labelledby = this.caption.prop("id");
		return aria;
	},
	_destroy:function()
	{
		this._super();
		var options = this.options;
		this.element.ibxRemoveClass("dlg-auto-size");
		this.element.ibxRemoveClass(options.type);

		var children = this.children();
		children.detach();
		this.element.empty();
		this.element.append(children);
	},
	_init:function()
	{
		this._super();
		this.add(this.element.children().not(this.vbMain));
		this.refresh();
	},
	children:function(selector)
	{
		return this.contentBox.ibxWidget("children", selector);
	},
	add:function(el, sibling, before, refresh)
	{
		this.contentBox.ibxWidget("add", el, sibling, before, refresh);
	},
	remove:function(el, destroy, refresh)
	{
		this.contentBox.ibxWidget("remove", el, destroy, refresh);
	},
	apply:function(e)
	{
		this._trigger("apply");
	},
	_onDialogKeyDown:function(e)
	{
		var defAction = this.options.defaultAction;
		if(!$(e.target).is(".ibx-button") && e.keyCode == 13 && defAction)
		{
			var target = this.element.find(defAction);
			if(!target.ibxWidget("option", "disabled"))
				target.trigger("click");
		}
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;

		//manage default captions
		var caption = options.captionOptions.text;
		if(!caption)
		{
			if(-1 != options.type.search("plain"))
				caption = ibx.resourceMgr.getString("IBX_DLG_CAPTION_PLN");
			else
			if(-1 != options.type.search("error"))
				caption = ibx.resourceMgr.getString("IBX_DLG_CAPTION_ERR");
			else
			if(-1 != options.type.search("warn"))
				caption = ibx.resourceMgr.getString("IBX_DLG_CAPTION_WRN");
			else
			if(-1 != options.type.search("information"))
				caption = ibx.resourceMgr.getString("IBX_DLG_CAPTION_INF");
			else
			if(-1 != options.type.search("question"))
				caption = ibx.resourceMgr.getString("IBX_DLG_CAPTION_QST");
		
			options.captionOptions.text = caption;
		}			
		this.caption.ibxLabel(options.captionOptions);

		this.titleClose.css("display", options.closeButton ? "" : "none");
		this.btnOK.css("display", options.buttons.search("ok") != -1 ? "" : "none");
		this.btnNo.css("display", options.buttons.search("no") != -1 ? "" : "none");
		this.btnCancel.css("display", options.buttons.search("cancel") != -1 ? "" : "none");
		this.btnApply.css("display", options.buttons.search("apply") != -1 ? "" : "none");
		this.element.find(".ibx-dlg-default-action").ibxRemoveClass("ibx-dlg-default-action");
		this.element.find(options.defaultAction).ibxAddClass("ibx-dlg-default-action");
		this.element.ibxAddClass(options.type);
		options.autoSize ? this.element.ibxAddClass("dlg-auto-size") : this.element.ibxRemoveClass("dlg-auto-size");
	}
});
$.ibi.ibxDialog.createMessageDialog = function(options)
{
	options = options || {};

	//setup the options for the dialog
	options = $.extend(true, {},
	{
		type:"std",
		captionOptions:
		{
			text:options.caption,
		},
		messageOptions:
		{
			text:options.message,
			textWrap:true,
			justify:"start",
		},
		aria:{role:"alertdialog"}
	}, options);
	var msg = $("<div data-ibx-name='message'>").ibxLabel(options.messageOptions).ibxAddClass("ibx-dialog-message").ibxAriaId();

	//setup the dialog
	options.aria = $.extend(true, {}, {"describedby":msg.prop("id")}, options.aria);
	var dlg = $("<div>").ibxDialog(options).ibxDialog("add", msg);
	ibx.bindElements(msg);
	return dlg;
};

$.ibi.ibxDialog.statics = 
{
};
//# sourceURL=dialog.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/tooltip.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.4 $:

$.widget("ibi.ibxTooltip", $.ibi.ibxPopup, 
{
	options:
	{
		"text":null,
		"effect":"fade",
		"delay":300,
		"destroyOnClose":true,
	},
	_widgetClass:"ibx-tooltip",
	_create:function()
	{
		this._super();
	},
	_destroy:function()
	{
		this._super();
	},
	open:function(openInfo)
	{
		ibxPopupManager.closeOpenPopups(".ibx-tooltip");
		this._super();
	},
	close:function(closeInfo)
	{
		this._super();
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		this.element.ibxToggleClass("ibx-text-tip", options.text);
		if(options.text)
			this.element.html(options.text);
	}
});

//# sourceURL=tooltip.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/radiogroup.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.39 $:

$.widget("ibi.ibxRadioGroup",$.ibi.ibxFlexBox,
{
	options:
		{
			"inline": true,
			"navKeyRoot": true,
			"focusDefault": true,
			"name": "",
			"form": "",
			"aria": { "role": "radiogroup" }
		},
	_widgetClass: "ibx-radio-group",
	_onChangeBind: null,
	_onBeforeChangeBind: null,
	_create: function()
	{
		this._controls = [];
		this._onChangeBind = this._onChange.bind(this);
		this._onBeforeChangeBind = this._onBeforeChange.bind(this);
		this.options.name = this.options.name || ("autoGroupName" + $.ibi.ibxRadioGroup.uniqueName++);
		this._super();
	},
	_setAccessibility: function(accessible,aria)
	{
		aria=this._super(accessible,aria);
		var btnIds="";
		$(this._controls).each(function(members, idx, el)
		{
			btnIds+=" "+el.id;
		}.bind(this,btnIds));
		aria.controls=btnIds;
		return aria;
	},
	_destroy: function()
	{
		$(this._controls).each(function(idx, el)
		{
			this.removeControl(el);
		}.bind(this));
		this._super();
	},
	_init: function()
	{
		this._super();

		//add all the precreated controls that want to be a member of this group...then replace them with this.
		var options = this.options;
		var grps = $.ibi.ibxRadioGroup.grps;
		var grp = grps[options.name];
		if(grp instanceof Array)
			this.addControl(grp);
		grps[options.name] = this.element[0];

		this.add(this.element.children(".ibx-can-toggle").detach());//add children to this group.
	},
	_onBeforeChange: function(e)
	{
		if(!$(e.currentTarget).ibxWidget('checked'))
		{
			if(!this._trigger('beforechange'))
				e.preventDefault();
		}
	},
	_onChange: function(e)
	{
		if(!this._bInUpdating)
		{
			this._bInUpdating=true;
			if($(e.currentTarget).ibxWidget('checked'))
				this._setSelected(e.currentTarget);
			this._bInUpdating=false;
		}
	},
	_getItemUserValue: function(el)
	{
		el = $(el);
		if(el.is(":ibxWidget"))
			return el.ibxWidget("userValue");
		else
			return null;
	},
	add: function(el, elSibling, before, refresh)
	{
		this._super(el,elSibling,before,refresh);
		$(el).each(function(idx, el)
		{
			el = $(el)
			if(!el.attr("tabIndex"))
				el.attr("tabIndex",-1);
			this.addControl(el);
		}.bind(this));
	},
	remove: function(el,destroy,refresh)
	{
		this.removeControl(el);
		this._super(el,destroy,refresh);
	},
	_controls:null,
	controls: function()
	{
		return this._controls.slice(0);
	},
	hasControl: function(element)
	{
		return (this._controls.indexOf(element)!=-1)
	},
	addControl: function(el)
	{
		var el=$(el);
		el.each(function(index, el)
		{
			//add to internal controls if not already part of group.
			if(this.hasControl(el))
				return;

			this._controls.push(el);

			var ctrl = $(el).on("ibx_change", this._onChangeBind).on('ibx_beforechange', this._onBeforeChangeBind).data("ibxWidget");
			ctrl.option("group", this.options.name);

			//all items must have user values...if not set by user, then we create one.
			var value = this._getItemUserValue(el);
			if(value === undefined || value === null)
			{
				value = "autoUserValue" + $.ibi.ibxRadioGroup.uniqueUserVal++;
				ctrl.option("userValue", value);
			}
			
			var checked = ctrl.checked();
			if(checked || this.options.userValue == value)
				this._setSelected(el);
		}.bind(this));
		this.refresh();
	},
	removeControl: function(el)
	{
		if(this.hasControl(el))
		{
			this._controls.splice(this._controls.indexOf(el), 1);
			
			el = $(el);
			el.ibxRemoveClass("radio-group-checked" + this.options.name);
			el.off("ibx_change", null, this._onChangeBind).off('ibx_beforechange', this._onBeforeChangeBind);
			this.refresh();
		}
	},
	_setSelected: function(el)
	{
		var val = this._getItemUserValue(el);
		this.userValue(val);
	},
	selected: function(el)
	{
		el = $(el);
		if(!el.length)
			return $(this._controls).filter(".radio-group-checked");
		else
		{
			//YOU WERE FIGURING OUT HOW TO SET THE USER VALUE TO NULL AND DESELECT ALL ITEMS.
			el.ibxWidget("checked", true);
			return this;
		}
	},
	_setOptionDisabled: function(value)
	{
		$(this._controls).ibxWidget('option', 'disabled', value);
	},
	_setOption: function(key,value)
	{
		if(this._settingOption)
			return;
		this._settingOption = true;

		var changed = this.options[key] != value;
		this._super(key,value);

		if(key == "userValue")
		{
			$(this._controls).each(function(value, index, el)
			{
				el = $(el);
				el.ibxRemoveClass('radio-group-checked').ibxWidget('checked',false)
				var itemUserValue = this._getItemUserValue(el);
				if(itemUserValue == value)
					el.ibxWidget('checked', true).ibxAddClass('radio-group-checked');
			}.bind(this, value));

			this.element.dispatchEvent("ibx_change", null, false);
		}

		this._settingOption = false;
	},
	_refresh: function()
	{
		var options = this.options;
		(!this.element.children(".ibx-can-toggle").length) ? this.element.css("display","none") : this.element.css("display","");
		this._super();
	}
});
$.ibi.ibxRadioGroup.uniqueName = 0;
$.ibi.ibxRadioGroup.uniqueUserVal = 0;
$.ibi.ibxRadioGroup.grps={};
$.ibi.ibxRadioGroup.addControl=function(grpName, ctrl)
{
	//if you try to add a control to a group before the group is created we cache it in an array.  When the group is created, it will find that cache
	//and add all the controls to itself.  From that point on, adding controls will directly interact with the group.
	var grp = this.grps[grpName];
	if(!grp && grpName)
		grp = this.grps[grpName] = [];

	if(grp instanceof Array)
		grp.push(ctrl);
	else
	if(grp)
		$(grp).ibxWidget("addControl", ctrl)
}
$.ibi.ibxRadioGroup.removeControl=function(grpName, ctrl)
{
	var grp = this.grps[grpName];
	if(grp && !(grp instanceof Array))
		$(grp).ibxWidget("removeControl", ctrl)
}

$.widget("ibi.ibxHRadioGroup",$.ibi.ibxRadioGroup,{ options: { direction: "row" } });
$.widget("ibi.ibxVRadioGroup",$.ibi.ibxRadioGroup,{ options: { direction: "column" } });

//# sourceURL=radiogroup.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/form.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.17 $:

$.widget("ibi.ibxForm", $.ibi.ibxWidget,
{
	options:
	{
		name:"myForm",
		action:"",
		target:"_self",
		method:"post",
		encType:"application/x-www-form-urlencoded; charset=utf-8",
		acceptCharset:"",
		fields:{}		
	},
	_widgetClass: "ibx-form",
	_create: function ()
	{
		this._super();
	},
	_destroy: function ()
	{
		this._super();
	},
	submit:function(doc)
	{
		if(this.element.parent().length)
			this.element.submit();
		else
		{
			this.element.uniqueId();
			var id = this.element.prop("id");
			var doc = $(doc ? doc.documentElement : document.documentElement);
			var frm = doc.find("body").append(this.element.prop("outerHTML")).find("#"+id);
			frm.submit();

			//clean up after our selves.
			if(doc.is(document.documentElement))
				frm.remove();
		}
		return;
	},
	_refresh: function ()
	{
		var options = this.options;
		this._super();
		this.element.attr("name", options.name);
		this.element.attr("action", options.action);
		this.element.attr("target", options.target);
		this.element.attr("method", options.method);
		this.element.attr("enctype", options.encType);
		this.element.attr("accept-charset", options.acceptCharset);
		this.element.remove(".ibx-form-internal-field");
		$.each(options.fields, function(name, value)
		{
			var input = $("<input class='ibx-form-internal-field'>").prop(
			{
				"type": "hidden",
				"name": name,
				"value": value
			});
			this.element.append(input);
		}.bind(this));
	}
});
//# sourceURL=form.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/accordion.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.49 $:

/******************************************************************************
	ACCORDION PANE
******************************************************************************/

$.widget("ibi.ibxAccordionPane", $.ibi.ibxFlexBox, 
{
	options:
	{
		focusDefault:true,
		navKeyRoot:true,
		direction:"column",
		align:"stretch",
		pageStretch:false,
		pageAutoSize:false,
		selected: "",
		wrap: false,

		aria:
		{
			role:"tablist"
		}

	},
	_widgetClass:"ibx-accordion-pane",
	_create:function()
	{
		this._super();
		var options = this.options;
		this._group = $("<div>").uniqueId().appendTo(this.element);
		this._group.ibxRadioGroup({name:this._group.prop("id")}).on("ibx_change", this._onPageChange.bind(this));
		this.add(this.element.children());
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		//setup the relationship between the accordion buttons and the accordion pane
		this.element.find(".ibx-accordion-page-button").each(function(idx, el)
		{
			var id = el.id;
			aria.owns += " " + id;
		}.bind(this));
		return aria;
	},
	children:function(selector)
	{
		return this._super(selector || ".ibx-accordion-page");
	},
	add:function(el, sibling, before, refresh)
	{
		el = $(el);
		el.filter(".ibx-accordion-page").each(function (idx, el)
		{
			this._group.ibxRadioGroup("addControl", el);
		}.bind(this));

		this._super(el, sibling, before, false);
	},
	remove:function(el, destroy, refresh)
	{
		var selIndex = this.selectedIndex();
		var options = this.options;
		var el = this.children().not(this._group).filter(el);
		el.filter(".ibx-accordion-page").each(function(options, idx, el)
		{
			el = $(el);
			this._group.ibxRadioGroup("removeControl", el[0]);
			if(el.is(options.selected))
				options.selected = null;
		}.bind(this, options));
		this._super(el, destroy, refresh);

		// If selected node was removed, select next / previous page, if available
		var newSelIndex = this.selectedIndex();
		if (newSelIndex < 0)
		{
			var pages = this.element.children(".ibx-accordion-page");
			if (pages.length > 0 && selIndex >= 0)
			{
				selIndex = Math.max(0, Math.min(selIndex, pages.length -1));
				this.selectedIndex(selIndex);
			}
		}
	},
	group:function(){return this._group;},
	userValue:function(value)
	{
		return this._group.ibxWidget("userValue", value);
	},
	selectedIndex: function (index)
	{
		if (index === undefined)
		{
			var page = this._group.ibxWidget("selected");
			if (page.length)
				return this.element.children(".ibx-accordion-page").index(page);
			else
				return -1;
		}
		else
		{
			var pages = this.element.children(".ibx-accordion-page");
			if (index >= 0 && index < pages.length)
				this._group.ibxWidget("selected", $(pages[index]));
			return this.element;
		}
	},
	selected: function (element)
	{
		if (element === undefined)
		{
			return this._group.ibxWidget("selected");
		}
		else
		{
			element = $(element);
			if (element.length > 0 && element.data("ibiIbxAccordionPage"))
				this._group.ibxWidget("selected", element);
			return this.element;
		}
	},
	_onPageChange:function(e)
	{
		this.options.selected = $(e.target).ibxWidget("selected");
		this._trigger("change");
	},
	_setOption: function (key, value)
	{
		this._super(key, value);
		if(key == "selected")
		{
			if (this.options.selected)
				this.selected(this.options.selected);
		}
		else if (key == "userValue")
		{		
			if (this.options.userValue)
				this.userValue(this.options.userValue);
		}
	},
	refresh:function(withChildren)
	{
		this._super();
		if(withChildren)
			this.children().ibxWidget("refresh");
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		this.element.children(".ibx-accordion-page").ibxToggleClass("acc-pg-stretch", options.pageStretch).ibxToggleClass("acc-pg-auto-size", options.pageAutoSize);
		this.element.data("ibiIbxSelectionManager").options.selectableChildren = ".ibx-accordion-page-button";
	}
});
$.widget("ibi.ibxHAccordionPane", $.ibi.ibxAccordionPane, {options:{direction:"row"}, _widgetClass:"ibx-accordion-pane-horizontal"});
$.widget("ibi.ibxVAccordionPane", $.ibi.ibxAccordionPane, {options:{direction:"column"}, _widgetClass:"ibx-accordion-pane-vertical"});
$.ibi.ibxAccordionPane.statics = 
{
};

/******************************************************************************
	ACCORDION PAGE
******************************************************************************/
$.widget("ibi.ibxAccordionPage", $.ibi.ibxFlexBox, 
{
	options:
	{
		autoClose:true,
		group:"",
		direction:"column",
		align:"stretch",
		wrap:false,
		selected:false,
		btnShow:true,
		btnPosition:"start",
		btnOptions:
		{
			text:"",
			textElClass:"ibx-label-text ibx-accordion-button-text",
			justify:"start",
			iconPosition:"right",
			glyph:"chevron_right",
			glyphClasses:"material-icons"
		},
		btnOptionsOpen:
		{
			glyphClasses:"material-icons acc-rotate-glyph"
		},
		contentOptions:
		{
		},
	},
	_widgetClass:"ibx-accordion-page",
	_create:function()
	{
		this._super();
		var options = this.options;

		var content = this._content = $("<div tabindex='0' class='ibx-accordion-page-content'>").ibxWidget(this.options.contentOptions);
		content.on("transitionend", this._onTransition.bind(this))

		var btn = this._button = $("<div tabIndex='-1' class='ibx-accordion-page-button'>").on("click", this._onBtnChange.bind(this));
		btn.data("accPage", this.element).ibxButton(this.options.btnOptions).ibxAddClass("ibx-accordion-button");

		this.element.on("focus", this._onPageFocus.bind(this));
		this.element.append(btn, content)
		this.element.ibxAddClass("accordion-page-no-animate");
		this.add(this.element.children());

		//alternate to data-ibxp-text...direct text node children can be used to set the text.
		options.btnOptions.text = options.btnOptions.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");

		//need this on timer so we can stop the initial animation for selected pages.
		window.setTimeout(function(){this.element.ibxRemoveClass("accordion-page-no-animate");}.bind(this), 0);
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		var options = this.options;
		var contentId = this._content.prop("id");
		btnOptions = 
		{
			role:"tab",
			expanded: options.selected,
			controls: contentId,
			owns: contentId,
		};
		this._button.ibxWidget("setAccessibility", options.aria.accessible, btnOptions);
		return aria;
	},
	_destroy:function()
	{
		$.ibi.ibxRadioGroup.removeControl(this.options.group, this.element[0]);
		this.element.append(this._content.children());
		this._button.ibxWidget("destroy");
		this._content.ibxWidget("destroy");
		this._super();
	},
	button:function(){return this._button;},
	content:function(){return this._content;},
	children:function(selector)
	{
		return this._content.ibxWidget("children", selector);
	},
	add:function(el, sibling, before, refresh)
	{
		this._content.ibxWidget("add",  $(el).not(".ibx-accordion-page-button, .ibx-accordion-page-content"), sibling, before, refresh);
	},
	remove:function(el, destroy, refresh)
	{
		this._content.ibxWidget("remove", el, destroy, refresh);
	},
	/*Needed so this object can be part of an ibxRadioGroup.*/
	getValue:$.noop,
	checked:function(checked)
	{
		return (this.options.autoClose) ? this.selected(checked) : this;
	},
	_onBtnChange:function(e)
	{
		this.selected(!this.options.selected);
	},
	_onPageFocus:function(e)
	{
		this._button.focus();
	},
	selected:function(selected)
	{
		/****
			The pane's group listens for the 'change' event below and adjusts all pages accordingly.
			This WILL TRIGGER a call to 'checked', which will call this function...the if statement
			stops recurssion.
		****/
		if(typeof(selected) === "undefined")
			return this.options.selected;
		else
		if(this.options.selected != selected)
		{
			var type = selected ? "open" : "close";
			var event = this.element.dispatchEvent("ibx_before" + type)
			if(!event.isDefaultPrevented())
			{
				this.options.selected = selected;
				this.refresh();
				this._trigger(type);
				if(this.options.autoClose)
					this._trigger("change");
			}
		}
		return this;
	},
	_onTransition: function (e)
	{
		if (e.originalEvent.propertyName == "max-height")
		{
			// remove max-height at the end of the transition, so the page's content can grow as needed.
			// max-height is really used just for animation when page closed/opened.
			this._content.css({"maxHeight": "", "overflow":""});
		}
	},
	_setOption: function (key, value)
	{
		if(key == "selected")
			this.selected(value);
		else
			this._super(key, value);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		var selected = options.selected;

		//disable the content, if desired
		this._content.ibxWidget("option", "disabled", !selected);

		//set the button options and also its position
		opts = $.extend({}, this.options.btnOptions, selected ? options.btnOptionsOpen : null);
		this._button.ibxButton("option", opts).css("order", (options.btnPosition == "end") ? 1 : -1);
		options.btnShow ? this._button.ibxRemoveClass("acc-btn-hide") : this._button.ibxAddClass("acc-btn-hide");

		/****
			Figure out the desired height of the content so we can apply the max-height property which triggers the transition animation.
			WE ONLY DO THIS WHEN HEIGHT IS NOT 0 AS 0 WILL NOT CAUSE THE ANIMATION TO BE TRIGGERED AND THE MAX-HEIGHT WILL NOT BE REMOVED.
			In create we set max-height to 0 to force the initial transition.
		****/
		var nHeight = selected ? this._content.prop("scrollHeight") : this._content.height();
		if(nHeight != 0 && !this.element.hasClass("accordion-page-no-animate"))
		{
			this._content.css("maxHeight", nHeight + "px");
			this.element[0].offsetHeight;//this causes the document to reflow and trigger the max-height animation
		}

		this._content.css({"maxHeight": (selected && nHeight) ? (nHeight + "px") : "", "overflow":"hidden"});
		this.element.css("minHeight", selected ? (this._button.outerHeight(true) + "px") : "");

		//DO NOT MOVE THIS CODE ABOVER THE max-height CALCULATION CODE ABOVE!!!!!!
		selected ? this.element.ibxRemoveClass("acc-pg-closed") : this.element.ibxAddClass("acc-pg-closed");
		selected ? this._button.ibxRemoveClass("acc-btn-closed") : this._button.ibxAddClass("acc-btn-closed");
		selected ? this._content.ibxRemoveClass("acc-cnt-closed") : this._content.ibxAddClass("acc-cnt-closed");
	}
});
$.widget("ibi.ibxHAccordionPage", $.ibi.ibxAccordionPage, {options:{direction:"row"}, _widgetClass:"ibx-accordion-page-horizontal"});
$.widget("ibi.ibxVAccordionPage", $.ibi.ibxAccordionPage, {options:{direction:"column"}, _widgetClass:"ibx-accordion-page-vertical"});


//# sourceURL=accordion.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/menu.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.147 $:

/******************************************************************************
	IbxMenu
******************************************************************************/
$.widget("ibi.ibxMenu", $.ibi.ibxPopup,
{
	options:
	{
		"focusRoot":false,
		"focusDefault":true,
		"navKeyRoot":true,
		"navKeyDir":"vertical",
		"modal":false,
		"destroyOnClose":false,
		"multiSelect":false, //user can select multiple items without closing menu (checkboxes, etc.)
		"effect":"menu",
		"aria":{"role":"menu"}
	},
	_widgetClass: "ibx-menu",
	_create: function ()
	{
		this._super();
		var box = this._box = $("<div>").ibxVBox({"wrap":"false", "align":"stretch"}).ibxAddClass("ibx-menu-box");
		this.element.append(box);
		this.element.on("keydown", this._onMenuKeyDown.bind(this));
		this.element.on("ibx_menu_item_click", this._onMenuItemClick.bind(this));
		this.element.on("ibx_close_sub_menus", this.closeSubMenus.bind(this));
		this.element.children(".ibx-menu-item, .ibx-menu-separator").each(function(idx, el)
		{
			this.add(el);
		}.bind(this));
	},
	_setAccessibility:function(accessible, aria)
	{
		this._super(accessible, aria);
		return aria;
	},
	_destroy: function ()
	{
		this._super();
	},
	parentMenu:function(){return this.element.data("ibxParentMenu") || null;},
	children:function(selector)
	{
		selector = selector || ".ibx-menu-item, .ibx-menu-separator";
		return this._box.children(selector);
	},
	add:function(menuItem, sibling, before, refresh)
	{
		this._box.ibxWidget("add", menuItem, sibling, before, refresh);
	},
	remove:function(menuItem, destroy, refresh)
	{
		this._box.ibxWidget("remove", menuItem, destroy, refresh);
	},
	_onMenuKeyDown:function(e)
	{
		if(e.keyCode == $.ui.keyCode.TAB)
			this.close();
	},
	_onMenuItemClick:function(e, menuItem)
	{
		//trigger the event on this menu, then bubble to parent menus. Prevent default will stop menu from closing.
		if(this._trigger("select", e, menuItem))
		{
			//close if desired.
			if(this.options.autoClose && !this.options.multiSelect)
				this.close();
		
			//bubble event up owner chain.
			var parentMenu = this.parentMenu();
			if(parentMenu)
				parentMenu.trigger(e, menuItem);
		}
	},
	open:function(openInfo)
	{
		this._super(openInfo);
	},
	close:function(closeData)
	{
		this.closeSubMenus(null, closeData);
		this._super(closeData);
	},
	closeSubMenus:function(e, closeData)
	{
		this._box.children(".ibx-menu-item:hasSubMenu").ibxWidget("closeSubMenu", closeData);
	},
	_refresh: function ()
	{
		this._super();
	}
});
$.ibi.ibxPopup.statics.effect.menu = "pop-effect-menu";//NOT CURRENTLY USED - add custom menu display effect

/******************************************************************************
	IbxMenuItem
******************************************************************************/
$.widget("ibi.ibxMenuItem", $.ibi.ibxHBox,
{
	options:
	{
		"iconPosition":"right",
		"justify":"start",
		"align":"center",
		"type":"plain",
		"markerClass":"ibx-menu-item-marker",
		"startMarkerClass":"ibx-start-marker",
		"endMarkerClass":"ibx-end-marker",
		"labelClass":"ibx-menu-item-label",
		"labelOptions":{},
		"aria":
		{
			"role":"menuitem",
			"haspopup":false
		}
	},
	_widgetClass: "ibx-menu-item",
	_create:function()
	{
		this._super();

		var options = this.options;

		//alternate to data-ibxp-text...direct text node children can be used to set the text.
		options.labelOptions.text = options.labelOptions.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");

		this._startMarker = $("<div>");
		this._endMarker = $("<div>");
		this._label = $("<div>").ibxLabel();

		this.element.attr("tabIndex", -1).append(this._label, this._endMarker);
		this.element.on(
		{
			"keydown":this._onMenuItemKeyEvent.bind(this),
			"click":this._onMenuItemClick.bind(this),
			"mouseenter":this._onMenuItemMouseEvent.bind(this),
			"mouseleave": this._onMenuItemMouseEvent.bind(this)
		});
		this.addSubMenu(this.element.children(".ibx-popup"));
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);

		var subMenu = this.subMenu();
		aria.haspopup = !!subMenu;
		aria.expanded = subMenu ? subMenu.ibxWidget("isOpen") : null;

		(accessible) ? this._startMarker.attr("aria-hidden", true) : this._startMarker.removeAttr("aria-hidden");
		(accessible) ? this._endMarker.attr("aria-hidden", true) : this._endMarker.removeAttr("aria-hidden");
		return aria;
	},
	_destroy:function()
	{
		this._startMarker.remove();
		this._endMarker.remove();
		this._label.remove();
		this._super();
	},
	_onMenuItemKeyEvent:function(e)
	{
		if(e.keyCode == $.ui.keyCode.LEFT)//close if submenu
		{
			var menu = this.parentMenu();
			menu.ibxWidget("parentMenu") ? menu.ibxWidget("close") : null;
		}
		else
		if(e.keyCode == $.ui.keyCode.RIGHT && this.subMenu())//open if submenu
			this.element.trigger("click");
		else
		if(e.keyCode == $.ui.keyCode.ENTER || e.keyCode == $.ui.keyCode.SPACE)//activate
		{
			this.element.trigger("click");
			e.preventDefault();//stops body from doing weird scrolling
		}
	},
	_onMenuItemClick:function (e)
	{
		window.clearTimeout(this._subTimer);

		//does this item have a submenu?...if so show it...otherwise handle click.
		var subMenu = this.subMenu();
		if(subMenu)
		{
			subMenu.data("ibxParentMenu", this.parentMenu());
			subMenu.ibxWidget("option", {destroyOnClose: false, position:{of: this.element, at:"right top", my:"left top", collision:"flip fit"}}).ibxWidget("open");
		}
		else
		{
			this.refresh();
			this._trigger("menu_item_click", e, this.element);//bubble click event to owner menu.
			this.doCommandAction("trigger");
		}

		//stop this from bubbling, as menus can be stored under other objects, and a click on the menu item should not be
		//confused with a click on the parent...have to check for 'e' because this can be called directly without an event.
		if(e)
			e.stopPropagation();
	},
	_subTimer:null,
	_onMenuItemMouseEvent:function(e)
	{
		window.clearTimeout(this._subTimer);
		if(e.type == "mouseenter")
		{
			this._subTimer = window.setTimeout(function()
			{
				this._trigger("close_sub_menus", null, this.element);
				if(this.subMenu())
					this._onMenuItemClick();
			}.bind(this), 100);
		}
		e.stopPropagation();
	},
	text:function(text)
	{
		return this.option("text", text);
	},
	parentMenu:function(){return this.element.parents(".ibx-menu").first() || null;},
	subMenu:function()
	{
		var subMenu = this.element.data("ibxSubMenu");
		return subMenu || null;//can't return undefined, because jQueryUI will make that return 'this.element'
	},
	addSubMenu:function(subMenu)
	{
		this.removeSubMenu();
		subMenu = $(subMenu);
		if(subMenu.is(".ibx-popup"))
		{
			this.element.data("ibxSubMenu", subMenu);
			subMenu.appendTo(this.element);
			subMenu.on("ibx_open ibx_close", this._onSubMenuOpenClose.bind(this));
			this.refresh();
		}
	},
	removeSubMenu:function()
	{
		this.closeSubMenu();
		var subMenu = this.subMenu();
		if(subMenu)
		{
			this.element.removeData("ibxSubMenu");
			subMenu.detach().off("ibx_open ibx_close").removeData("ibxParentMenu");
			this.refresh();
		}
	},
	closeSubMenu:function(closeData)
	{
		var subMenu = this.subMenu();
		if(subMenu && subMenu.is(":openPopup"))
			subMenu.ibxWidget("close", closeData);
	},
	_onSubMenuOpenClose:function(e)
	{
		this.setAccessibility();
	},
	option:function(key, value, refresh)
	{
		if(key == "text" && !value)
			return this._label.ibxWidget("option", "text");
		return this._superApply(arguments);
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		if(key == "text")
		{
			if(value)
				options.labelOptions.text = value;
		}
		this._super(key, value);
	},
	_refresh:function()
	{
		this._super();

		var options = this.options;
		this._startMarker.ibxAddClass(sformat("{1} {2}", options.markerClass, options.startMarkerClass));
		this._label.ibxAddClass(options.labelClass);
		this._endMarker.ibxAddClass(sformat("{1} {2}", options.markerClass, options.endMarkerClass));
		this._endMarker.ibxToggleClass("ibx-marker-sub", !!this.subMenu());

		//setup the command shortcut key for the menu item
		var cmd = this.getCommand();
		var scut = cmd ? cmd.ibxWidget("option", "shortcut") : null;
		this._endMarker.text(scut).ibxToggleClass("ibx-end-marker-cmd-shortcut", !!cmd);

		//set the label's options...if there's no start marker (not check or radio) and no glyph...add space for glyph.
		var labelOptions = options.labelOptions;
		this._label.ibxLabel("option", labelOptions);
	}
});

/******************************************************************************
	IbxCheckMenuItem
******************************************************************************/
$.widget("ibi.ibxCheckMenuItem", $.ibi.ibxMenuItem,
{
	options:
	{
		"type":"check",
		"checked":false,
		"aria":
		{
			"role":"menuitemcheckbox",
			"checked":false
		}
	},
	_widgetClass: "ibx-menu-item-check",
	_create:function()
	{
		this._super();
		this.element.prepend(this._startMarker).ibxAddClass("ibx-can-toggle");
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		aria.checked = this.options.checked;
		aria.selected = this.options.checked;
		return aria;
	},
	_onMenuItemClick:function(e)
	{
		this.option("checked", !this.options.checked);
		this._super(e);
	},
	checked:function(checked)
	{
		if(checked === undefined)
			return this.options.checked;
		this.option("checked", checked);
	},
	_setOption:function(key, value)
	{
		var changed = this.options[key] != value;
		this._super(key, value);
		if(key == "checked" && changed)
		{
			this._trigger("change", null, this.element);
			this.doCommandAction("checked", value);
		}
	},
	_refresh:function()
	{
		var options = this.options;
		this.element.toggleClass("checked", options.checked);
		this._startMarker.ibxRemoveClass("ibx-marker-uncheck ibx-marker-check");
		this._startMarker.ibxAddClass(options.checked ? "ibx-marker-check" : "ibx-marker-uncheck");
		this._super();
	}
});

/******************************************************************************
	IbxRadioMenuItem
******************************************************************************/
$.widget("ibi.ibxRadioMenuItem", $.ibi.ibxCheckMenuItem,
{
	options:
	{
		"group":"",
		"aria":{"role":"menuitemradio"}
	},
	_widgetClass: "ibx-menu-item-radio",
	_create:function()
	{
		this._super();
	},
	_destroy:function()
	{
		$.ibi.ibxRadioGroup.removeControl(this.options.group, this.element[0]);
		this._super();
	},
	_init:function()
	{
		this._super();
		$.ibi.ibxRadioGroup.addControl(this.options.group, this.element[0]);
	},
	_onMenuItemClick:function(e)
	{
		/*call menu item click if radio button already selected*/	
		if(this.options.disabled || this.options.group && this.options.checked)
			$.ibi.ibxMenuItem.prototype._onMenuItemClick.call(this, e);
		else
			this._super(e);
	},
	getValue:$.noop,
	_refresh:function()
	{
		var options = this.options;
		this._startMarker.ibxRemoveClass("ibx-marker-radio-uncheck ibx-marker-radio-check");
		this._startMarker.ibxAddClass(options.checked ? "ibx-marker-radio-check" : "ibx-marker-radio-uncheck");
		this._super();
	}
});
$.ibi.ibxRadioMenuItem.statics = 
{
};

/******************************************************************************
	ibxMenuSeparator
	Just a utility widget for handling a menu separator...really just sets the class on the div.
******************************************************************************/
$.widget("ibi.ibxMenuSeparator", $.ibi.ibxWidget,{options:{"aria":{"role":"separator", "hidden":true}},_widgetClass: "ibx-menu-separator",});

/******************************************************************************
	ibxMenuBar
	Simple derivation of ibxHBox/ibxVBox...mostly for markup readability
******************************************************************************/
$.widget("ibi.ibxMenuBar", $.ibi.ibxHBox,
{
	"options":
	{
		"navKeyDir":"horizontal",
		"navKeyRoot":true,
		"focusDefault":true,
		"direction":"row",
		"align":"stretch",
		"aria":
		{
			"role":"menubar",
		}
	},
	_widgetClass:"ibx-menu-bar",
	_create:function()
	{
		this._super();
	},
	_refresh:function()
	{
		this._super();
		this.children(".ibx-menu-button").attr("tabIndex", -1);
	}
});
$.widget("ibi.ibxHMenuBar", $.ibi.ibxMenuBar, {options:{direction:"row"}, _widgetClass:"ibx-hmenu-bar"});
$.widget("ibi.ibxVMenuBar", $.ibi.ibxMenuBar, {options:{direction:"column", aria:{orientation:"vertical"}, "navKeyDir":"vertical"}, _widgetClass:"ibx-vmenu-bar"});

/******************************************************************************
	ibxMenuButton
	Let's you define a button that will show a menu
******************************************************************************/
$.widget("ibi.ibxMenuButton", $.ibi.ibxButtonSimple,
{
	options:
	{
		"menu":null,
		"showArrow":false,
		"justify":"start",
		"menuOptions":
		{
			"position":
			{
				/* for my/at position values see: http://api.jqueryui.com/position/ */
				"my":"left top",
				"at":"left bottom",
				"of":null,
				"collision":"flip",
				"using":null,
				"within":null,
			},
		},
		"aria":
		{
			"role":"button",
			"haspopup":true,
		}
	},
	_widgetClass: "ibx-menu-button",
	_create:function()
	{
		var options = this.options;
		options.menuOptions.position.of = this.element[0];
		this.element.on({"click": this._onClickEvent.bind(this)});

		//save bound functions in case someone resets the menu option...need to remove the event listeners.
		this._onBeforeMenuOpenCloseBound = this._onBeforeMenuOpenClose.bind(this);
		this._onMenuSelectBound = this._onMenuSelect.bind(this);

		//get/make the menu...if menu isn't in the dom, tuck it under this element for safe keeping...must be in dom for accessibility.
		var menu = options.menu = options.menu || this.element.children(".ibx-popup")[0] || $("<div class='ibx-menu-button-default-menu'>").ibxMenu();
		if(!menu.parentElement)
			this.element.append(menu);
		
		this.option("menu", menu);
		this._super();
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);
		aria.owns = options.menu.prop("id");
		aria.expanded = options.menu.ibxWidget("isOpen");
		return aria;
	},
	_init:function()
	{
		this._super();
		var menuItems = this.element.children(".ibx-menu-item, .ibx-menu-separator").detach();
		this.add(menuItems);
	},
	children:function(selector)
	{
		return this.options.menu.ibxWidget("children", selector);
	},
	add:function(el, elSibling, before, refresh)
	{
		this.options.menu.ibxWidget("add", el, elSibling, before, refresh);
	},
	remove:function(el, destroy, refresh)
	{
		this.options.menu.ibxWidget("remove", el, destroy, refresh);
	},
	showMenu:function(show)
	{
		this.options.menu.ibxWidget(show ? "open" : "close");
	},
	_onClickEvent:function(e)
	{
		//[HOME-584]...my bad.
		var options = this.options;
		var event = $.Event(e.origionalEvent);
		event.type = "ibx_click";
		event.menu = options.menu;
		this.element.trigger(event);

		//menu might have changed...reset after event.
		var menu = event.menu;
		this.option("menu", menu);

		//open the menu if it is a menu, and it has items, or is some other popup type.
		if(!menu.is(".ibx-menu") || menu.ibxWidget("children", "*").length)
			menu.ibxWidget("open");
	},
	_onKeyEvent:function(e)
	{
		var eType = e.type;

		//other keys - enter/space will trigger the click as a normal button will.
		if(eType == "keyup" && e.keyCode == $.ui.keyCode.DOWN)
		{
			this.element.trigger("click");
			e.stopPropagation();
		}
		else
		if(eType == "keydown" && e.keyCode == $.ui.keyCode.DOWN)
		{
			e.preventDefault();//stops the body from scrolling
			e.stopPropagation();
		}
		this._super(e);
	},
	_onBeforeMenuOpenClose:function(e)
	{
		this.setAccessibility();
	},
	_onMenuSelect:function(e, menuItem)
	{
		this.element.dispatchEvent("ibx_select", menuItem, false, false);
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		if(key == "menu")
		{
			var menu = $(options.menu);
			menu.off("ibx_beforeopen ibx_beforeclose", this._onBeforeMenuOpenCloseBound).off("ibx_select", this._onMenuSelectBound);
			menu = $(value);
			menu.ibxAriaId().on("ibx_beforeopen ibx_beforeclose", this._onBeforeMenuOpenCloseBound).on("ibx_select", this._onMenuSelectBound);
			value = menu;
		}
		this._super(key, value);
	},
	_refresh:function()
	{
		var options = this.options;
		options.menu.ibxWidget("option", options.menuOptions);
		options.iconPosition = options.showArrow ? "right" : options.iconPosition;
		options.glyph = options.showArrow  ? "arrow_drop_down" : options.glyph;
		options.glyphClasses = options.showArrow ? "material-icons ibx-menu-button-arrow" : options.glyphClasses;
		this._super();
	}
});
//defined types mostly for markup readability
$.widget("ibi.ibxHMenuButton", $.ibi.ibxMenuButton,{options:{},_widgetClass: "ibx-hmenu-button"});
$.widget("ibi.ibxVMenuButton", $.ibi.ibxMenuButton,
{
	options:{position:{at:"right top"}},
	_widgetClass: "ibx-vmenu-button",
	_onKeyEvent:function(e)
	{
		if(e.keyCode == $.ui.keyCode.RIGHT)
			this.element.trigger("click");
		this._super(e);
	},
	_refresh:function()
	{
		this._super();
		this._glyph.ibxToggleClass("ibx-menu-button-arrow-right", this.options.showArrow);
	}
});

/******************************************************************************
	ibxMenuSelect
	Let's you define a button that will show a menu and let you pick an item (or multiple)
******************************************************************************/
$.widget("ibi.ibxSelectMenuButton", $.ibi.ibxMenuButton,
{
	options:
	{
		"userValue":null,
		"editable":false,
		"filterValues":false,
		"filterNoCase":true,
		"showArrow":true,
		"useSelectionAsText":true,
		"placeholder":"",
		"multiSelect":false,
		"menuSelOptions":
		{
			selectableChildren:".ibx-select-menu-item",
			type:"single",
			toggleSelection: false,
			escClearSelection:false,
			focusResetOnBlur:false
		},
		"aria":
		{
			"role":"combobox",//turn button into a combobox.
		}
	},
	_widgetClass: "ibx-select-menu-button",
	_create:function()
	{
		this._super();
		var options = this.options;
		options.placeholder = options.placeholder || options.text;
		this._text.ibxEditable({commitKey:null, cancelKey:null}).on("ibx_textchanging", this._onTextChanging.bind(this)).on("keydown", this._onTextKeyDown.bind(this));
		this.element.on("ibx_widgetfocus", this._onWidgetFocus.bind(this));
		this._sm = options.menu.ibxSelectionManager("option", options.menuSelOptions).ibxSelectionManager("instance");
		this._sm.element.on("ibx_selchange", this._onMenuSelChange.bind(this));
	},
	_setAccessibility:function(accessible, aria)
	{
		this._super(accessible, aria);
		this.options.menu.ibxWidget("option", "aria.role", "listbox");//turn menu into a list box
		this.options.menu.ibxWidget("option", "aria.multiselectable", this.options.multiSelect ? true : null);//turn menu into a list box
		this.element.attr("title", this.options.text);
		return aria;
	},
	_init:function()
	{
		// have to set multiselect from markup before setting userValue or it won't process userValue properly (from markup or js)
		var markupOpts = ibx.getIbxMarkupOptions(this.element);//unfortunately redundant, but for some reason js is processing userValue before multiSelect option.
		var multiSelect = markupOpts.multiSelect || this.options.multiSelect;
		this.options.multiSelect = undefined;
		this.option("multiSelect", multiSelect);
		this._super();
	},
	add:function(el, elSibling, before, refresh)
	{
		this._super(el, elSibling, before, refresh);
		var userValue = this.options.multiSelect ? this.options.userValue : [this.options.userValue];//if multiselect, then possibly add to existing selection.
		$(el).attr("role", "option").each(function(idx, el)
		{
			el = $(el);
			var sel = el.ibxWidget("option", "selected");
			if(sel)
				userValue.push(el.ibxWidget("userValue"));
 		}.bind(this));
		this.option("userValue", userValue)
	},
	remove:function(el, destroy, refresh)
	{
		this._super(el, destroy, refresh);
		$(el).attr("role", "menuitem");
	},
	_onWidgetFocus:function(e)
	{
		this.startEditing();
	},
	isEditing:function()
	{
		return this._text.ibxEditable("isEditing");
	},
	startEditing:function()
	{
	},
	stopEditing:function()
	{
	},
	_onKeyEvent:function(e)
	{
		this._super(e);
	},
	_onTextKeyDown:function(e)
	{
		if(e.keyCode == $.ui.keyCode.DOWN)
			this.options.menu.focus();
	},
	_onTextChanging:function(e)
	{
	},
	selected:function(el, select)
	{
		if(el === undefined)
			return this._sm.selected();

		el = $(el);
		this._sm.selected(el, select, select, select);
	},
	_onBeforeMenuOpenClose:function(e)
	{
		this._super(e);
	},
	_onMenuSelChange:function(e)
	{
		//selection changing from _setOption, so don't do this!
		if(this._inSetOption || !e.originalEvent.data.selected)
			return;

		//on menu selection set the control's userValue based on selected item(s).
		var userValues = [];
		$(this._sm.selected()).each(function(idx, el)
		{
			el = $(el);
			userValues.push(el.ibxWidget("userValue"));
		}.bind(this));
		this.option("userValue", userValues);
		this.element.dispatchEvent("ibx_selchange", e.originalEvent.data, false, false);
	},
	_setOption:function(key, value)
	{
		var options = this.options;

		if(key == "placeholder")
			this.option("text", value, false);
		else
		if(key == "multiSelect" || key == "menuSelOptions")
		{
			var multiSelect = options.multiSelect;
			if(key == "multiSelect")
			{
				multiSelect = value;
				options.value = multiSelect ? [] : null;
				options.menuSelOptions.type = (multiSelect ? "multi" : "single");
				options.menuSelOptions.toggleSelection = multiSelect;
			}
			options.menu.ibxWidget("option",{multiSelect:multiSelect, selMgrOpts:options.menuSelOptions});
		}
		else
		if(key == "userValue" && !this._inSetOption)
		{
			var labelText = [];
			var selItems = [];
			var items = this.children();

			value = (value instanceof Array) ? value : [value];//value has to be an array.
			for(var i = 0; i < items.length; ++i)
			{
				var item = $(items[i]);
				var itemValue = item.ibxWidget("userValue");
				var sel = (itemValue && (value.indexOf(itemValue) != -1));
				if(sel)
				{
					selItems.push(item[0]);
					labelText.push(item.ibxWidget("text"));
				}
			}

			//single select turn uservalue into single value, not array.
			if(!options.multiSelect)
			{
				selItems.length = labelText.length = 1;
				value = value[0];
			}

			//set label
			labelText = labelText.length ? labelText.join(", ") : options.placeholder;
			this.option("text", labelText);

			//adjust selection model, and save value as normal.
			this._inSetOption = true;
			this._sm.selected(selItems, true, true, true);
			this._super(key, value);//so events will be triggered...both widget, and command.
			this._inSetOption = false;
			return;
		}
		this._super(key, value);
	},
	getSelectionManager:function()
	{
		return this._sm;
	},
	_refresh:function()
	{
		var options = this.options;
		this._text.ibxToggleClass("ibx-select-menu-button-label-editable", options.editable).attr("tabindex", options.editable ? "-1" : null);
		this._super();
	}
});

//defined types mostly for markup readability
$.widget("ibi.ibxHSelectMenuButton", $.ibi.ibxSelectMenuButton,{options:{},_widgetClass: "ibx-hselectmenu-button"});
$.widget("ibi.ibxVSelectMenuButton", $.ibi.ibxSelectMenuButton,
{
	options:{position:{at:"right top"}},
	_widgetClass: "ibx-vselectmenu-button",
	_onKeyEvent:function(e)
	{
		if(e.keyCode == $.ui.keyCode.RIGHT)
			this.element.trigger("click");
		this._super(e);
	},
	_refresh:function()
	{
		this._super();
		this._glyph.ibxToggleClass("ibx-menu-button-arrow-right", this.options.showArrow);
	}
});

//Simple derived widget for select menu items.
$.widget("ibi.ibxSelectMenuItem", $.ibi.ibxMenuItem,
{
	options:
	{
		selected:false,
	},
	_widgetClass:"ibx-select-menu-item",
	_create:function()
	{
		this.options.userValue = this.options.userValue || ("smiAutoUserValue" + $.ibi.ibxSelectMenuItem.autoUserValue++);
		this._super();
	},
	_setOption:function(key, value)
	{
		this._super(key, value);
		var options = this.options;
		if(key == "selected")
			this.element.closest(".ibx-selection-manager").ibxSelectionManager("selected", this.element, options.selected);
	},
	selected:function(selected)
	{
		if(selected === undefined)
			return this.options.selected;
		this.option("selected", selected);
	}
});
$.ibi.ibxSelectMenuItem.autoUserValue = 0;

/******************************************************************************
	ibxSplitMenuButton
	combination button/menu...pressing button will be equiv of selecting defaultMenuItem
******************************************************************************/
$.widget("ibi.ibxSplitMenuButton", $.ibi.ibxButtonSimple,
{
	options:
	{
		"class":"split-button",
		"defaultMenuItem":null,
		"align":"center",
		"menuOptions":
		{
			"class":"split-menu",
			"justify":"center",
			"position":
			{
				"my":"left top",
				"at":"left bottom",
			}
		},
		"aria":
		{
			"role":"button",
			"haspopup":true
		}
	},
	_widgetClass:"ibx-split-menu-button",
	_create:function()
	{
		this._super();
		var options = this.options;

		options.menuOptions.position.of = this.element;
		var menu = this.element.children(".ibx-popup");
		var menuBtn = this._menuBtn = $("<div>").append(menu).ibxMenuButton().on("mousedown click", this._onMenuButtonMouseEvent.bind(this)).attr("title", ibx.resourceMgr.getString("IBX_SPLIT_BUTTON_DOWN_ARROW_TITLE"));
		var separator = this._separator = $("<div class='split-separator'>");
		this.element.append(separator, menuBtn).on({"click":this._onBtnClick.bind(this)});
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		return aria;
	},
	menu:function(menu)
	{
		if(menu === undefined)
			return this._menuBtn.ibxWidget("option", "menu");
		this._menuBtn.ibxWidget("option", "menu", menu);
		this.refresh();
	},
	_onBtnClick:function(e)
	{
		var event = $.Event(e.origionalEvent);
		event.type = "ibx_click";
		this.element.trigger(event);

		var menu = event.menu || this._menuBtn.ibxWidget("option", "menu");
		var defItem = menu.ibxWidget("children", ".ibx-split-button-default-item");
		defItem.trigger("click");
	},
	_onKeyEvent:function(e)
	{
		var eType = e.type;
		if(eType == "keyup" && e.keyCode == $.ui.keyCode.DOWN)
			this._menuBtn.trigger("click");
		else
		if(eType == "keydown" &&  e.keyCode == $.ui.keyCode.DOWN)
			e.preventDefault();
		this._super(e);
	},
	_onMenuButtonMouseEvent:function(e)
	{
		if(e.type == "mousedown")
		{
			var event = $.Event(e.origionalEvent);
			event.type = "ibx_menubuttonmousedown";
			this.element.trigger(event);
			var menu = this._menuBtn.ibxWidget("option", "menu");
			menu.css("minWidth", this.element.css("width"));
		}
		if(e.type == "click")
			e.stopPropagation();
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		this._menuBtn.ibxWidget("option", options.menuOptions);

		var menu = this._menuBtn.ibxWidget("option", "menu");
		menu.ibxWidget("option", "position", options.menuOptions.position);
		menu.css("minWidth", this.element.css("width"));

		var menuItems = menu.ibxWidget("children");
		menuItems.ibxRemoveClass("ibx-split-button-default-item").filter(options.defaultMenuItem).ibxAddClass("ibx-split-button-default-item");
	}
});
//defined types mostly for markup readability
$.widget("ibi.ibxHSplitMenuButton", $.ibi.ibxSplitMenuButton,{options:{},_widgetClass: "ibx-hsplit-menu-button"});
$.widget("ibi.ibxVSplitMenuButton", $.ibi.ibxSplitMenuButton,{options:{menuOptions:{position:{my:"left top", at:"right top"}}},_widgetClass: "ibx-vsplit-menu-button"});

//separator between menu buttons
$.widget("ibi.ibxMenuButtonSeparator", $.ibi.ibxWidget,{options:{"aria":{"role":"separator", "hidden":true}},_widgetClass: "ibx-menu-button-separator",});



//# sourceURL=menu.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/groupbox.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.5 $:

$.widget("ibi.ibxGroupBox", $.ibi.ibxWidget,
{
	options:
		{
			"titlePosition": "top-left",
			"text": "",
			"glyph": "",
			"glyphClasses": "",
			"icon": "",
			"iconPosition": "left",
			"labelOptions": {}
		},
	_widgetClass: "ibx-group-box",
	_create: function ()
	{
		this._super();
		this.options.text = this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");
		this.options.labelOptions.display = "block";
		this._labelBox = $("<div></div>").ibxHBox();
		this._label = $("<div></div>").ibxLabel();
		this._labelBox.append(this._label);
		this._labelBox.css("position", "absolute");
		this._labelBox.css("left", "0px");
		this._labelBox.css("right", "0px");
		this._labelBox.ibxWidget('option', 'alignIems', 'center');
		this.element.css("position", "relative");
	},
	_destroy: function ()
	{
		this._label.remove();
		this._super();
	},
	_refresh: function ()
	{
		this.options.labelOptions.text = this.options.text;
		this.options.labelOptions.glyph = this.options.glyph;
		this.options.labelOptions.glyphClasses = this.options.glyphClasses;
		this.options.labelOptions.icon = this.options.icon;
		this.options.labelOptions.iconPosition = this.options.iconPosition;
		this.options.labelOptions.justify = (this.options.titlePosition.search("left") != -1) ? "start" : (this.options.titlePosition.search("right") != -1 ? "end" : "center");
		this._label.ibxWidget('option', this.options.labelOptions);
		this._label.ibxAddClass("ibx-group-box-label");
		this.element.ibxRemoveClass("ibx-group-label-pos-top ibx-group-label-pos-bottom");
		if (this.options.titlePosition.search("top") != -1)
		{
			this.element.ibxAddClass("ibx-group-label-pos-top");
			this.element.prepend(this._labelBox);
			this._labelBox.css("top", (-this._labelBox.outerHeight() / 2) + "px");
			this._labelBox.css("bottom", "");
		}
		else
		{
			this.element.ibxAddClass("ibx-group-label-pos-bottom");
			this.element.append(this._labelBox);
			this._labelBox.css("bottom", (-this._labelBox.outerHeight() / 2) + "px");
			this._labelBox.css("top", "");
		}
		this._labelBox.ibxWidget('option', 'justify', (this.options.titlePosition.search("left") != -1) ? "start" : (this.options.titlePosition.search("right") != -1 ? "end" : "center"));
		this._super();
	}
});


//# sourceURL=groupbox.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/gridstack.ibx.js"><![CDATA[/*Copyright 1996-2017 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.14 $:

//////////////////////////////////////////////////////////////////////////
$.widget("ibi.ibxGridStack", $.ibi.ibxWidget,
{
	options:
		{
			minHeight: 300,
			width: 12,
			float: false,
			acceptWidgets: '.grid-stack-item',
			resizable: {
				handles: 'se, s, sw'
			},
			defaultCellWidth: 4,
			defaultCellHeight: 4,
			animate: true,
		},
	_widgetClass: "ibx-grid-stack",
	_create: function ()
	{
		this.element.gridstack(this.options);
		this.element.ibxAddClass("grid-stack");
		this.element.css('min-height', this._getMinHeight());
		this._super();
		// Stop bubbling of jquery ui events "resize", "drag", "drop"
		this.element.on('resize', function (event) { event.stopPropagation(); });
		this.element.on('drag', function (event) { event.stopPropagation(); });
		this.element.on('drop', function (event) { event.stopPropagation(); });
	},
	addCell: function (cell, x, y, width, height)
	{
		width = width || this.options.defaultCellWidth;
		height = height || this.options.defaultCellHeight;
		this.element.css('min-height', "");
		var grid = this.element.data('gridstack');
		var outercell = $("<div class='grid-stack-item'>");
		var innercell = $("<div class='grid-stack-item-content'>");
		outercell.append(innercell);
		innercell.append(cell);
		//outercell.attr('data-gs-locked', true);
		grid.addWidget(outercell, x, y, width, height, false);
		//outercell.data('_gridstack_node').locked = false;
		this.element.on('resizestart', function (event, ui)
		{
			$("iframe").css("pointer-events", "none");
		});
		this.element.on('resizestop', function (event, elem)
		{
			$("iframe").css("pointer-events", "");
		});
	},
	removeCell: function (cell, detachNode)
	{
		var el = $(cell).closest('.grid-stack-item');
		if (el)
		{
			el.fadeOut(200, function ()
			{
				var grid = this.element.data('gridstack');
				grid.removeWidget(el, detachNode);
				if (this.element.children('.grid-stack-item').length == 0)
					this.element.css('min-height', this._getMinHeight());
			}.bind(this));
		}
	},
	_getMinHeight: function ()
	{
		return this.options.minHeight + "px";
	},
	_destroy: function ()
	{
		this._super();
	},
	_refresh: function ()
	{
		this._super();
	}
});


//# sourceURL=gridstack.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/select.ibx.js"><![CDATA[/*Copyright 1996-2017 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.136 $:

$.widget("ibi.ibxSelectBase", $.ibi.ibxTextField,
{
	options:
		{
			"btnShow": true,
			"popup": true,
			"popupOnArrowOnly":false,

			// overrides for the base
			"autoComplete": "off",
			"autoCorrect": "off",
			"autoCapitalize": "off",
			"spellCheck": "false",
			"controlClasses": "",
			
			"navKeyDir":"vertical",

			"aria":
			{
				"role":"combobox",
				"multiline":null,
				"haspopup":"listbox"
			}
		},
	_widgetClass: "ibx-select-base",
	_control: null,
	control: function () { return this._control; },
	_popup: null,
	popup: function () { return this._popup;},
	_create: function ()
	{
		this._super();
	},
	_setAccessibility:function(accessible, aria)
	{
		var options = this.options;
		aria = this._super(accessible, aria);
		aria.expanded = this.options.popup && this._popup ? this._popup.ibxWidget("isOpen") : true;
		aria.controls = aria.owns = (this.options.popup && this._popup) ? this._popup.prop("id") : (this._control ? this._control.prop("id"): "");
		return aria;
	},
	_init: function ()
	{
		this._super();
		if (this.options.popup)
		{
			this.options.wrap = false;
			this._dropButton = $("<div class='ibx-select-open-btn'>").ibxButton({aria:{hidden:true}});
			this.element.append(this._dropButton);
			this._dropButton.on("mousedown", this._onButtonMouseDown.bind(this)).on("click", this._onButtonClick.bind(this));
		}
		else
		{
			this.options.wrap = true;
		}

		this.element.on("ibx_textchanged", this._onTextChanged.bind(this));
		if (this.options.popup)
			this._textInput.on("click", this._onTextClick.bind(this));
		this._bindControl();
		this.refresh();
	},
	navKeyChildren:function(selector)
	{
		return this.element.children(selector || ":ibxNavFocusable");
	},
	// overridables in derived functions
	_createControl: function ()
	{
		// return the control in derived
		return null;
	},
	_initControl: function ()
	{
		// init the control in derived
	},
	_onControlChange: function (e, data)
	{
		if (e.target == this._control[0])
			return this._trigger("change", e, data);
	},
	_onControlBeforeChange: function (e, data)
	{
		if (e.target == this._control[0])
			return this._trigger("beforechange", e, data);
	},
	_onPopupOpen: function ()
	{
	},
	_onPopupClose: function ()
	{
	},
	_onTextChanged: function (e)
	{
	},
	_onDownArrow: function(e)
	{
		if(this.options.popup && !this._popup.ibxWidget("isOpen"))
		{
			this._openPopup(e);
		}
	},
	_boundPopupPosition: null,
	_popupPosition: function (pos, info)
	{
		// fine-tune the position and size of the popup
		if (this.options.popup)
			this._popup.css(pos);	

	},	
	// end overridables

	_bindControl: function ()
	{
		this._control = this._createControl();
		this._control.on("ibx_change", this._onControlChange.bind(this));
		this._control.on("ibx_beforechange", this._onControlBeforeChange.bind(this));
		
		if (this.options.popup)
		{
			this._boundPopupPosition = this._popupPosition.bind(this);
			this._popup = $("<div class='ibx-select-popup'>").ibxPopup(
			{
				"modal":false,
				"destroyOnClose":false,
				"effect":"fade",
				"position":{ my: "left top", at: "left bottom+1px", of: this.element, collision: "none", using: this._boundPopupPosition },
			});
			this._popup.on("ibx_open ibx_close", function(e)
			{
				this.setAccessibility();
			}.bind(this));
			this._control.ibxWidget('option', 'focusRoot', true);
			this._popup.ibxWidget("add", this._control);
			this.element.append(this._popup);
			this._popup.on("ibx_open", function (e)
			{
				this._onPopupOpen();
			}.bind(this)).on("ibx_beforeclose", function(e, closeData)
			{
				if (closeData && $.contains(this.element[0], closeData.target))
					return false;
			}.bind(this)).on("ibx_close", function ()
			{
				this._onPopupClose();
			}.bind(this));
			}
		else
		{
			this._control.css("width", "100%").css("align-self", "flex-start");
			this.element.append(this._control);
		}

		this._initControl();
	},
	_onButtonMouseDown: function (e)
	{
		this._textInput.focus();
	},
	// Override text
	_onTextInputKeyDown: function (e)
	{
		if(e.keyCode == $.ui.keyCode.DOWN) // open dropdown on down arrow
		{
			this._onDownArrow(e);
		}
		else if(e.keyCode == $.ui.keyCode.ESCAPE) // close dropdown on up arrow or enter
		{
			if(this.options.popup && this._popup.ibxWidget("isOpen"))
				this._popup.ibxWidget("close");
		}
		else if(e.keyCode == $.ui.keyCode.ENTER) // close dropdown on enter and update with the selection
		{
			if(this.options.popup && this._popup.ibxWidget("isOpen"))
				this._popup.ibxWidget("close");
		}
		else if (e.keyCode == $.ui.keyCode.TAB) // close popup on tab
		{
			if(this.options.popup && this._popup.ibxWidget("isOpen"))
				this._popup.ibxWidget("close");
		}
		else if (e.keyCode != 37 && e.keyCode != 39 && !e.shiftKey && !e.ctrlKey) // open popup for everything except left/right arrows
		{
			if(this.options.popup && !this._popup.ibxWidget("isOpen"))
				this._openPopup(e);
		}
		this._super(e);
	},
	_onTextInputBlur: function (event)
	{
		var newVal = this._textInput.val();
		if (newVal != this._focusVal)
		{
			var relatedTarget = event.relatedTarget ? event.relatedTarget : document.activeElement;
			if (!$.contains(this._control[0], relatedTarget) && this._control[0] != relatedTarget)
				this._setValue(newVal, true);
		}
	},
	_onTextClick: function (e)
	{
		this._dontFocusText = false;
		this._openPopup(e);
	},
	_onButtonClick: function (e)
	{
		if (this._popup.ibxWidget("isOpen"))
			this._popup.ibxWidget("close");
		else
		{
			this._dontFocusText = false;
			this._openPopup(e);
		}
	},
	closePopup: function ()
	{
		this._popup.ibxWidget("close");
	},
	openPopup: function ()
	{
		this._openPopup();
	},
	_openPopup: function(e)
	{
		var event = this.element.dispatchEvent("ibx_beforeopenpopup", e);
		if(!event.isDefaultPrevented())
		{
			if(!this._popup.ibxWidget("isOpen"))
			{
				this._popup.ibxWidget("open");
				this._control.ibxWidget("refresh");
			}
		}
		else
			this._popup.ibxWidget("close");
	},
	_destroy: function ()
	{
		this._super();
		if (this._dropButton)
			this._dropButton.remove();
		this._control.remove();
	},
	_refresh: function ()
	{
		this._super();
		if (this._dropButton)
			this.options.btnShow ? this._dropButton.show() : this._dropButton.hide();

		if (this._control)
		{
			if (this.options.controlClasses && this._control)
				this._control.ibxAddClass(this.options.controlClasses);
		}
	}
});

$.widget("ibi.ibxSelect", $.ibi.ibxSelectBase,
{
	options:
		{
			"multiSelect": false,
			"autoHeight": true,
			"autoHeightGap": 50,
		},
	_widgetClass: "ibx-select",
	_create: function ()
	{
		this._super();
	},
	_init: function ()
	{
		this._super();
		this.element.on('ibx_action', this._onAction.bind(this));
	},
	_createControl: function ()
	{
		return $("<div tabindex='0'>").ibxSelectItemList({"multiSelect": this.options.multiSelect});
	},
	_initControl: function ()
	{
		this._control.ibxWidget("add", this.element.children(".ibx-select-item, .ibx-select-group, .ibx-select-separator"));
	},
	_setValue: function (value, bFormat, extra)
	{
		this.options.text = bFormat && this.options.fnFormat ? this.options.fnFormat(value) : value;
		this.refresh();
		var data = {"text": this.options.text};
		if (extra)
			$.extend(data, extra);
		this._trigger("change", null, data);
	},
	_onControlChange: function (e, data)
	{
		if (e.target !== this._control[0])
			return;
		this._setValue(this._control.ibxWidget("getText"), true, data);
		if(this.options.popup && !this._control.ibxWidget("option", "multiSelect") && this._popup)
			this._popup.ibxWidget("close");
	},
	_onPopupOpen: function ()
	{
		if (!this._dontFocusText)
			this._textInput.focus();
		else
		{
			if (this.options.readonly)
				this._control.ibxWidget("focusSelItem");
		}
		this._dontFocusText = false;
	},
	_onPopupClose: function ()
	{
		window.setTimeout(function (){
			if (!this.destroyed())
				this._control.ibxWidget("resetHighlight");
		}.bind(this), 10);
	},
	_onTextChanged: function (e)
	{
		this._control.ibxWidget("setHighlight", this._textInput.val());
	},
	_onAction: function (e)
	{
		this._control.ibxWidget("selectHighlight");
	},
	_onDownArrow: function (e)
	{
		this._super(e);
		if(this.options.popup)
		{
			if (this._popup.ibxWidget("isOpen"))
				this._control.ibxWidget("focusSelItem");
			else
				this._dontFocusText = true;
		}
		else
			this._control.ibxWidget("focusSelItem");
	},
	addControlItem:function(el, sibling, before, refresh)
	{
		this._control.ibxWidget("add", el, sibling, before, refresh);
	},
	removeControlItem: function (el, destroy, refresh)
	{
		this._control.ibxWidget("remove", el, destroy, refresh);
	},
	controlItems: function (selector)
	{
		this._control.ibxWidget("children", selector);
	},
	selected: function (element)
	{
		return this._control.ibxWidget("selected", element);
	},
	userValue: function (value)
	{
		return this._control.ibxWidget("userValue", value);
	},
	_popupPosition: function (pos, info)
	{
		if (this.options.popup)
		{
			if (this.options.autoHeight)
			{
				var maxHeight = $(window).height() + $(window).scrollTop() - info.target.top - info.target.height - this.options.autoHeightGap;
				if (maxHeight < 100)
				{
					/*
					maxHeight = info.target.top - $(window).scrollTop() - this.options.autoHeightGap;
					if (maxHeight > 100)
					{
						pos.top = info.target.top - maxHeight;
					}
					else
					*/
						maxHeight = 100;	
				}	
				this._control.css("max-height", maxHeight + "px");
			}	
			this._control.css("min-width", info.target.width + "px");
			this._popup.css(pos);
		}
	},	
	_refresh: function ()
	{
		this._super();
		if (this._control)
			this._control.ibxWidget("option", "multiSelect", this.options.multiSelect);
	},
});

$.widget("ibi.ibxSelectItemList", $.ibi.ibxVBox,
{
	options:
	{
		"multiSelect": false,
		"align": "stretch",
		"navKeyRoot":true,
		"navKeyDir":"vertical",
		"navKeyResetFocusOnBlur":false,
		"navKeyKeys":
		{
			"cancel":"",
		},
		"focusDefault": true,
		"aria":{"accessible":true, "role":"listbox", "hidden":false},
		"filter": false,
	},
	_widgetClass: "ibx-select-item-list",
	_create: function ()
	{
		this._super();

	},
	_init: function ()
	{
		this._super();
		this.add(this.element.children(".ibx-select-item, .ibx-select-group, .ibx-select-separator"));
		this.element.on("click", this._onSelect.bind(this));
	},
	add: function (el, sibling, before, refresh)
	{
		el = $(el).filter(".ibx-select-group, .ibx-select-item, .ibx-select-separator");
		this._super(el, sibling, before, false);

		var selChildren = [];
		el.each(function(idx, el)
		{
			el = $(el);
			if (el.hasClass("ibx-select-group"))
			{
				el.ibxWidget("option", "selectCtrl", this.element);
				var children = el.children(".ibx-select-item");
				children.prepend($("<div>").ibxAddClass("ibx-select-group-marker")).ibxAddClass("ibx-select-group-item ibx-radio-group-" + $(el).attr("id"));
				this._super(children, el, false, false);
				children.each(function (index, el)
				{
					if ($(el).ibxWidget("option", "selected") || this.options.userValue && this.options.userValue == $(el).ibxWidget("option", "userValue"))
						selChildren.push($(el));
				}.bind(this));
			}
			else if (el.hasClass("ibx-select-separator"))
			{
				;// do nothing for separators
			}
			else
			{
				if (el.ibxWidget("option", "selected") || this.options.userValue && this.options.userValue == el.ibxWidget("option", "userValue"))
					selChildren.push($(el));
			}
		}.bind(this));
		selChildren.forEach(function(el){
			this._setSelection(el, true);
		}.bind(this));
	},
	_sortType: true,
	_fnSort: null,
	getSortType: function ()
	{
		return this._sortType;
	},
	sort: function (type, fnSort)
	{
		this._sortType = type = (typeof(type) !== "undefined") ? type : this._sortType;
		this._fnSort = fnSort = fnSort || this._fnSort || $.ibi.ibxSelect.statics.sort;
		var children = this.element.find(".ibx-select-item, .ibx-select-group").not(".ibx-select-group-item");
		children.sort(fnSort.bind(this));
		children.each(function (index, el)
		{
			el = $(el);
			this.add(el);
			if (el.hasClass("ibx-select-group"))
			{
				var groupChildren = this.element.find(".ibx-radio-group-" + el.attr("id"));
				groupChildren.sort(fnSort.bind(this));
				this.add(groupChildren, el);
			}
		}.bind(this));
	},
	_fnMatch: null,
	match: function (fnMatch)
	{
		this._fnMatch = fnMatch;
		this._setHighlight();
	},
	_onSelect: function (e)
	{
		var event = (e.originalEvent && e.originalEvent.target) ? e.originalEvent : e;
		var target = (e.originalEvent && e.originalEvent.target) ? e.originalEvent.target : e.target;
		var selItem = $(target).hasClass("ibx-select-item") ? $(target) : $(target).closest(".ibx-select-item");
		if (selItem.length == 0)
			return;

		var bKeepAnchor = false;
		var bSynthetic = false;
		if (this.options.multiSelect && event.shiftKey)
		{
			bKeepAnchor = true;
			// select block - select between current anchor and current item.
			//				- if no current anchor, select from beginning to current item
			var all = this.element.find(".ibx-select-item");
			all.ibxRemoveClass("sel-selected");
			var anchor = this.element.find(".sel-anchor").first();
			if (anchor.length == 0)
				anchor = all.first();
			if (anchor.length == 0)
			{
				this._setSelection(selItem, true, bKeepAnchor);
			}
			else if ($(anchor).is(selItem))
			{
				this._setSelection(selItem, false, false);
			}
			else
			{
				var bAdd = false;
				for (var i = 0; i < all.length; i++)
				{
					var current = $(all[i]);
					if (!bAdd && (current.is(selItem) || current.is(anchor)))
					{
						bAdd = true;
						current.ibxAddClass("sel-selected");
					}
					else
					{
						if (bAdd)
						{
							current.ibxAddClass("sel-selected");
							if (current.is(selItem) || current.is(anchor))
								break;
						}
					}
				}
				this._setSelection(selItem, true, bKeepAnchor);
			}
		}
		else if (this.options.multiSelect && event.ctrlKey)
		{
			// multi select
			if ($(selItem).hasClass("sel-selected"))
				this._removeSelection(selItem, bKeepAnchor);
			else
				this._setSelection(selItem, true, bKeepAnchor);
		}
		else
		{
			// single select
			this._setSelection(selItem, false, false);
		}
	},
	selected: function (element)
	{
		if (typeof (element) == "undefined")
			return this.element.find(".sel-selected");
		else
		{
			$(element).trigger("click");
			return this;
		}
	},
	_setSelection: function (selItem, bKeep, bKeepAnchor, bNoUpdate)
	{
		if (!this._trigger("beforechange", null, {"item": selItem, "action": "select"}))
		{
			/*
			if (selItem.ibxWidget("option", "checked"))
				selItem.ibxWidget("option", "checked", false);
			*/
			return;
		}
		
		var selItem = $(selItem);
		if (selItem.length == 0)
			return;

		if (selItem.hasClass("ibx-select-check-item"))
		{
			if (!bKeep && selItem.hasClass("sel-selected"))
			{
				this._removeSelection(selItem, bKeepAnchor, bNoUpdate);
				return;
			}
			bKeep = true;
		}
		this.element.find(".ibx-select-radio-item,.ibx-select-check-item").each(function (index, el) { $(el).data("ibxWidget").option({"checked": false, "selected": false}); });
		if (!this.options.multiSelect || !bKeep)
		{
			this.element.find(".sel-selected").ibxRemoveClass("sel-selected");
		}
		if (!this.options.multiSelect || !bKeepAnchor)
		{
			this.element.find(".sel-anchor").ibxRemoveClass("sel-anchor");
			if (selItem.length > 0)
			{
				selItem.ibxAddClass("sel-selected sel-anchor");
				selItem.data("ibxWidget").option({"checked": true, "selected": true});
			}
		}
		this.element.find(".sel-selected.ibx-select-check-item, .sel-selected.ibx-select-radio-item").each(function (index, el) { $(el).data("ibxWidget").option({"checked": true, "selected": true}); });
		if (!bNoUpdate)
		{
			this._trigger("change", null, {"item": selItem, "action": "select"});
		}
	},
	_removeSelection: function (selItem, bKeepAnchor, bNoUpdate)
	{
		if (!this._trigger("beforechange", null, {"item": selItem, "action": "remove"}))
		{
			/*
			if (!selItem.ibxWidget("option", "checked"))
				selItem.ibxWidget("option", "checked", true);
			*/
			return;
		}

		var selItem = $(selItem);
		if (selItem.length == 0)
			return;

		selItem.ibxRemoveClass("sel-selected");
		selItem.each(function (index,el){
			$(el).ibxWidget("option", {"checked": false, "selected": false});
		});
		if (!bKeepAnchor)
		{
			this.element.find(".sel-anchor").ibxRemoveClass("sel-anchor");
			selItem.first().ibxAddClass("sel-anchor");
		}
		if (!bNoUpdate)
		{
			this._trigger("change", null, {"item": selItem, "action": "remove"});
		}
	},
	selectHighlight: function ()
	{
		this.element.find(".ibx-select-item-highlight").trigger("click");
	},
	resetHighlight: function ()
	{
		this._resetHighlight();
	},
	_resetHighlight: function ()
	{
		this.element.find(".ibx-select-item").ibxRemoveClass("ibx-select-item-highlight");
		this.element.find(".ibx-select-item").show();
		this.element.find(".ibx-select-group").show();
	},
	setHighlight: function (searchText)
	{
		this._setHighlight(searchText);
	},
	_setHighlight: function (searchText)
	{
		if (searchText)
		{
			var found = false;
			this.element.find(".ibx-select-item").each(function (index, el)
			{
				var itemText = $(el).data("ibxWidget").option("text") + "";
				if (this._fnMatch ? (this._fnMatch(searchText, itemText)) : (0 == itemText.toLowerCase().indexOf(searchText.toLowerCase())))
				{
					if (!found && !this.options.filter)
					{
						$(el).ibxAddClass("ibx-select-item-highlight");
						el.scrollIntoView(false);
					}
					else
						$(el).ibxRemoveClass("ibx-select-item-highlight");
					found = true;
					$(el).show();
				}
				else
				{
					$(el).ibxRemoveClass("ibx-select-item-highlight");
					if (this.options.filter)
						$(el).hide();
				}
			}.bind(this));

			// Hide empty groups when filtering
			if (this.options.filter)
			{
				this.element.find(".ibx-select-group").each(function (index, el)
				{
					if (this.element.find(".ibx-radio-group-" + $(el).attr("id") + ":ibxNavFocusable").length > 0)
						$(el).show();
					else
						$(el).hide();
				}.bind(this));
			}
		}
		else
			this._resetHighlight();
	},
	getText: function ()
	{
		var newText = "";
		var selection = this.element.find(".sel-selected");
		selection.each(function (index, el)
		{
			if (newText)
				newText += ", ";
			newText += $(el).ibxWidget("option", "text") + "";
		}.bind(this));
		return newText;
	},
	userValue: function (value)
	{
		if (typeof (value) == "undefined")
		{
			var selected = this.element.find(".sel-selected");

			if (this.options.multiSelect)
			{
				// return an array of user values
				var ret = [];
				selected.each(function (index, el)
				{
					ret.push($(el).ibxWidget("option", "userValue"));
				}.bind(this));
				return ret;
			}
			else
			{
				return (selected.length == 0 ? null : selected.first().ibxWidget("option", "userValue"));
			}
		}
		else
		{
			this._resetHighlight();
			this._removeSelection(this.element.find(".ibx-select-item"), false, true);

			if (this.options.multiSelect)
			{

				var userValues;
				if (value instanceof Array)
					userValues = value;
				else
				{
					userValues = [];
					userValues.push(value);
				}

				var selItems = [];

				this.element.find(".ibx-select-item").each(function (index, el)
				{
					var itemUserValue = $(el).ibxWidget("option", "userValue");
					for (var i = 0; i < userValues.length; i++)
					{
						if (itemUserValue == userValues[i])
						{
							selItems.push(el);
							break;
						}
					}
				}.bind(this));

				if (selItems.length > 0)
					this.selectItems(selItems);
			}
			else
			{
				if (value instanceof Array)
				{
					if (value.length == 0)
						return this;
					else
						value = value[0];
				}

				this.element.find(".ibx-select-item").each(function (index, el)
				{
					var itemUserValue = $(el).ibxWidget("option", "userValue");
					if (itemUserValue == value)
					{
						this.selectItem(el);
						return false;
					}
				}.bind(this));
			}

			return this;
		}
	},
	focusSelItem: function ()
	{
		var anchor = this.element.find(".ibx-select-item-highlight:ibxNavFocusable").first();
		if (anchor.length == 0)
			anchor = this.element.find(".sel-anchor:ibxNavFocusable").first();
		if (anchor.length == 0)
			anchor = this.element.find(".sel-selected:ibxNavFocusable").first();
		if (anchor.length == 0)
		{
			anchor = this.element.find(".ibx-select-item:ibxNavFocusable").first();
			//this._setSelection(anchor, false, false);
		}
		anchor.focus();
	},
	selectItems: function (elems)
	{
		this._resetHighlight();
		this._removeSelection(this.element.find(".ibx-select-item"), false, true);

		if (this.options.multiSelect)
		{
			if (elems.length > 0)
				this.options.userValue = $(elems[0]).ibxWidget("userValue");
			else
				this.options.userValue = "";
			this._setSelection(elems);
		}
		else
		{
			this.options.userValue = $(elems[0]).ibxWidget("userValue");
			this.selectItem(elems[0]);
		}
	},
	selectItem: function (el)
	{
		this._resetHighlight();
		this.options.userValue = $(el).ibxWidget("userValue");
		this._setSelection(el, false);
	},
	_refresh: function ()
	{
		this._super();
	},
	selectAll: function ()
	{
		this._resetHighlight();
		var items;
		if (this.options.multiSelect)
			items = this.element.find(".ibx-select-item");
		else
			items = this.element.find(".ibx-select-item").first();

		this._setSelection(items, false, false, false);
	},
	removeSelection: function ()
	{
		this._resetHighlight();
		this._removeSelection(this.element.find(".ibx-select-item"), false, false);
		this.options.userValue = "";
	},
});

$.ibi.ibxSelect.statics =
{
	sort: function (a, b)
	{
		var texta = ($(a).ibxWidget("option", "text") + "").toLowerCase();
		var textb = ($(b).ibxWidget("option", "text") + "").toLowerCase();
		if (texta < textb)
			return this._sortType ? -1 : 1;
		else if (texta > textb)
			return this._sortType ? 1 : -1;
		else
			return 0;
	}
};

$.widget("ibi.ibxSelectItem", $.ibi.ibxButtonSimple,
{
	options:
	{
		selected: false,
		userValue: "",
		aria: {
			role: "option"
		}
	},
	_widgetClass: "ibx-select-item",
	_create: function ()
	{
		this.element.attr("tabIndex", -1);
		this._super();
	},
});

$.widget("ibi.ibxSelectCheckItem", $.ibi.ibxCheckBoxSimple,
{
	options:
	{
		selected: false,
		userValue: "",
	},
	_widgetClass: "ibx-select-check-item",
	_create: function ()
	{
		this.element.attr("tabIndex", -1).ibxAddClass("ibx-select-item");
		this._super();
	},
});

$.widget("ibi.ibxSelectRadioItem", $.ibi.ibxRadioButtonSimple,
{
	options:
	{
		selected: false,
		userValue: "",
	},
	_widgetClass: "ibx-select-radio-item",
	_create: function ()
	{
		this.element.attr("tabIndex", -1).ibxAddClass("ibx-select-item");
		this._super();
	},
});

// This should only be used with a simple select, otherwise unexpected results might appear
$.widget("ibi.ibxSelectSeparator", $.ibi.ibxWidget,
{
	options:
	{
		"aria":{"role":"separator", "hidden":true},
	},
	_widgetClass: "ibx-select-separator",
});

$.widget("ibi.ibxSelectGroup", $.ibi.ibxLabel,
{
	options:
	{
		selectCtrl:null,
		userValue: "",
		glyph: "format_list_bulleted",
		glyphClasses: "material-icons",
		justify: "start",
	},
	_widgetClass: "ibx-select-group",
	_create: function ()
	{
		var id = this.element.attr("id");
		if (!id)
			this.element.uniqueId();
		this._super();
	},
	children:function(selector)
	{
		return this.element.parent().children(".ibx-radio-group-" + $(this.element).attr("id"));
	},
	add:function(el, sibling, before)
	{
		el = $(el);
		el.each(function (idx, el)
		{
			el = $(el);
			var children = this.children();
			var after = (children.length == 0) ? this.element : after = children[children.length - 1];
			el.prepend($("<div>").ibxAddClass("ibx-select-group-marker")).ibxAddClass("ibx-select-group-item ibx-radio-group-" + $(this.element).attr("id"));
			el.insertAfter(after);
			if (el.ibxWidget("option", "selected"))
				this.options.selectCtrl.ibxWidget("selectItem", el);
		}.bind(this));
	},
	_refresh: function ()
	{
		this._super();
	}
});

$.widget("ibi.ibxSelectPaged", $.ibi.ibxSelectBase, {
	options:
	{
        "readonly": true,
        "autoHeight": true,
		"autoHeightGap": 100,
		"search": false,
		"selectionControls": false,
		"enablePagingTrigger": 200,
		"pageSize": 10,
		"multiSelect": false,
		/*
        "listClasses": "search-list ibx-menu-no-icons",
        */
	},
	_widgetClass: "ibx-select-paged",
	_create: function ()
	{
		this._super();
	},
	_init: function ()
	{
		this._super();
		this.element.on("ibx_change", this._onChange.bind(this));
	},
	_createControl: function ()
	{
		return $("<div tabindex='0'>").ibxSelectItemListPaged({"search": this.options.search, "selectionControls": this.options.selectionControls, "multiSelect": this.options.multiSelect, "enablePagingTrigger": this.options.enablePagingTrigger, "pageSize": this.options.pageSize});
	},
	_initControl: function ()
	{
		// remove markup children and add them as values
		var children = this.element.find(".ibx-select-item").detach();
		var values = [];
		children.each(function (){
			var obj = {};
			obj.display = $(this).ibxWidget("option", "text");
			obj.value = $(this).ibxWidget("option", "userValue");
			if (!obj.value)
				obj.value = obj.display;
			values.push(obj);
		});
		this.values(values);

        if (this._popup)
        {
            this._popup.on("ibx_close", function (e)
            {
				this._control.ibxWidget("resetSearch", true);
            }.bind(this));
		}
	},
	_setValue: function (value, bFormat, extra)
	{
		this.options.text = bFormat && this.options.fnFormat ? this.options.fnFormat(value) : value;
		this.refresh();
		var data = {"text": this.options.text};
		if (extra)
			$.extend(data, extra);
		this._trigger("change", null, data);
	},
	_onControlChange: function (e, data)
	{
		if (e.target !== this._control[0])
			return;
		this._setValue(this._control.ibxWidget("getText"), true, data);
		if(this.options.popup && !this._control.ibxWidget("option", "multiSelect") && this._popup)
			this._popup.ibxWidget("close");
	},
	_removeSelection: function (item, bKeepAnchor, bNoUpdate)
	{
		var item = $(item);
		if (item.length > 0)
		{
			item.each(function (index, el){
				var obj = $(el).ibxWidget("option", "valObj");
				obj.checked = false;
			});
		}
		this._super(item, bKeepAnchor, bNoUpdate);
	},
	selected: function (element)
	{
		if (typeof (element) == "undefined")
			return this._control.find(".sel-selected");
		else
		{
			$(element).trigger("click");
			return this;
		}
	},
	_onPopupOpen: function ()
	{
		if (!this._dontFocusText)
			this._textInput.focus();
		else
		{
			if (this.options.readonly)
				this._control.ibxWidget("focusSelItem");
		}
		this._dontFocusText = false;
	},
	_onDownArrow: function (e)
	{
		this._super(e);
		if(this.options.popup)
		{
			if (this._popup.ibxWidget("isOpen"))
				this._control.ibxWidget("focusSelItem");
			else
				this._dontFocusText = true;
		}
		else
			this._control.ibxWidget("focusSelItem");
	},
	_onChange: function (e)
	{
		if (e.target !== this.element[0])
			return;
		this.option("text", this._getText());
	},
	_getText: function ()
	{
		var values = this._control.ibxWidget("selected");
		var allValues = this._control.ibxWidget("values");
		var count = allValues.length; 
		var selValues = [];
		values.forEach(function (value){
			selValues.push(value.display ? value.display : value.value);
		});

		var ret = "";
		for (var i = 0; i < selValues.length; i++)
		{
			if (i > 0)
				ret += ", ";
			ret += selValues[i];
		}
		return ret;	
	},
	userValue: function (value)
	{
		this._super(value);
		if (typeof(value) == "undefined")
		{
			var values = this._control.ibxWidget("selected");
			if (this._control.ibxWidget("option", "multiSelect"))
			{
				var ret = [];
				values.forEach(function (val){
					ret.push(val.value);
				});
				return ret;
			}
			else
			{
				if (values.length == 0)
					return null;
				else
					return values[0].value;
				
			}
		}
		else
		{
			var userValues;
			if (value instanceof Array)
				userValues = value;
			else
			{
				userValues = [];
				userValues.push(value);
			}
			this._control.ibxWidget("userValue", userValues);

			var currentValues = this._control.ibxWidget("values");
			currentValues.forEach(function (cv){
				for (var i = 0; i < userValues.length; i++)
				{
					if (cv.value == userValues[i])
						cv.checked = true;
				}
			});
			return this;
		}
	},
	values: function (listValues)
	{
		this._control.ibxWidget("values", listValues);
        window.setTimeout(function (){this.option("text", this._getText());}.bind(this), 100);
	},
	selectItems: function (elems)
	{
		this._control.ibxWidget("selectItems", elems);
		this._updateText();
	},
	selectDefaultOrAll: function (defValue)
	{
		var ret = this._control.ibxWidget("selectDefaultOrAll", defValue);
		if (ret)
			this._updateText();
		return ret;
	},
	_updateText: function ()
	{
		var selection = this._control.find(".sel-selected");
		this.option("text", this._getText());
	},
	inSetPage: function ()
	{
		return this._control.ibxWidget("inSetPage");
	},
	_popupPosition: function (pos, info)
	{
		if (this.options.popup)
		{
			if (this.options.autoHeight)
			{
				var maxHeight = $(window).height() + $(window).scrollTop() - info.target.top - info.target.height - this.options.autoHeightGap;
				if (maxHeight < 100)
				{
					/*
					maxHeight = info.target.top - $(window).scrollTop() - this.options.autoHeightGap;
					if (maxHeight > 100)
					{
						pos.top = info.target.top - maxHeight;
					}
					else
					*/
					maxHeight = 100;
				}
				this._control.ibxWidget("listControl").css("max-height", maxHeight + "px");
			}
			this._control.ibxWidget("listControl").css("min-width", info.target.width + "px");
			this._popup.css(pos);
		}
	},
	_refresh: function ()
	{
		this._super();
		if (this._control)
			this._control.ibxWidget("option", {"search": this.options.search, "selectionControls": this.options.selectionControls, "multiSelect": this.options.multiSelect, "enablePagingTrigger": this.options.enablePagingTrigger, "pageSize": this.options.pageSize});
	},
});

$.widget("ibi.ibxSelectItemListPaged", $.ibi.ibxVBox,
{
	options:
	{
		"multiSelect": false,
		"search": false,
		"selectionControls": false,
		"enablePagingTrigger": 200,
		"pageSize": 10,
		"align": "stretch",
		"focusDefault": true,
	},
	_widgetClass: "ibx-select-item-list-paged",
	_enablePaging: false,
	listControl: function ()
	{
		return this._listControl;
	},
	_create: function ()
	{
		this._super();

		// remove markup children and add them as values
		var children = this.element.find(".ibx-select-item").detach();
		var values = this._values;
		children.each(function (){
			var obj = {};
			obj.display = $(this).ibxWidget("option", "text");
			obj.value = $(this).ibxWidget("option", "userValue");
			if (!obj.value)
				obj.value = obj.display;
			values.push(obj);
		});
		
		this._optionsBox = $("<div class='ibx-page-list-options-box'>").ibxVBox({"align": "stretch"});
		this._searchBoxWrapper = $("<div class='ibx-page-list-search-wrapper'>").ibxHBox({"align": "stretch"});
		this._searchBox = $("<div tabindex='0' class='ibx-page-list-options-search'>").ibxTextField();
		this._searchBoxWrapper.append(this._searchBox);
		this._buttonsBox = $("<div class='ibx-page-list-select-options-buttons'>").ibxHBox();
		this._selectAll = $("<div tabindex='0' class='ibx-page-list-select-options-all'>").ibxButton({"justify": "center", "text": ibx.resourceMgr.getString('IBX_PAGE_LIST_SELECT_ALL')});
		this._clearAll = $("<div tabindex='0' class='ibx-page-list-select-options-none'>").ibxButton({"justify": "center", "text": ibx.resourceMgr.getString('IBX_PAGE_LIST_SELECT_NONE')});
		this._buttonsBox.ibxWidget("add", this._selectAll);
		this._buttonsBox.ibxWidget("add", this._clearAll);
		this._optionsBox.ibxWidget("add", this._searchBoxWrapper);
		this._optionsBox.ibxWidget("add", this._buttonsBox);

		this._listControl = $("<div tabindex='0' class='ibx-select-item-list-paged-inner'>").ibxSelectItemList({"align": "stretch"});
		
		this._searchBox.on("ibx_textchanged", this._onSearch.bind(this));
		this._selectAll.on("click", this._onSelectAll.bind(this));
		this._clearAll.on("click", this._onClearAll.bind(this));

		this._pageBox = $("<div class='ibx-page-list-page-box'>").ibxHBox({"align": "stretch"});
		this._pageLeft = $("<div tabindex='0' class='ibx-page-list-page-box-left'>").ibxButtonSimple({glyphClasses:"fa fa-chevron-left"}).on("click", this._onPageLeft.bind(this));
		this._pageRight = $("<div tabindex='0' class='ibx-page-list-page-box-right'>").ibxButtonSimple({glyphClasses:"fa fa-chevron-right"}).on("click", this._onPageRight.bind(this));
		this._pageLabel = $("<div class='ibx-page-list-page-box-label'>").ibxLabel({"justify": "center"});
		this._pageBox.append(this._pageLeft, this._pageLabel, this._pageRight);

		this.element.append(this._optionsBox, this._listControl, this._pageBox);
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		this._searchBox.attr("title", ibx.resourceMgr.getString("IBX_SELECT_SEARCH_VALUES")).ibxWidget("refresh");
		this._pageLeft.attr("title", ibx.resourceMgr.getString("IBX_SELECT_PAGE_PREV"));
		this._pageRight.attr("title", ibx.resourceMgr.getString("IBX_SELECT_PAGE_NEXT"));
		return aria;
	},
	_init: function ()
	{
		this._super();
		this._listControl.ibxWidget("option", "multiSelect", this.options.multiSelect);
		this._listControl.on("ibx_change", this._onListControlChange.bind(this));
		this._listControl.on("ibx_beforechange", this._onListControlBeforeChange.bind(this));
		this._searchBox.on("ibx_action", this._onSearchAction.bind(this));
		this._searchBox.on("ibx_textchanged", this._onSearchTextChanged.bind(this));
		// add markup items
		if (this._values.length > 0)
			this.values(this._values);
	},
	_refresh: function ()
	{
		this._super();
		if (this.options.search || this.options.selectionControls)
			this._optionsBox.show();
		else
			this._optionsBox.hide();
		if (this.options.search)
			this._searchBoxWrapper.show();
		else
			this._searchBoxWrapper.hide();
		if (this.options.selectionControls)
			this._buttonsBox.show();
		else
			this._buttonsBox.hide();

		if (this._enablePaging)
			this._pageBox.show();
		else
			this._pageBox.hide();
		if (this.options.search || this.options.selectionControls || this._enablePaging)
			this.element.ibxAddClass("paged");
		else
			this.element.ibxRemoveClass("paged");
		var oldMultiSelect = this._listControl.ibxWidget("option", "multiSelect");
		this._listControl.ibxWidget("option", "multiSelect", this.options.multiSelect);
		if (oldMultiSelect != this.options.multiSelect)
			this._setPage();
	},
	focusSelItem: function ()
	{
		this._listControl.ibxWidget("focusSelItem");
	},
	_onSearchTextChanged: function (e)
	{
		this._listControl.ibxWidget("setHighlight", this._searchBox.ibxWidget("option", "text"));
	},
	_onSearchAction: function (e)
	{
		this._listControl.ibxWidget("selectHighlight");
	},
	_onListControlBeforeChange: function (e, data)
	{
		if (e.target !== this._listControl[0] || this._inSetPage)
			return;
		return this._trigger("beforechange", e, data);
	},
	_onListControlChange: function (e, data)
	{
		if (e.target !== this._listControl[0] || this._inSetPage)
			return;

		//if not multiselect, then deselect all items before adjusting selection below.
		if (!this.options.multiSelect)
		{
			this._values.forEach(function (value){
				value.checked = false;
			});
		}

		//adjust the anchor node (that which was clicked on).
		var item = this.element.find(".sel-anchor");
		if (item && item.length == 1)
		{
			var obj = item.ibxWidget("option", "valObj");
			var checked = item.ibxWidget("option", "checked");
			obj.checked = checked;
		}

		//adjust all the checked items
		var items = this.element.find(".checked");
		items.each(function(idx, el)
		{
			var obj = $(el).ibxWidget("option", "valObj");
			obj.checked = true;
		});

		this._trigger("change", e, data);
	},
	getText: function ()
	{
		return this._listControl.ibxWidget("getText");
	},
    resetSearch: function (bForceFirstPage)
    {
        this._resetSearch(bForceFirstPage);
    },
	_resetSearch: function(bForceFirstPage)
	{
		this._searchBox.ibxWidget("option", "text", "");
		if (this._filter)
		{
			this._filter = "";
			this._extractFiltered();
			this._setPage(0);
		}
		else if (bForceFirstPage)
			this._setPage(0);
	},
	_onSearch: function ()
	{
		var text = this._searchBox.ibxWidget("option", "text").toLowerCase();
		if (text != this._filter)
		{
			this._filter = text;
			this._extractFiltered();
			this._setPage(0);
		}
	},
	_onSelectAll: function ()
	{
		this._filteredValues.forEach(function (value){
			value.checked = true;
		});

		var items = this.element.find(".ibx-paged-item");
		items.each(function (index, el){
			el = $(el);
			el.ibxRemoveClass("sel-selected");
			el.ibxWidget("option", "valObj").checked = true;
		});
		this._listControl.ibxWidget("selectAll");
	},
	_onClearAll: function ()
	{
		this._filteredValues.forEach(function (value){
			value.checked = false;
		});
		this._listControl.ibxWidget("removeSelection");
	},
	_onPageLeft: function ()
	{
		if (this._currentPage > 0)
			this._setPage(this._currentPage - 1);
	},
	_onPageRight: function ()
	{
		if (this._currentPage + 1 < this._pageCount())
			this._setPage(this._currentPage + 1);
	},
	add:function(item, sibling, before, refresh)
	{
		this._listControl.ibxWidget("add", item, sibling, before, refresh);
	},
	userValue: function (value)
	{
		return this._listControl.ibxWidget('userValue', value);
	},
	_updatePageLabel: function ()
	{
		
		this._pageLabel.ibxWidget("option", "text", sformat(ibx.resourceMgr.getString('IBX_PAGE_LIST_PAGES'), (this._currentPage + 1), this._pageCount()));
	},
	_setPage: function (pageIndex)
	{
		if (pageIndex === undefined)
			pageIndex = 0;
		
		this._inSetPage = true;
		var options = this.options;
		//options.parent.options.userValue = "";

		if (this._enablePaging)
		{
			if (this._filteredValues.length <= options.pageSize)
				this._pageBox.hide();
			else
				this._pageBox.show();
		}

		this._currentPage = pageIndex;

		this._listControl.empty();
		this._listControl.ibxWidget("option", "userValue", "");

		var pageStart = this._enablePaging ? (options.pageSize * pageIndex) : 0;
		var pageEnd = this._enablePaging ? Math.min(this._filteredValues.length, pageStart + options.pageSize) : this._filteredValues.length;

		var nodes = [];
		for (var i = pageStart; i < pageEnd; ++i)
		{
			var valInfo = this._filteredValues[i];
			var item;
			if (options.multiSelect)
				item = $("<div class='ibx-paged-item'>").ibxSelectCheckItem({"text": valInfo.display ? valInfo.display : valInfo.value, "userValue": valInfo.value, "selected": valInfo.checked });
			else
				item = $("<div class='ibx-paged-item'>").ibxSelectItem({"text": valInfo.display ? valInfo.display : valInfo.value, "userValue": valInfo.value, "selected": valInfo.checked });
			if (valInfo.class)
				item.ibxAddClass(valInfo.class);
			item.ibxWidget("option", "valObj", valInfo);
			nodes.push(item[0]);
		}
		this.add($(nodes));

		this._updatePageLabel();
		this._inSetPage = false;
	},
	/*
		Array of values to display. Each entry is an object with the structure
		{
			"value": "item1", // the value of the item - required
			"display": "Item1", // display value - optional (value will be used if missing)
			"checked": true, // initial state - optional (false by default)
			"class": "css class", // optional class to be added to the created select item
			"data": obj, // optional data attached to the item
		}
	*/
	_values: [],
	_currentPage: 0,
	_filter: "",
	_filteredValues: [],
	_extractFiltered: function ()
	{
		this._filteredValues = [];
		this._values.forEach(function (value){
			if (!this._filter || (value.display ? value.display : value.value).toLowerCase().indexOf(this._filter) >= 0)
				this._filteredValues.push(value);
		}.bind(this));
	},
	_pageCount: function ()
	{
		return Math.ceil(this._filteredValues.length / this.options.pageSize);
	},
	values: function (values)
	{
		if (typeof (values) == "undefined")
			return this._values;
		else
		{
			var options = this.options;
			this._enablePaging = values.length >= this.options.enablePagingTrigger;
			// make a shallow copy of the array
			this._values = values.slice();
			this._extractFiltered();
			this._setPage(0);
			return this;
		}
	},
	selected: function (element)
	{
		if (typeof (element) == "undefined")
		{
			var sel = [];
			this._values.forEach(function (value){
				if (value.checked)
					sel.push(value);
			});
			return sel;
		}
		else
		{
			this.selectItems(element);
			return this;
		}
		
	},
	selectItems: function (elems)
	{
		if (elems instanceof Array)
			elems.forEach(function (el){
				$(el).ibxWidget("option", "valObj").checked = true;
			});
		else
			elems.each(function (index, el){
				$(el).ibxWidget("option", "valObj").checked = true;
		});
		this._listControl.ibxWidget("selectItems", elems);
		
	},
	inSetPage: function ()
	{
		return this._inSetPage;
	},
});

//# sourceURL=select.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/carousel.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.120 $:

/******************************************************************************
Simple Carousel (Kind of a placeholder for when I have more time to do a better one!)
******************************************************************************/
$.widget("ibi.ibxCarousel", $.ibi.ibxVBox, 
{
	options:
	{
		wantResize:true,
		nameRoot:true,
		focusDefault:true,
		align:"stretch",
		allowDragScrolling:true,
		showPageMarkers:true,
		showSinglePageMarker:false,
		pageMarkersPos:"end",
		pageMarkerClass:"ibx-csl-page-marker",
		pageMarkerSelectedClass:"ibx-csl-page-selected",
		pagePrev:"SHIFT+LEFT",
		pageNext:"SHIFT+RIGHT",
		prevNextButtonPos:"ends",	//ends/start/end
		showPrevButton:true,
		showNextButton:true,
		floatButtons:false,
		hideDisabledButtons:false,
		alignChildren:"center",
		sizeToFit:false,	//sizes each child to fit exactly one page.

		scrollType:"integral",													//page/integral/fractional
		scrollTime:{"page":250, "integral":250, "fractional":50, "jump":50},	//time per scroll unit (ms)
		scrollProps://html props to use for calculating scroll position/delta
		{
			"axis":"scrollLeft",
			"size":"offsetWidth",
			"pageSize":"pageWidth",
			"scrollSize":"scrollWidth",
			"fractionalStepSize":25,
			"forward":{"child":"right", "page":"scrollRight"},
			"backward":{"child":"left", "page":"scrollLeft"},
		},

		aria:
		{
			role:"region",
			label: ibx.resourceMgr.getString("IBX_CAROUSEL")
		}
	},
	_widgetClass:"ibx-carousel",
	_create:function()
	{
		this._super();
		var children = this.element.children();
		this._loadWidgetTemplate(".ibx-carousel-template");
		this.add(children);

		this.element.data("ibiIbxCarousel", this).on("ibx_resize", this._onResize.bind(this));
		this._prevBtn.on("click mousedown mouseup mouseleave", this._onPrevNext.bind(this));
		this._nextBtn.on("click mousedown mouseup mouseleave", this._onPrevNext.bind(this));
		this._itemsBox.on("ibx_widgetfocus", this._onItemsBoxFocus.bind(this)).on("keydown", this._onItemsBoxKeyDown.bind(this)).ibxDragScrolling({overflowY:"hidden"}).on("scroll", this._onItemsBoxScroll.bind(this));	
	},
	_setAccessibility:function(accessible, aria)
	{
		this._super(accessible, aria);
		var options = this.options;

		this._itemsBox.ibxWidget("option", "aria", {"role":"list", "label":ibx.resourceMgr.getString("IBX_CAROUSEL_ITEMS")}).ibxWidget("setAccessibility", this.options.aria.accessible);
		this._pageMarkers.ibxWidget("option", "aria", {"role":"radiogroup", "label":ibx.resourceMgr.getString("IBX_CAROUSEL_PAGES")}).ibxWidget("setAccessibility", this.options.aria.accessible);
		return aria;
	},
	_destroy:function()
	{
		this.remove(this.children());
		this._super();
	},
	children:function(selector)
	{
		selector = selector || ".ibx-csl-item";
		return this._itemsBox.ibxWidget("children", selector);
	},
	add:function(el, sibling, before, refresh)
	{
		el = $(el);
		el.ibxAddClass("ibx-csl-item").prop("tabIndex", -1).attr("role", "listitem");
		
		this._itemsBox.ibxWidget("add", el, sibling, before, refresh);
		if(refresh)
			this.refresh();
	},
	remove:function(el, destroy, refresh)
	{
		var children = this.children().filter(el || ".ibx-csl-item").ibxRemoveClass("ibx-csl-item");
		this._itemsBox.ibxWidget("remove", children, destroy, refresh);
		if(refresh)
			this.refresh();
	},
	_onResize:function()
	{
		if(this.options.sizeToFit)
		{
			var options = this.options;
			this._itemsBox.ibxAddClass("ibx-csl-calc-size"); //children must be hidden to correctly determine the items box size
			var pageInfo = this.getPageInfo();
			this._itemsBox.ibxRemoveClass("ibx-csl-calc-size"); //restore the children now that the bounds have been retrieved.
			var children = this.children();
			children.each(function(idx, child)
			{
				child = $(child);
				child.css({"margin":"0px", "width":pageInfo.pageWidth + "px", "height":pageInfo.pageHeight + "px"});
			}.bind(this));
			var curPage = this._pageMarkers.ibxWidget("children", "." + options.pageMarkerSelectedClass).data("ibxPageMarkerInfo");
			curPage = curPage ? curPage.pageNo : 9999;
			this._itemsBox.prop(options.scrollProps.axis, curPage * pageInfo[options.scrollProps.pageSize]);
		}
		this._adjustPageMarkers();
	},
	page:function(pageNo, stepRate, relative)
	{
		var info = this.getPageInfo();
		if(pageNo === undefined)
			return info.curPage;

		var pages = relative ? pageNo : (pageNo - info.curPage);
		this.scroll(pages, "page", this.options.scrollTime.jump);
	},
	_stopScrolling:false,
	scrolling:function(){return this.element.hasClass("ibx-csl-scrolling")},
	scroll:function(steps, scrollType, scrollTime)
	{
		this._itemsBox.clearQueue().stop()
		this._stopScrolling = false;

		var options = this.options;
		var infinite = (steps !== undefined) && !isFinite(steps);
		var forward = (steps >= 0);
		var scrollType = (scrollType !== undefined) ? scrollType : options.scrollType;
		var scrollInfo = 
		{
			"axis": options.scrollProps.axis,
			"forward":forward,
			"scrollType": scrollType,
			"scrollTime": (scrollTime !== undefined) ? scrollTime : this.options.scrollTime[scrollType],
			"steps": (steps !== undefined) ? steps : 1,
			"infinite":infinite,
			"animationProperties":{},
			"animationOptions":{"easing":"linear"}
		};
		scrollInfo.delta = this._calcScrollDelta(scrollInfo.steps, scrollInfo.scrollType);
		scrollInfo.endPos = this._itemsBox.prop(scrollInfo.axis) + scrollInfo.delta;
		scrollInfo.pageInfo = this.getPageInfo();
		scrollInfo.animationProperties[scrollInfo.axis] = scrollInfo.endPos;
		scrollInfo.animationOptions.duration = scrollInfo.scrollTime;

		var evt = this.element.dispatchEvent("ibx_beforescroll", scrollInfo, false, true);
		if(!evt.isDefaultPrevented())
		{
			scrollInfo.animationOptions = $.extend(
			{
				"start":function(scrollInfo, animation)
				{
				}.bind(this, scrollInfo),
				"progress":function(scrollInfo, animation, progress, remainingMs)
				{
					this.element.ibxAddClass("ibx-csl-scrolling")
				}.bind(this, scrollInfo),
				"done":function(scrollInfo, animation, jumpToEnd)
				{
					if(scrollInfo.infinite && !this._stopScrolling)
						this.scroll(scrollInfo.steps, scrollInfo.scrollType, scrollInfo.scrollTime);
					else
					{
						scrollInfo.pageInfo = this.getPageInfo();
						this.element.dispatchEvent("ibx_endscroll", scrollInfo, false, false);
					}
					this.element.ibxRemoveClass("ibx-csl-scrolling");
				}.bind(this, scrollInfo),
			}, evt.data.animationOptions);
			this._itemsBox.animate(scrollInfo.animationProperties, scrollInfo.animationOptions);
		}
	},
	scrollTo:function(el)
	{
		el = this.children().filter(el);
		var options = this.options;
		var pageInfo = this.getPageInfo();
		var metrics = el.metrics();
		var steps = 0;
		
		if(pageInfo.scrollRight < metrics.marginBox.right)
			steps = metrics.marginBox.right - pageInfo.scrollRight; 
		else
		if(pageInfo.scrollLeft > metrics.marginBox.left)
			steps = metrics.marginBox.left - pageInfo.scrollLeft;

		//We need to set the size here because when fractional scrolling is no we want to make the step size
		//bigger (25) so the control scrolls faster.  Here we need an exact 1px step for accuracy.
		var curSize = options.scrollProps.fractionalStepSize;
		options.scrollProps.fractionalStepSize = 1;
		this.scroll(steps, "fractional", options.scrollTime.jump);
		options.scrollProps.fractionalStepSize = curSize; //reset to default fractional size.
	},
	_calcScrollDelta:function(steps, scrollType)
	{
		var options = this.options;
		var delta = 0;
		steps = isFinite(steps) ? steps : (steps >= 0) ? 1 : -1;

		if(scrollType == "fractional")
			delta = steps * options.scrollProps.fractionalStepSize;
		else
		if(scrollType == "page")
			delta =  steps * this._itemsBox.prop(options.scrollProps.size);
		else
		if(scrollType == "integral")
		{
			var forward = (steps >= 0);
			var pageInfo = this.getPageInfo();
			var scrollChild = this.getScrollChild(forward);
			if(scrollChild)
			{
				var props = options.scrollProps[forward ? "forward" : "backward"];
				delta = scrollChild[props.child] - pageInfo[props.page];
			}
		}
		return delta;
	},
	getSelectionManager:function()
	{
		var sm = this._itemsBox.ibxSelectionManager("instance");
		return sm;
	},
	_onItemsBoxScroll:function(e)
	{
		this._adjustPageMarkers();
		var evt = this.element.dispatchEvent("ibx_carouselscroll", this.getPageInfo(), false, true, this._itemsBox); 
	},
	_onItemsBoxFocus:function(e)
	{
		/*COMMENTED OUT FOR NOW BECAUSE IT NEVER QUITE WORKED RIGHT!
		//the idea was that if nothing was focused, then when the items box is focused
		//automatically focus the first item visible in the carousel's viewport.
		//don't do the focusing if selected item is already a child.
		if($(e.target).ibxSelectionManager("active"))
		{
			var oEvent = e.originalEvent.data;
			if(!$.contains(e.target, oEvent.target))
			{
				//if the current active item is not in the viewport, then focus the first child that is.
				var visChildren = this.children(":inViewport()");
				if(!visChildren.filter(".ibx-nav-key-item-active").length)
					visChildren.first().focus();
			}
		}
		*/
	},
	_onItemsBoxKeyDown:function(e)
	{
		var options = this.options;
		if(eventMatchesShortcut(options.pagePrev, e))
			this.page(-1, null, true);
		else
		if(eventMatchesShortcut(options.pageNext, e))
			this.page(1, null, true);
	},
	_onPrevNext:function(e)
	{
		var forward = this._nextBtn.is(e.target) ? true : false;
		if(e.type == "mousedown")
			this.scroll(forward ? Infinity : -Infinity)
		else
		if(e.type == "click" && !this.scrolling())
			this.scroll(forward ? 1 : -1)
		else
		if(e.type == "mouseup" || e.type == "mouseleave")
			this._stopScrolling = true;
	},
	_onPageMarkerKeyEvent:function(e)
	{
		if(e.keyCode == $.ui.keyCode.ENTER || e.keyCode == $.ui.keyCode.SPACE)
			$(e.target).trigger("click");
	},
	_onPageMarkerClick:function(e)
	{
		var markerInfo = $(e.currentTarget).data("ibxPageMarkerInfo");
		this.page(markerInfo.pageNo);
	},
	_adjustPageMarkers:function()
	{
		this._pageMarkers.empty();
		var pageInfo = this.getPageInfo();
		for(var i = 0; i < pageInfo.pages; ++i)
		{
			var isCurPage = (i == pageInfo.curPage);
			var pageMarker = $(sformat("<div class='{1} {2}' tabIndex='-1'>", this.options.pageMarkerClass, isCurPage ? this.options.pageMarkerSelectedClass : ""));
			pageMarker.prop("title", sformat("{1} {2} of {3}", ibx.resourceMgr.getString("IBX_CAROUSEL_PAGE"), i+1, pageInfo.pages));
			pageMarker.data("ibxPageMarkerInfo", {"pageNo":i, "pageInfo":pageInfo}).on("click", this._onPageMarkerClick.bind(this)).on("keyup", this._onPageMarkerKeyEvent.bind(this));

			if(this.options.aria.accessible)
				pageMarker.attr({"role":"radio", "aria-checked": isCurPage})
			this._pageMarkers.append(pageMarker)
		}

		this._pageMarkers.css("visibility", (!this.options.showSinglePageMarker && pageInfo.pages <= 1) ? "hidden" : ""); 

		var options = this.options;
		var disabled = pageInfo[options.scrollProps.axis] <= 0;
		this._prevBtn.ibxWidget("option", "disabled", disabled).ibxToggleClass("csl-btn-hidden", (disabled && options.hideDisabledButtons));

		disabled = (pageInfo[options.scrollProps.axis] + pageInfo[options.scrollProps.pageSize]) >= pageInfo[options.scrollProps.scrollSize];
		this._nextBtn.ibxWidget("option", "disabled", disabled).ibxToggleClass("csl-btn-hidden", (disabled && options.hideDisabledButtons));
	},
	getScrollChild:function(forward) 
	{ 
		 var childBox = null; 
		 var pageInfo = this.getPageInfo(); 
		 var children = this.children(); 
		 for(var i = 0; i < children.length; ++i) 
		 { 
			var child = $(children[i]);
			var box = child.metrics().marginBox; 
			if(box)
			{
				if((forward === true) && (Math.floor(box.right) > pageInfo.scrollRight)) 
					childBox = box; 
				else 
				if((forward === false) && (Math.floor(box.left) >= pageInfo.scrollLeft) && child.prev().length) 
					childBox = child.prev().metrics().marginBox; 

				if(childBox) 
				{
					childBox.child = child[0];
					childBox.nChildren = children.length;
					childBox.idx = i;
					break;
				}
			}
		 } 
		 return childBox; 
	},  
	getPageInfo:function()
	{
		var props = this.options.scrollProps;
		var info = 
		{
			scrollWidth:	this._itemsBox.prop("scrollWidth"),
			scrollHeight:	this._itemsBox.prop("scrollHeight"),
			scrollLeft:		this._itemsBox.prop("scrollLeft"),
			scrollTop:		this._itemsBox.prop("scrollTop"),
			pageWidth:		this._itemsBox.prop("offsetWidth") || 1,
			pageHeight:		this._itemsBox.prop("offsetHeight") || 1,
		};

		info.pageWidth = this._itemsBox.prop("offsetWidth") || 1;
		info.pageHeight = this._itemsBox.prop("offsetHeight") || 1;
		
		info.pages = Math.round(info[props.scrollSize] / info[props.pageSize]) || 1;
		info.curPage = Math.round(info[props.axis] / info[props.pageSize]);
		info.scrollRight = info.scrollLeft + info.pageWidth;
		info.scrollBottom = info.scrollTop + info.pageHeight;
		return info;
	},
	option:function(key, value, refresh)
	{
		this._needsLayout = (key == "prevNextButtonPos" || key == "floatButtons" && value != this.options[key]);
		if(key == "sizeToFit" && !value)
			this.children().css({"margin":"", "width":"", "height":""});
		return this._superApply(arguments);
	},
	_refresh:function()
	{
		this._super();
		var options = this.options;
		
		//set various options for the items box...along with how selections work.
		this._itemsBox.ibxDragScrolling("option", {"disabled":!options.allowDragScrolling, "overflowX":"auto", "overflowY":"hidden"});
		this._itemsBox.ibxWidget("option", "align", options.alignChildren);
		this.getSelectionManager().option("type", options.selType);

		this._prevBtn.css("display", options.showPrevButton ? "" : "none");
		this._nextBtn.css("display", options.showNextButton ? "" : "none");

		//floated buttons force position to either end of the carousel
		this._prevBtn.ibxToggleClass("csl-btn-float", options.floatButtons);	
		this._nextBtn.ibxToggleClass("csl-btn-float", options.floatButtons);	
		if(options.floatButtons)
			options.prevNextButtonPos = "ends";

		if(!this._created || this._needsLayout)
		{
			if(options.prevNextButtonPos == "ends")
				this._itemsContainer.append(this._prevBtn, this._itemsBox, this._nextBtn);
			else
			if(options.prevNextButtonPos == "start")
				this._itemsContainer.append(this._prevBtn, this._nextBtn, this._itemsBox);
			else
			if(options.prevNextButtonPos == "end")
				this._itemsContainer.append(this._itemsBox, this._prevBtn, this._nextBtn);
		}

		//size to fit needs to adjust all elements for the current items box size...it'll adjust the page markers.
		if(options.sizeToFit)
			this._onResize()
		else
			this._adjustPageMarkers();
	
	this._pageMarkers.css("display", options.showPageMarkers ? "" : "none");
		(options.pageMarkersPos == "start")
			? this._pageMarkers.insertBefore(this._itemsContainer)
			: this._pageMarkers.insertAfter(this._itemsContainer);
	}
});
$.widget("ibi.ibxHCarousel", $.ibi.ibxCarousel,{_widgetClass:"ibx-h-carousel"});

$.widget("ibi.ibxVCarousel", $.ibi.ibxCarousel,
{
	options:
	{
		navKeyDir:"vertical",
		direction:"row",
		scrollProps://html props to use for calculating scroll position/delta
		{
			"axis":"scrollTop",
			"size":"offsetHeight",
			"pageSize":"pageHeight",
			"scrollSize":"scrollHeight",
			"fractionalSize":25,
			"forward":{"child":"bottom", "page":"scrollBottom"},
			"backward":{"child":"top", "page":"scrollTop"},
		},
	},
	_widgetClass:"ibx-v-carousel",
	_create:function()
	{
		this._super();
		this._itemsContainer.ibxWidget("option", "direction", "column");
		this._itemsBox.ibxWidget("option", {"navKeyDir":"vertical", "direction":"column"});
		this._pageMarkers.ibxWidget("option", "direction", "column");
		this._prevBtn.ibxWidget("option", {"iconPosition": "top"});
		this._nextBtn.ibxWidget("option", {"iconPosition": "top"});
	},
	getScrollChild:function(forward)
	{
		var childBox = null;
		var pageInfo = this.getPageInfo();
		var children = this.children();
		for(var i = 0; i < children.length; ++i)
		{
			var child = $(children[i]);
			var box = child.metrics().borderBox; 
			if(box)
			{
				if((forward === true) && (Math.floor(box.bottom) > pageInfo.scrollBottom)) 
					childBox = box; 
				else 
				if((forward === false) && (Math.floor(box.top) >= pageInfo.scrollTop) && child.prev().length) 
					childBox = child.prev().metrics().marginBox; 

				if(childBox) 
				{
					childBox.child = child[0];
					childBox.nChildren = children.length;
					childBox.idx = i;
					break;
				}
			}
		}
		return childBox;
	},
	_refresh:function()
	{
		this._super();
		this._itemsBox.ibxDragScrolling("option", {"overflowX":"hidden", "overflowY":"auto"});
	}
});

//# sourceURL=carousel.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/tabs.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.53 $:

/******************************************************************************
	TAB PANE WIDGETS
******************************************************************************/
$.widget("ibi.ibxTabPane", $.ibi.ibxFlexBox,
{
	options:
	{
		focusDefault:true,
		position: "top",
		direction: "column",
		align: "stretch",
		wrap: false,
		inline:true,
		selected: "",
		tabBarOptions:{
			"showPrevButton": false,
			"showNextButton": false,
			"alignChildren": "flex-start",
		},
		aria:{}
	},
	_widgetClass: "ibx-tab-pane",
	_tabBar: null,
	_create: function ()
	{
		this._super();
		this._group = $("<div>").uniqueId().appendTo(this.element);
		this._group.ibxRadioGroup({name:this._group.prop("id")}).on("ibx_change", this._onTabChange.bind(this));
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		return aria;
	},
	_destroy: function ()
	{
		this._removeTabBar();
		this._super();
	},
	_init: function ()
	{
		this._super();
		this._createTabBar();
		this.add(this.element.children(".ibx-tab-page"));
	},
	children:function(selector)
	{
		return this._super(selector || ".ibx-tab-page");
	},
	add:function(el, sibling, before, refresh)
	{
		this._super(el, sibling, before, refresh);

		el = $(el).filter(".ibx-tab-page");
		el.each(function(idx, el)
		{
			el = $(el);
			el.ibxAddClass("tpg-hidden").on("keydown", this._onTabPaneKeyDown.bind(this));
			var button = el.ibxWidget("button");
			var nextPage = el.next(".ibx-tab-page");
			if (nextPage.length > 0)
			{
				nextButton = nextPage.ibxWidget("button");
				if ($.contains(this._tabBar[0], nextButton[0]))
					this._tabBar.ibxWidget("add", button, nextButton, true, true);
				else
					this._tabBar.ibxWidget("add", button, null, null, true);
			}
			else
				this._tabBar.ibxWidget("add", button, null, null, true);
			button.ibxWidget("option", "group", this._group.ibxWidget("option", "name")); //this will add button to radioGroup
		}.bind(this));
		this.refresh();
	},
	remove:function(el, destroy, refresh)
	{
		var selIndex = this.selectedIndex();
		var el = this.children().filter(el);
		el.each(function(idx, el)
		{
			var button = $(el).ibxWidget("button");
			button.css("flex", "").ibxRemoveClass("tpg-hidden").detach();
			button.ibxWidget("option", "group", "");
			this._group.ibxRadioGroup("removeControl", button[0]);
		}.bind(this));
		this._super(el, destroy, refresh);

		// If selected node was removed, select next / previous page, if available
		var newSelIndex = this.selectedIndex();
		if (newSelIndex < 0)
		{
			var pages = this.element.children(".ibx-tab-page");
			if (pages.length > 0 && selIndex >= 0)
			{
				selIndex = Math.max(0, Math.min(selIndex, pages.length -1));
				this.selectedIndex(selIndex);
			}
		}
	},
	_createTabBar: function ()
	{
		var name = "" + this.widgetName + this.uuid;
		switch (this.options.position)
		{
			default:
			case "top":
				this.option("direction", "column");
				this._tabBar = $("<div>").ibxHTabGroup({ "name": name, position: "top"}, this.options.tabBarOptions);
				break;

			case "bottom":
				this.option("direction", "columnReverse");
				this._tabBar = $("<div>").ibxHTabGroup({ "name": name, position: "bottom" }, this.options.tabBarOptions);
				break;

			case "left":
				this.option("direction", "row");
				this._tabBar = $("<div>").ibxVTabGroup({ "name": name, position: "left" }, this.options.tabBarOptions);
				break;

			case "right":
				this.option("direction", "rowReverse");
				this._tabBar = $("<div>").ibxVTabGroup({ "name": name, position: "right" }, this.options.tabBarOptions);
				break;

		}
		this.element.prepend(this._tabBar);
	},
	_removeTabBar: function ()
	{
		this._tabBar.remove();
	},
	tabBar: function ()
	{
		return this._tabBar;
	},
	_onTabPaneKeyDown: function(e)
	{
		if(e.keyCode == $.ui.keyCode.ESCAPE)
			;
	},
	_onTabChange: function (e)
	{
		var curSel = this.options.selected;
		var tabButton = $(e.target).ibxWidget("selected");
		var selected = tabButton.ibxWidget("option", "tabPage");
		selected.ibxWidget("option", "selected", true);
		this.element.children(".ibx-tab-page").not(selected).ibxWidget("option", "selected", false).not(selected).ibxAddClass("tpg-hidden").ibxRemoveClass("tpg-selected");
		selected.ibxRemoveClass("tpg-hidden").ibxAddClass("tpg-selected");
		this.options.selected = selected;
		selected.dispatchEvent("ibx_selected", null, true, false, curSel[0]);
		this._trigger("change", e, selected);
		this._tabBar.ibxWidget("scrollTo", tabButton);
	},
	userValue:function(value)
	{
		return this._group.ibxWidget("userValue", value);
	},
	selectedIndex: function (index)
	{
		if (index === undefined)
		{
			var button = this._group.ibxWidget("selected");
			if (button.length)
				return this.element.children(".ibx-tab-page").index(button.ibxWidget("option", "tabPage"));
			else
				return -1;
		}
		else
		{
			var pages = this.element.children(".ibx-tab-page");
			if (index >= 0 && index < pages.length)
			{
				var button = $(pages[index]).ibxWidget("button");
				this._group.ibxWidget("selected", button);
				this._tabBar.ibxWidget("scrollTo", button);
			}
			return this.element;
		}
	},
	selected: function (element)
	{
		if (element === undefined)
		{
			var button = this._group.ibxWidget("selected");
			if (button.length)
			{
				return button.ibxWidget("option", "tabPage");
			}
			else
				return null;
		}
		else
		{
			element = $(element);
			if (element.length > 0 && element.hasClass("ibx-tab-page"))
			{
				var button = element.ibxWidget("button");
				this._group.ibxWidget("selected", button);
				this._tabBar.ibxWidget("scrollTo", button);
			}
			return this.element;
		}
	},
	_setOption: function (key, value)
	{
		this._super(key, value);
		if(key == "selected")
		{
			if (this.options.selected)
				this.selected(this.options.selected);
		}
		else if (key == "userValue")
		{		
			if (this.options.userValue)
				this.userValue(this.options.userValue);
		}
	},
	_refresh: function ()
	{
		this._super();
		if (this._tabBar)
		{
			switch (this.options.position)
			{
				default:
				case "top":
				case "bottom":
					this._tabBar.ibxHTabGroup(this.options.tabBarOptions);
					break;
	
				case "left":
				case "right":
					this._tabBar.ibxVTabGroup(this.options.tabBarOptions);
					break;
				
			}
		}
	}
});
$.ibi.ibxTabPane.statics =
{
};

/******************************************************************************
	TAB PAGE WIDGETS
******************************************************************************/
$.widget("ibi.ibxTabPage", $.ibi.ibxWidget, 
{
	options:
	{
		selected: false,
		tabOptions:
		{
		},
		aria:{role:"tabpanel"}
	},
	_widgetClass:"ibx-tab-page",
	getValue: $.noop,
	_create: function ()
	{
		this._super();
		var options = this.options;

		//alternate to data-ibxp-text...direct text node children can be used to set the text.
		options.tabOptions.text = options.tabOptions.text || this.element.textNodes().remove().text().replace(/^\s*|\s*$/g, "");
		options.tabOptions.tabPage = this.element;		
		this._tabButton = $("<div class='ibx-tab-button'>").prop("tabIndex", -1).ibxTabButton(options.tabOptions);
		this.element.append(this._tabButton).attr({tabindex:0});
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		this._tabButton.ibxWidget("setAccessibility");
		return aria;
	},
	_destroy:function()
	{
		this._super();
		this._tabButton.ibxWidget("destroy").detach();
	},
	_setOptionDisabled:function(value)
	{
		if(this._tabButton)
			this._tabButton.ibxWidget("option", "disabled", value);
		this._super(value);
	},
	button: function () { return this._tabButton; },
	selected: function (value)
	{
		if (value === undefined)
		{
			return this._tabButton.ibxWidget("checked");
		}
		else
		{
			if (!value)
				throw("Parameter cannot be false");
			this._tabButton.ibxWidget("option", "checked", true);
			return this.element;
		}
	},
	_setOption: function (key, value)
	{
		this._super(key, value);
		if(key == "selected")
		{
			if (this.options.selected)
				this.selected(this.options.selected);
		}
		else if (key == "userValue")
		{		
			if (this.options.userValue)
				this._tabButton.ibxWidget("userValue", this.options.userValue);
		}
	},
	_refresh: function ()
	{
		this._tabButton.ibxWidget("option", this.options.tabOptions).attr("title", this.options.tabOptions.title);
		this._super();
	}
});
$.ibi.ibxTabPage.statics = 
{
};

/******************************************************************************
	TAB BUTTON...just a radio button with some accessibility overrides.
******************************************************************************/
$.widget("ibi.ibxTabButton", $.ibi.ibxRadioButton,
{
	options:
	{
		tabPage:null,
		aria:{role:"tab"}
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		delete aria.checked;

		var tabPage = this.options.tabPage;
		var pageOptions = tabPage.ibxWidget("option");
		aria.expanded = pageOptions.expanded;
		aria.controls = tabPage.prop("id");
		aria.owns = aria.controls;
		aria.selected = pageOptions.selected;
		return aria;
	},
});

/******************************************************************************
	TAB GROUP
******************************************************************************/
$.widget("ibi.ibxHTabGroup", $.ibi.ibxHCarousel,
{
	options:
	{
		position: "top",
		hideDisabledButtons:true,
		showPageMarkers: false,
		aria:
		{
			role:null,
			label:null,
		}
	},
	_widgetClass:"ibx-tab-group",
	_create: function ()
	{
		this._super();
		this.element.ibxAddClass("ibx-tab-group-horizontal").prop("tabindex", -1);
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		this._itemsBox.ibxWidget("setAccessibility", undefined, {"role":"tablist", "label":""});
		//this._itemsBox.ibxWidget("option", "aria", {"role":"tablist", "label":""});
		return aria;
	},
	_refresh: function ()
	{
		this._super();
		this.element.ibxRemoveClass("ibx-tab-position-top ibx-tab-position-bottom");
		switch (this.options.position)
		{
			default:
			case "top":
				this.element.ibxAddClass("ibx-tab-position-top"); break;
			case "bottom":
				this.element.ibxAddClass("ibx-tab-position-bottom"); break;
		}
	}
});

$.widget("ibi.ibxVTabGroup", $.ibi.ibxVCarousel,
{
	options:
	{
		position: "left",
		hideDisabledButtons:true,
		showPageMarkers: false,
		aria:
		{
			role:"null",
			label:null,
		}
	},
	_widgetClass:"ibx-tab-group",
	_create: function ()
	{
		this._super();
		this.element.ibxAddClass("ibx-tab-group-vertical").prop("tabindex", -1);
	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		this._itemsBox.ibxWidget("option", "aria", {"role":"tablist", "label":null});
		return aria;
	},
	_refresh: function ()
	{
		this._super();
		this.element.ibxRemoveClass("ibx-tab-position-left ibx-tab-position-right");
		switch (this.options.position)
		{
			default:
			case "left":
				this.element.ibxAddClass("ibx-tab-position-left"); break;
			case "right":
				this.element.ibxAddClass("ibx-tab-position-right"); break;

		}
	}
});


//# sourceURL=tabs.ibx.js

]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/wizard.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/

$.widget("ibi.ibxWizard", $.ibi.ibxDialog, 
{
	options:
	{
		"type":"std wiz",
		"titlePageSteps":true,
		"captionOptions":
		{
			"text":"ibxWizard"
		},
	},
	_widgetClass:"ibx-wizard",
	_create:function()
	{
		this._super();

		this.btnPrev = $("<div tabindex='0' class='ibx-dialog-button ibx-wizard-back-button'>").ibxButton({text:ibx.resourceMgr.getString("IBX_WIZ_BTN_PREV"), glyphClasses:"material-icons", "glyph":"navigate_before"}).on("click", this.goBack.bind(this));
		this.btnNext = $("<div tabindex='0' class='ibx-dialog-button ibx-wizard-next-button'>").ibxButton({text:ibx.resourceMgr.getString("IBX_WIZ_BTN_NEXT"), glyphClasses:"material-icons", "glyph":"navigate_next", iconPosition:"right"}).on("click", this.goNext.bind(this));
		this.btnFinish = $("<div tabindex='0' class='ibx-dialog-button ibx-wizard-finish-button hidden'>").ibxButton({text:ibx.resourceMgr.getString("IBX_WIZ_BTN_FINISH")}).on("click", this.close.bind(this, "finish"));
		this.btnBox.ibxWidget("remove", ".ibx-dialog-ok-button, .ibx-dialog-apply-button, .ibx-dialog-no-button");
		this.btnBox.ibxWidget("add", [this.btnPrev[0], this.btnNext[0], this.btnFinish[0]], this.btnCancel, true);
		this._tabPane = $("<div class='ibx-wiz-tab-pane'>").ibxTabPane().ibxWidget("instance");
		$.ibi.ibxDialog.prototype.add.call(this, this._tabPane.element);
		var pages = this.element.find(".ibx-wizard-page").detach();
		this.add(pages);
		this.go(0);
	},
	_destroy:function()
	{
		this._super();
	},
	children:function(selector)
	{
		return this._tabPane.children(selector || ".ibx-wizard-page");
	},
	add:function(el, elSibling, before, refresh)
	{
		this._tabPane.add(el, elSibling, before, refresh);
	},
	remove:function(el, destroy, refresh)
	{
		this._tabPane.remove(el, destroy, refresh);
	},
	open:function(page)
	{
		this.go(page || 0);
		this._super();
	},
	allowNext:function(allow)
	{
		this.btnNext.ibxWidget("option", "disabled", !allow);
		this.btnFinish.ibxWidget("option", "disabled", !allow);
	},
	allowPrev:function(allow)
	{
		this.btnPrev.ibxWidget("option", "disabled", !allow);
	},
	goNext:function(e)
	{
		this.go($.ibi.ibxWizard.NEXT)
	},
	goBack:function(e)
	{
		this.go($.ibi.ibxWizard.PREV)
	},
	go:function(where)
	{
		var options = this.options;
		var pages = this.children();

		where = isNaN(where) ? pages.index(where) : where;

		var idx = this._tabPane.selectedIndex();
		var idxNext = idx;
		switch(where)
		{
			case $.ibi.ibxWizard.PREV:
			case $.ibi.ibxWizard.NEXT:
				idxNext += where;
				break;
			case $.ibi.ibxWizard.FIRST:
				idxNext = 0;
				break;
			case $.ibi.ibxWizard.LAST:
				idxNext = pages.length-1;
				break;
			default:
				idxNext = where;
		}

		var info = 
		{
			"pages":pages,
			"idxCur":idx,
			"curPage":pages[idx],
			"idxNext":idxNext,
			"nextPage":pages[idxNext],
			"isFirst":idxNext == 0,
			"isLast":idxNext >= (pages.length-1),
			"allowNext":false,
			"allowPrev":true,
		};
		
		var evt = this.element.dispatchEvent("ibx_beforewizardpagechange", info);
		if(!evt.isDefaultPrevented())
		{
			if(info.nextPage)
			{
				//based on new page, manage dialog state.
				this._tabPane.selected(info.nextPage);
				var pageOptions = $(info.nextPage).ibxWidget("option");

				var title = options.titlePageSteps ? sformat(ibx.resourceMgr.getString("IBX_WIZ_DEF_TITLE"), pageOptions.tabOptions.text, info.idxNext + 1, info.pages.length) : pageOptions.tabOptions.text;
				info.title = title;
				info.curPage = info.nextPage;
				info.idxCur = info.idxNext;
				
				delete info.idxNext;
				delete info.nextPage;

				this.element.dispatchEvent("ibx_wizardpagechange", info, true, false);
				this.title(info.title);

				this.allowNext(info.allowNext);
				this.allowPrev(info.allowPrev);

				this.btnPrev.ibxToggleClass("hidden", info.isFirst);
				this.btnNext.ibxToggleClass("hidden", info.isLast);
				this.btnFinish.ibxToggleClass("hidden", !info.isLast);
			}
		}
	},
	title:function(caption)
	{
		if(caption === undefined)
			return this.options.captionOptions.text;
		this.option("captionOptions.text", caption);
	},
	page:function()
	{
		return this._tabPane.selected();
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		if(key == "selected")
		{
			this._tabPage.option(key, value);
		}
		this._super(key, value);
	},
	_refresh:function()
	{
		this._super();
		var options = this.option;
	}
});
$.ibi.ibxWizard.NEXT = 1;
$.ibi.ibxWizard.PREV = -1;
$.ibi.ibxWizard.FIRST = 0;
$.ibi.ibxWizard.LAST = Infinity;

$.widget("ibi.ibxWizardPage", $.ibi.ibxTabPage,{_widgetClass:"ibx-wizard-page"});

//# sourceURL=wizard.ibx.js]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/datepicker.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.29 $:

$.widget("ibi.ibxDatePicker", $.ibi.ibxVBox,
{
	options:
		{
			"type": "popup", // valid values: "popup", "simple", "inline"
			"autoOpen":true, //show datepicker when focused
			"dateFormat": '', // used as internal formatting
			"outDateFormat": '', // used to format what's shown in the associated label
			"wrap": "false",
			"align": "stretch",
			"showClear": false,
			"pickerClasses": '',
			"date": '',
			"numberOfMonths": 1,
			"initDate": true, // set date to the current date
			"adjustForMonthYear":false
	},
	_widgetClass: "ibx-datepicker",
	_create: function ()
	{
		this.options.dateFormat = this.options.dateFormat || $.ibi.ibxDatePicker.statics.defaultDateFormat;
		this.options.outDateFormat = this.options.outDateFormat || ibx.resourceMgr.getString("IBX_DP_DATE_OUTPUT_FORMAT");
		this.options.date = this.options.date || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
		this._super();
		this.element.on("focus keydown", this._onFocusKeyEvent.bind(this));
		this._input = $('<div class="ibx-datepicker-input">').ibxLabel({glyphClasses:"fa fa-calendar", 'align': 'stretch'}).on('click', this._showPopup.bind(this));
		this._clear = $('<div class="ibx-datepicker-clear">').ibxButtonSimple({glyphClasses:"fa fa-times"}).on('click', this._onClear.bind(this)).hide();
		this._inputWrapper = $('<div>').ibxHBox({align: 'center'}).ibxAddClass('ibx-datepicker-input-wrapper');
		this._inputWrapper.append(this._input, this._clear);
		this._dateWrapper = $('<div>').ibxFlexBox({ 'wrap': false });
		this._datePicker = $('<div tabindex="-1">').datepicker({
			"closeText" : ibx.resourceMgr.getString("IBX_DP_CLOSE_TEXT"),
			"prevText" : ibx.resourceMgr.getString("IBX_DP_PREV_TEXT"),
			"nextText" : ibx.resourceMgr.getString("IBX_DP_NEXT_TEXT"),
			"currentText" : ibx.resourceMgr.getString("IBX_DP_CUR_TEXT"),
			"weekHeader" : ibx.resourceMgr.getString("IBX_DP_WEEK_HEADER"),
			"monthNames" : (eval(ibx.resourceMgr.getString("IBX_DP_MONTHS"))),
			"monthNamesShort" : (eval(ibx.resourceMgr.getString("IBX_DP_MONTHS_SHORT"))),
			"dayNames" : (eval(ibx.resourceMgr.getString("IBX_DP_DAYS"))),
			"dayNamesShort" : (eval(ibx.resourceMgr.getString("IBX_DP_DAYS_SHORT"))),
			"dayNamesMin" : (eval(ibx.resourceMgr.getString("IBX_DP_DAYS_MIN"))),
			"buttonText" : ibx.resourceMgr.getString("IBX_DP_BUTTON_TEXT"),
			"onSelect": this._onSelect.bind(this),
			"onChangeMonthYear": this._onChangeMonthYear.bind(this)
		});

		//Need this because teh datepicker is not accessible by default...only uses anchors...and the selection manager won't tab/move between them by default.
		this._datePicker.ibxSelectionManager({type:"single", navKeyRoot:true, focusDefault:".ui-datepicker-current-day", focusResetOnBlur:false}).on("ibx_selectablechildren", function(e)
		{
			var dp = $(e.target);
			e.originalEvent.data.items = dp.find("a").attr("tabindex", 0);
		});

		//setup the strings.
		this._pickerOptions = {
			"closeText" : ibx.resourceMgr.getString("IBX_DP_CLOSE_TEXT"),
			"prevText" : ibx.resourceMgr.getString("IBX_DP_PREV_TEXT"),
			"nextText" : ibx.resourceMgr.getString("IBX_DP_NEXT_TEXT"),
			"currentText" : ibx.resourceMgr.getString("IBX_DP_CUR_TEXT"),
			"weekHeader" : ibx.resourceMgr.getString("IBX_DP_WEEK_HEADER"),
			"monthNames" : (eval(ibx.resourceMgr.getString("IBX_DP_MONTHS"))),
			"monthNamesShort" : (eval(ibx.resourceMgr.getString("IBX_DP_MONTHS_SHORT"))),
			"dayNames" : (eval(ibx.resourceMgr.getString("IBX_DP_DAYS"))),
			"dayNamesShort" : (eval(ibx.resourceMgr.getString("IBX_DP_DAYS_SHORT"))),
			"dayNamesMin" : (eval(ibx.resourceMgr.getString("IBX_DP_DAYS_MIN"))),
			"buttonText" : ibx.resourceMgr.getString("IBX_DP_BUTTON_TEXT")};
		this._dateWrapper.append(this._datePicker).ibxAddClass('ibx-datepicker-date-wrapper');
		this.element.append(this._inputWrapper, this._dateWrapper);
		this._popup = $('<div class="ibx-datepicker-popup">').ibxPopup({'focusDefault':true, 'focusRoot':true, 'destroyOnClose': false});
	},
	_init: function ()
	{
		this._super();
	},
	_destroy: function ()
	{
		this._super();
	},
	_onClear: function ()
	{
		this.options.date = '';
		this._datePicker.datepicker('setDate', '');
		this._input.ibxWidget('option', 'text', '');
		this._trigger("change", null, { 'date': '' });
	},
	_onSelect: function (dateText, inst)
	{
		switch (this.options.type)
		{
			case 'popup':
				if (this._popup.ibxWidget('isOpen'))
					this._popup.ibxWidget('close');
				break;
			default:
				break;
		}
		var value = $.datepicker.formatDate(this.options.dateFormat, this._datePicker.datepicker('getDate'));
		this.options.date = value;
		this._trigger("change", null, { 'date': value });
		this._input.ibxWidget('option', 'text', $.datepicker.formatDate(this.options.outDateFormat, this._datePicker.datepicker('getDate'), this._pickerOptions));
	},
	_onChangeMonthYear:function(year, month, picker)
	{
		if(this._inChange)
			return;
		this._inChange = true;

		//this._datePicker.find("a").attr("tabindex", 0);

		var curDate = this._datePicker.datepicker('getDate');
		var newDate = curDate;
		newDate.setMonth(month-1);
		newDate.setYear(year);
		var data = { 'curDate': curDate, "newDate":$.datepicker.formatDate(this.options.dateFormat,newDate), "newYear":year, "newMonth":month };
		var defaultPrevented = !this._trigger("changemonthyear", null, data);
		if(!defaultPrevented && this.options.adjustForMonthYear)
			this.option("date", data.newDate);
		this._inChange = false;
	},
	_onFocusKeyEvent:function(e)
	{
		if(this.options.autoOpen)
			this._showPopup();
		else
		if(e.type == "keydown" && (e.keyCode == $.ui.keyCode.DOWN || e.keyCode == $.ui.keyCode.ENTER || e.keyCode == $.ui.keyCode.SPACE))
			this._showPopup();
	},
	_showPopup: function ()
	{
		switch (this.options.type)
		{
			case 'popup':
				if (!this._popup.ibxWidget('isOpen'))
					this._popup.ibxWidget('open');//.find("a").attr("tabindex", 0);
				break;
			default:
				break;
		}
	},
	_refresh: function ()
	{
		this.element.ibxRemoveClass('popup simple inline');
		if (this.options.showClear)
			this._clear.show();
		else
			this._clear.hide();
		if (this.options.pickerClasses)
			this._popup.ibxAddClass(this.options.pickerClasses);
		this._datePicker.datepicker('option', this.options);
		var dateObj = $.datepicker.parseDate(this.options.dateFormat, this.options.date) || new Date();
		this._datePicker.datepicker('setDate', dateObj);
		this._input.ibxWidget('option', 'text', $.datepicker.formatDate(this.options.outDateFormat, this._datePicker.datepicker('getDate'), this._pickerOptions));
		this._super();

		//[IBX-434] don't see why we close the popup on the refresh...take out and see what happens!
		//if (this._popup.ibxWidget('isOpen'))
		//	this._popup.ibxWidget('close');


		switch (this.options.type)
		{
			default:
			case 'popup':
				this.element.ibxAddClass('popup');
				this._inputWrapper.show();
				this._popup.ibxWidget('option', 'position', { "my": "left top", "at": "left bottom+5px", "of": this._input, "collision": "fit" });
				this._popup.append(this._dateWrapper);
				break;
			case 'simple':
				this.element.ibxAddClass('simple');
				this._inputWrapper.show();
				this.element.append(this._dateWrapper);
				break;
			case 'inline':
				this.element.ibxAddClass('inline');
				this._inputWrapper.hide();
				this.element.append(this._dateWrapper);
				break;
		}
	}
});

$.ibi.ibxDatePicker.statics =
{
	defaultDateFormat: "MM d, yy"
};


$.widget("ibi.ibxDatePickerSimple", $.ibi.ibxDatePicker, { options: { type: "simple" } });
$.widget("ibi.ibxDatePickerInline", $.ibi.ibxDatePicker, { options: { type: "inline" } });

$.widget("ibi.ibxDateRange", $.ibi.ibxDatePicker,
{
	options:
	{
		"dateTo": '',
		"dateFrom": '',
		"numberOfMonths": 2,
		"singleInput": false,
	},
	_create: function ()
	{
		this.options.dateTo = this.options.dateTo || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
		this.options.dateFrom = this.options.dateFrom || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
		this._super();

		this._input2 = $('<div class="ibx-datepicker-input">').ibxLabel({ glyphClasses: "fa fa-calendar", 'align': 'stretch' }).on('click', this._showPopup.bind(this));
		this._clear2 = $('<div class="ibx-datepicker-clear">').ibxButtonSimple({glyphClasses:"fa fa-times"}).on('click', this._onClear2.bind(this)).hide();
		this._inputWrapper.append(this._input2, this._clear2);
		this._datePicker.datepicker('option', 'onChangeMonthYear', this._onChangeMonthYear.bind(this));
		window.setTimeout(function () { this._highlightRange(); }.bind(this), 10);
	},
	_init: function ()
	{
		this._super();
		if (this.options.singleInput)
		{
			this._input2.remove();
			this._clear2.remove();
		}
	},
	_onChangeMonthYear: function (year, month, inst)
	{
		window.setTimeout(function () { this._highlightRange(); }.bind(this), 10);
	},
	_onClear: function ()
	{
		this.options.dateFrom  = '';
		if (this.options.singleInput)
			this.options.dateTo = '';
		this._datePicker.datepicker('setDate', '');
		this._trigger("change", null, { 'dateFrom': '', 'dateTo': this.options.dateTo});
		this._input.ibxWidget('option', 'text', '');
	},
	_onClear2: function ()
	{
		this.options.dateTo  = '';
		this._datePicker.datepicker('setDate', '');
		this._trigger("change", null, { 'dateFrom': this.options.dateFrom, 'dateTo': ''});
		this._input2.ibxWidget('option', 'text', '');
	},
	_onSelect: function (dateText, inst)
	{
		//var value = $.datepicker.formatDate(this.options.dateFormat, this._datePicker.datepicker('getDate'));
		var value = this._datePicker.datepicker('getDate');
		var v = value.getTime();

		var from;
		var parseFrom = $.datepicker.parseDate(this.options.dateFormat, this.options.dateFrom);
		if (!parseFrom)
			from = (new Date()).getTime();
		else
			from = parseFrom.getTime();

		var to;
		var parseTo = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo);
		if (!parseTo)
			to = from;
		else
			to = parseTo.getTime();

		if (v <= from)
		{
			// extend from
			this.options.dateFrom = $.datepicker.formatDate(this.options.dateFormat, value);
		}
		else if (v >= to)
		{
			// extend to
			this.options.dateTo = $.datepicker.formatDate(this.options.dateFormat, value);
		}
		else
		{
			// in between - reset
			this.options.dateFrom = $.datepicker.formatDate(this.options.dateFormat, value);
			this.options.dateTo = '';
		}

		this._trigger("change", null, { 'dateFrom': this.options.dateFrom, 'dateTo': this.options.dateTo});

		//this._datePicker.datepicker('setDate', new Date(this.options.dateTo));

		if (this.options.singleInput)
		{
			var fromText = '';
			var toText = '';
			if (this.options.dateFrom)
			{
				var parseFrom = $.datepicker.parseDate(this.options.dateFormat, this.options.dateFrom) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				fromText = $.datepicker.formatDate(this.options.outDateFormat, parseFrom, this._pickerOptions);
			}
			if (this.options.dateTo)
			{
				var parseTo = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				toText = $.datepicker.formatDate(this.options.outDateFormat, parseTo, this._pickerOptions);
			}
			this._input.ibxWidget('option', 'text', (fromText || toText) ? (fromText + ' - ' + toText) : '');
		}
		else
		{
			if (this.options.dateFrom)
			{
				var parseFrom = $.datepicker.parseDate(this.options.dateFormat, this.options.dateFrom) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				this._input.ibxWidget('option', 'text', $.datepicker.formatDate(this.options.outDateFormat, parseFrom, this._pickerOptions));
			}
			else
				this._input.ibxWidget('option', 'text', '');
			if (this.options.dateTo)
			{
				var parseTo = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				this._input2.ibxWidget('option', 'text', $.datepicker.formatDate(this.options.outDateFormat, parseTo, this._pickerOptions));
			}
			else
				this._input2.ibxWidget('option', 'text', '');
		}

		window.setTimeout(function () { this._highlightRange(); }.bind(this), 10);
	},
	_highlightRange: function ()
	{
		var parseFrom = $.datepicker.parseDate(this.options.dateFormat, this.options.dateFrom);
		var parseTo = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo);
		if (!parseFrom || !parseTo)
			return;

		var dateFrom = parseFrom.getTime();
		var dateTo = parseTo.getTime();

		this._datePicker.find('td[data-handler="selectDay"]').each(function (index, el)
		{
			var el = $(el);
			var month = parseInt(el.attr('data-month'),10);
			var year = parseInt(el.attr('data-year'),10);
			var day = parseInt(el.children('a').text(), 10);

			var current = (new Date(year, month, day)).getTime();
			if (current >= dateFrom && current <= dateTo)
				el.attr('data-range', "true");
			else
				el.attr('data-range', "");
			if (current == dateFrom)
				el.attr('data-range-from', "true");
			else
				el.attr('data-range-from', '');
			if (current == dateTo)
				el.attr('data-range-to', "true");
			else
				el.attr('data-range-to', '');
		});
	},
	_refresh: function ()
	{
		this.options.date = this.options.dateTo;
		this._super();
		if (!this.options.singleInput)
		{
			if (this.options.showClear)
				this._clear2.show();
			else
				this._clear2.hide();
		}

		var toDateObj = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo) || new Date();
		this._datePicker.datepicker('setDate', toDateObj);
		if (this.options.singleInput)
		{
			var fromText = '';
			var toText = '';
			if (this.options.dateFrom)
			{
				var parseFrom = $.datepicker.parseDate(this.options.dateFormat, this.options.dateFrom) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				fromText = $.datepicker.formatDate(this.options.outDateFormat, parseFrom, this._pickerOptions);
			}
			if (this.options.dateTo)
			{
				var parseTo = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				toText = $.datepicker.formatDate(this.options.outDateFormat, parseTo, this._pickerOptions);
			}

			this._input.ibxWidget('option', 'text', (fromText || toText) ? (fromText + ' - ' + toText) : '');
		}
		else
		{
			if (this.options.dateFrom)
			{
				var parseFrom = $.datepicker.parseDate(this.options.dateFormat, this.options.dateFrom) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				this._input.ibxWidget('option', 'text', $.datepicker.formatDate(this.options.outDateFormat, parseFrom, this._pickerOptions));
			}
			else
				this._input.ibxWidget('option', 'text', '');
			if (this.options.dateTo)
			{
				var parseTo = $.datepicker.parseDate(this.options.dateFormat, this.options.dateTo) || $.datepicker.formatDate($.ibi.ibxDatePicker.statics.defaultDateFormat, new Date());
				this._input2.ibxWidget('option', 'text', $.datepicker.formatDate(this.options.outDateFormat, parseTo, this._pickerOptions));
			}
			else
				this._input2.ibxWidget('option', 'text', '');
		}
		window.setTimeout(function () { this._highlightRange(); }.bind(this), 10);
	}
});

$.widget("ibi.ibxDateRangeSimple", $.ibi.ibxDateRange, { options: { type: "simple" } });
$.widget("ibi.ibxDateRangeInline", $.ibi.ibxDateRange, { options: { type: "inline" } });


//# sourceURL=datepicker.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/colorpicker.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.26 $:

$.widget("ibi.ibxColorPicker", $.ibi.ibxVBox,
{
	options:
	{
		"style":"wheel",
		"color":"",
		"colorRgba":"",
		"opacity":1,
		"setOpacity":true,
		"showColorInfo":true,
		"align":"center",
		"inline":true,
		"focusDefault":true,
	},
	_widgetClass: "ibx-color-picker",
	_create: function ()
	{
		this._super();
		var options = this.options;
		var infoBox = this._infoBox = $("<div class='cp-info-box'>").ibxHBox({"align":"stretch", "justify":"center"});
		var swatch = this._swatch = $("<div class='cp-swatch'>");
		var value = this._textValue = $("<div tabindex='0' class='cp-text-value'>").ibxTextField().on("ibx_change", this._onTextChanged.bind(this));
		var ctrl = this._ctrl = $("<div class='cp-mixer'>");
					
		infoBox.append(swatch, value);
		this.element.append(infoBox, ctrl);
		
		var swatches = [];
		/*
		var palDefault = ibx.resourceMgr.getXmlResource(".ibx-palette-picker-default-palettes", false);
		var colors = palDefault.find("[pid='default_basic'] > color");
		colors.sort(fnAttrSort.bind(colors, "idx", "numeric", false));
		$.each(colors, function(idx, el)
		{
			el = $(el);
			var swatch = {"name":el.attr("display-name"), "color":el.attr("value")};
			swatches.push(swatch);
		}.bind(this));
		*/

		//must be initialized after being added to dom.
		ctrl.minicolors({"control":options.style, "opacity":options.setOpacity, "swatches":swatches, "inline":true, "change": this._onColorChange.bind(this)});
		ctrl.minicolors("value", options.color);

	},
	_setAccessibility:function(accessible, aria)
	{
		aria = this._super(accessible, aria);
		this._textValue.ibxWidget("setAccessibility", undefined, {label: ibx.resourceMgr.getString("IBX_COLOR_PICKER_VALUE_LABEL") + this.options.color});
		return aria;
	},
	_destroy: function ()
	{
		this._super();
		this._infoBox.remove();
		this._swatch.remove();
		this._ctrl.remove();
	},
	control:function(){return this._ctrl;},
	_onColorChange:function(value, opacity)
	{
		if(this._inSetOptions)
			return;
		var options = this.options;
		var options = 
		{
			color:value,
			opacity:(options.setOpacity && !isNaN(opacity)) ? parseFloat(opacity) : 1,
			colorRgba:hexToRgba(value, options.opacity),
		};
		this.option(options);
		return;
	},
	_onTextChanged:function(e, info)
	{
		if(this._inSetOptions)
			return;
		this.option("color", info.text);
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = this.options[key] != value;
		if(!changed || this._inSetOptions)
			return;

		this._inSetOptions = true;
		if(key == "color")
		{
			value = value.toLowerCase();
			if(value.search(/^rgb\(/i) == 0)
				value = rgbToHex(value);
			else
			if(value[0] != "#")
				value = "#" + value;

			var rx = new RegExp("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");
			if(rx.test(value))
			{
				options.colorRgba = hexToRgba(value, options.opacity);
				this._ctrl.minicolors("value", {"color":options.colorRgba.rgba, "opacity":options.opacity});
			}
			else
				value = options.color;
		}
		else
		if(key == "opacity")
			this._ctrl.minicolors("value", {"color":options.color, "opacity":value});
		else
		if(key == "style")
			this._ctrl.minicolors("settings", {"control": value});
		else
		if(key == "setOpacity")
			this._ctrl.minicolors("settings", {"opacity": value});
		this._super(key, value);
		this.element.dispatchEvent("ibx_colorchange", {"color":options.color, "rgba": options.colorRgba, "opacity":options.opacity}, false, false);
		this._inSetOptions = false;
	},
	_refresh: function ()
	{
		this._super();
		var options = this.options;
		this._infoBox.css("display", options.showColorInfo ? "" : "none");
		this._swatch.css("backgroundColor", hexToRgba(options.color, options.opacity).rgba);
		this._textValue.ibxWidget("value", options.color);
	}
});

$.widget("ibi.ibxPalettePicker", $.ibi.ibxVBox,
{
	options:
	{
		"palette":"",
		"color":"",
		"colorRgba":"",
		"opacity":1,
		"showPalettes":true,
		"showPalette":true,
		"showCustom":true,
		"showTransparency":true,
		"showNoFill":true,
		"sliderOptions":{},
		"navKeyRoot":true,
		"navKeyDir":"both",
		"nameRoot":true,
		"focusDefault":true,
		"justify":"center",
		"align":"stretch",
		"selType":"single",
	},
	_widgetClass: "ibx-palette-picker",
	_create: function ()
	{
		this._super();
		this._loadWidgetTemplate(".ibx-palette-picker-template");
		this.element.on("ibx_selchange", this._selManagerEvent.bind(this));
		this._palSelect.on("ibx_change", this._onPalSelectChange.bind(this));
		this._transSlider.on("ibx_change", this._onTransSliderChange.bind(this)).ibxWidget("option", "fnFormat", this._formatSliderVals.bind(this));

		var palDefault = ibx.resourceMgr.getXmlResource(".ibx-palette-picker-default-palettes", false);
		this.paletteFile(palDefault, "default_basic");
	},
	_destroy: function ()
	{
		this._super();
	},
	_init:function()
	{
		this._inInit = true;
		this._super();
		this.element.ibxSelectionManager("option", "selectableChildren", ".pp-swatch");//IBX-390
		this._inInit = false;
	},
	_selManagerEvent:function(e)
	{
		var info = e.originalEvent.data;
		if(e.type == "ibx_selchange" && info.selected == true)
		{
			var swatch = $(info.items[0]);
			var dataVal = "ppHexValue";
			if(swatch.is(".pp-no-fill"))
				dataVal = "ppRgbValue";
			//this.option("color", swatch.data(dataVal))
			//this.option("opacity", swatch.data("ppOpacity"));
			this.option({"color":swatch.data(dataVal), "opacity":swatch.data("ppOpacity")});
		}
	},
	_formatSliderVals:function(fmt, info)
	{
		return info[fmt] + "%";
	},
	_onTransSliderChange:function(e, info)
	{
		this._inSliderChange = true;
		this.option("opacity", (info.value/100));
		this._inSliderChange = false;
		e.stopPropagation();
	},
	_onPalSelectChange:function(e)
	{
		var pid = $(e.target).ibxWidget("userValue");
		this._inSelectChange = true;
		this.option("palette", pid);
		this._inSelectChange = false;
		e.stopPropagation();
	},
	_palFile:null,
	paletteFile:function(palFile, palette)
	{
		if(palFile === undefined)
			return this._palFile[0];

		this._palFile = $(palFile);
		var pals = this._palFile.find("palette");
		this._palSelect.ibxWidget("removeControlItem");
		pals.each(function(idx, pal)
		{
			pal = $(pal);
			var pid = pal.attr("pid");
			var selItem = $("<div>").ibxSelectItem({"text":pal.attr("display-name"), "userValue": pal.attr("pid")});
			this._palSelect.ibxWidget("addControlItem", selItem);
		}.bind(this));
		this._palSelect.ibxWidget("userValue", palette || this.options.palette);
	},
	_setOption:function(key, value)
	{
		var options = this.options;
		var changed = options[key] != value;

		if(key == "palette" && changed)
		{
			if(!this._inSelectChange)
				this._palSelect.ibxWidget("userValue", value);
			else
			{
				var pal = this._palFile.find(sformat("palette[pid={1}]", value));
				var colors = pal.children("color");
				this._swatchBox.ibxWidget("remove");
				colors.sort(fnAttrSort.bind(this, "idx", "numeric", false)).each(function(idx, color)
				{
					var value = color.getAttribute("value").toLowerCase();
					var opacity = ibx.coercePropVal(color.getAttribute("opacity"));
					var displayName = color.getAttribute("display-name") || value;
					var swatch = $(sformat("<div tabindex='0' class='pp-swatch' title='{1}' data-pp-hex-value='{2}' data-pp-opacity='{3}'>", displayName, value, opacity));
					swatch.css("backgroundColor", value).attr("data-pp-rgb-value", swatch.css("backgroundColor"));
					this._swatchBox.append(swatch);
				}.bind(this));

				var colors = pal.find("custom_colors > color");
				this._customBox.ibxWidget("remove");
				colors.sort(fnAttrSort.bind(this, "idx", "numeric", false)).each(function(idx, color)
				{
					var value = color.getAttribute("value").toLowerCase();
					var opacity = ibx.coercePropVal(color.getAttribute("opacity"));
					var displayName = color.getAttribute("display-name") || value;
					var swatch = $(sformat("<div tabindex='0' class='pp-swatch pp-swatch-custom' title='{1}' data-pp-hex-value='{1}' data-pp-opacity='{3}'>", displayName, value, opacity));
					swatch.css("backgroundColor", value).attr("data-pp-rgb-value", swatch.css("backgroundColor"));
					this._customBox.append(swatch);
				}.bind(this));

				this.refresh();
			}
		}
		else
		if(key == "opacity" && changed)
		{
			if(!this._inSliderChange)
				this._transSlider.ibxWidget("option", "value", Math.min(value * 100, 100));
			options.colorRgba = hexToRgba(options.color, value);
		}
		else
		if(key == "color" && changed)
		{
			value = value.toLowerCase();
			if(value.search(/^rgb\(/i) == 0)
				value = rgbToHex(value);
			options.colorRgba = hexToRgba(value, options.opacity);
		}
		else
		if((key == "colorRgba") && !this._inInit)
		{
			console.warn("[ibx Warning] ibxPalettePicker.option.rgbColor is readonly.");
			return;
		}

		this._super(key, value);
		if(changed && (key == "color" || key == "opacity"))
			this.element.dispatchEvent("ibx_change", {"color":options.color, "rgba": options.colorRgba, "opacity":options.opacity}, false, false);
	},
	_refresh: function ()
	{
		this._super();
		var options = this.options;

		this._palSelect.css("display", options.showPalettes ? "" : "none");
		this._swatchBox.css("display", options.showPalette ? "" : "none");
		this._customLabel.css("display", options.showCustom ? "" : "none");
		this._customBox.css("display", options.showCustom ? "" : "none");
		this._noFillBox.css("display", options.showNoFill ? "" : "none");
		this._transparencyBox.css("display", options.showTransparency ? "" : "none");
		this._transSlider.ibxWidget("option", options.sliderOptions);

		var swatch = this.element.find(sformat("[data-pp-hex-value='{1}']", options.color));
		if(!this.element.ibxSelectionManager("isSelected", swatch[0]))
			this.element.ibxSelectionManager("option", "toggleSelection", false).ibxSelectionManager("selected", swatch, true);
	}
});
//# sourceURL=colorpicker.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/diagram.ibx.js"><![CDATA[/*global window: false, document: false, Element: false, jQuery: false, $: false */
/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.11 $:

// TODO: dispatch more events
// TODO: promote connection lines to widgets
$.widget('ibi.ibxDiagram', $.ibi.ibxWidget, {
	_widgetClass: 'ibx-diagram',
	options: {
		selectMode: 'fit',  // One of 'fit' or 'touch'
		grid: {
			size: null,  // Either null (disable grid) or a number.  If a number, snap each node to a grid with intervals this large (in px).
			offset: {left: 0, top: 0}  // If grid.size is set, start grid this far from the top left corner of the diagram container
		}
	},
	_create: function() {
		this._super();
		this._connections = [];
		var w = this.element[0].clientWidth;
		var h = this.element[0].clientHeight;
		this._svgContainer = $('<svg xmlns="http://www.w3.org/2000/svg" class="ibx-diagram-svg-container" width="' + w + '" height="' + h + '"></svg>');
		this._nodeContainer = $('<div class="ibx-diagram-node-container">');
		this.children().each((function(idx, child) {
			this.add(child);
		}).bind(this));
		this.element.append(this._svgContainer);
		this.element.append(this._nodeContainer);
	},
	_destroy: function() {
		this._super();
	},
	_refresh: function() {
		this._super();

		this._svgContainer.attr('width', this.element[0].clientWidth);
		this._svgContainer.attr('height', this.element[0].clientHeight);

		this.element.click((function() {
			this.clearSelectedNodes();
			this.triggerSelectionChange();
		}).bind(this));

		if (this.options.grid.size == null) {
			this._nodeContainer.children().each(function(idx, child) {
				$(child).draggable({grid: false});
			});
		} else {
			var gridSize = this.options.grid.size;
			this._nodeContainer.children().each(function(idx, child) {
				child = $(child).ibxDiagramNode('instance');
				child.lockToGrid();
				child.element.draggable({grid: [gridSize, gridSize]});
			});
		}
		this.updateConnections();
	},
	convertToNode: function(node) {  // Convert any variation of a 'node' into an ibxDiagramNode instance
		if (node && node.widgetName === 'ibxDiagramNode') {  // TODO: clean this up - cascade isn't clear
			return node;  // Node is already an ibxDiagramNode
		} else if (node instanceof Element) {
			node = $(node);  // Assume node is a fully formed DOM node representing a diagram node
		} else if (!(node instanceof jQuery)) {
			node = $('<div>').ibxDiagramNode(node);  // Assume 'node' is an ibxDiagramNode options object like {left, right, className, ...}.  Create a DOM node for it.
		}
		var res = node.ibxDiagramNode('instance');
		if (res) {
			return res;
		}
		return node.ibxDiagramNode().ibxDiagramNode('instance');
	},
	add: function(el, elSibling, before, refresh) {
		var classList = el.customClassList;
		var node = this.convertToNode(el);
		if (!node) {
			return null;
		}

		elSibling = $(elSibling);
		if (elSibling.length) {
			node.element[before ? 'insertBefore' : 'insertAfter'](elSibling);
		} else {
			this._nodeContainer[before ? 'prepend' : 'append'](node.element);
		}

		node.diagram = this;
		node.init();

		if (classList) {
			node.element.ibxAddClass(classList.join(' '));
		}
		if (refresh) {
			this.refresh();
		}
		return node;
	},
	remove: function(el, destroy, refresh) {
		var ret;
		if (el == null) {  // no arguments mean remove everything
			this._nodeContainer.children().each((function(idx, child) {
				this.remove(child);
			}).bind(this));
		} else {
			var node = this.convertToNode(el);
			var evt = node.element.dispatchEvent(
				'ibx_diagram_delete_node',
				node,
				true, true, node.element[0]
			);
			if (!evt.isDefaultPrevented()) {
				ret = node.element[destroy ? 'remove' : 'detach']();
				this._connections = $.grep(this._connections, function(connection) {
					return connection.from.node !== node && connection.to.node !== node;
				});
			}
		}
		this.resetConnections();  // Don't leave any dangling connection lines
		if (refresh) {
			this.refresh();
		}
		return ret;
	},
	clear: function() {
		this._nodeContainer.children().each((function(idx, child) {
			this.convertToNode(child).element.detach();
		}).bind(this));
		this._connections = [];
		this.resetConnections();
		this.refresh();
	},
	removeSelectedNodes: function() {
		this._nodeContainer.children().each((function(idx, child) {
			child = $(child).ibxDiagramNode('instance');
			if (child.options.selected) {
				this.remove(child);
			}
		}).bind(this));
	},
	selectNode: function(e) {
		if (!e.ctrlKey) {
			this._nodeContainer.children().each(function(idx, child) {
				child = $(child).ibxDiagramNode('instance');
				child.options.selected = false;
				child.element.ibxRemoveClass('ui-selected');
			});
		}
		var node = this.convertToNode(e.currentTarget);
		if (node && node.options.selectable) {
			node.setSelected(e.ctrlKey ? !node.options.selected : true);
		}
		this.triggerSelectionChange();
	},
	clearSelectedNodes: function() {
		this._nodeContainer.children().each((function(idx, child) {
			child = $(child).ibxDiagramNode('instance');
			child.setSelected(false);
		}).bind(this));
	},
	triggerSelectionChange: function() {
		this.element.dispatchEvent(
			'ibx_diagram_selection_change',
			this.getSelectedNodes(),
			true, true, this.element[0]  // canBubble, canCancel, relatedTarget
		);
	},
	getSelectedNodes: function() {
		return this._nodeContainer.children().filter(function(idx, child) {
			return $(child).ibxDiagramNode('option').selected;
		});
	},
	resetConnections: function() {
		this._svgContainer.empty();
		var connections = this._connections;
		this._connections = [];
		connections.forEach((function(connection) {
			this.addConnection(connection);
		}).bind(this));
	},
	addConnection: function(connection) {
		var g = $.ibi.ibxDiagram.getConnectionPath(connection.from.tip, connection.to.tip);
		if (connection.className) {
			g.ibxAddClass(connection.className);
		}
		this._svgContainer.append(g);
		var lineWidth = parseInt(window.getComputedStyle(g[0].firstElementChild).strokeWidth, 10);
		var from = this.convertToNode(connection.from.node);
		var to = this.convertToNode(connection.to.node);
		this._connections.push({
			className: connection.className,
			from: {
				node: from,
				anchor: connection.from.anchor,
				tip: $.ibi.ibxDiagram.clone(connection.from.tip)
			},
			to: {
				node: to,
				anchor: connection.to.anchor,
				tip: $.ibi.ibxDiagram.clone(connection.to.tip)
			},
			g: g[0],
			lineWidth: lineWidth
		});
		this.refresh();
		return this._connections.length - 1;
	},
	removeConnection: function(connectionIndex) {
		if (connectionIndex >= 0 && connectionIndex < this._connections.length) {
			this._connections.splice(connectionIndex, 1);
			this.resetConnections();
			this.refresh();
		}
	},
	updateConnections: function() {
		// Keep this function fast; it gets called on every mouse move
		for (var i = 0; i < this._connections.length; i++) {
			var connection = this._connections[i];
			var g = connection.g;
			var c1 = connection.from.node.element[0];
			var c1AnchorSize = connection.from.node.getAnchorSize(connection.from.anchor) / 2;
			var c2 = connection.to.node.element[0];
			var c2AnchorSize = connection.to.node.getAnchorSize(connection.to.anchor) / 2;
			var box1 = c1.getBoundingClientRect();
			var box2 = c2.getBoundingClientRect();
			var x1 = c1.offsetLeft + box1.width;
			var y1 = c1.offsetTop + (box1.height / 2);
			var x2 = c2.offsetLeft;
			var y2 = c2.offsetTop + (box2.height / 2);
			var padLeft = (g.childNodes[1] == null) ? 0 : connection.lineWidth;
			var padRight = (g.childNodes[2] == null) ? 0 : connection.lineWidth;
			var length = $.ibi.ibxDiagram.distance(x1, y1, x2, y2) - c1AnchorSize - padLeft - c2AnchorSize - padRight;
			var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

			// Move overall arrow to start connection point and rotate to point to end connection
			g.transform.baseVal.getItem(0).setTranslate(x1 + c1AnchorSize + padLeft, y1);
			g.transform.baseVal.getItem(1).setRotate(angle, 0, 0);

			g.childNodes[0].setAttribute('x2', length);  // Set line's end point
			if (g.childNodes[2]) {
				g.childNodes[2].transform.baseVal.getItem(0).setTranslate(length, 0);  // Position end arrow, if any
			}
		}
	}
});

$.ibi.ibxDiagram.clone = function(json) {
	return JSON.parse(JSON.stringify(json || null));
};

$.ibi.ibxDiagram.distance = function(x1, y1, x2, y2) {
	return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};

$.ibi.ibxDiagram.arrowShapeToPath = function(tip) {
	var size = tip.size || 10, shape = (tip.shape || '').toLowerCase();
	switch (shape) {
		case 'arrow-hollow':
			return 'M' + size + ' ' + (-size) + 'L0 0L' + size + ' ' + size + 'L0 0';
		case 'arrow':
			return 'M' + size + ' ' + (-size) + 'L0 0L' + size + ' ' + size + 'Z';
	}
	return '';
};

$.ibi.ibxDiagram.getConnectionPath = function(fromTip, toTip) {
	// Connections are drawn in a group that has been transformed such that
	// (0, 0) is at left connection and (100, 0) is on right connection
	var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
	g.setAttribute('transform', 'translate(0, 0) rotate(0)');

	var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
	line.setAttribute('x1', 0);
	line.setAttribute('y1', 0);
	line.setAttribute('x2', 0);
	line.setAttribute('y2', 0);
	g.appendChild(line);

	if (fromTip) {
		var tip = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		tip.setAttribute('d', $.ibi.ibxDiagram.arrowShapeToPath(fromTip));
		g.appendChild(tip);
	}

	if (toTip) {
		var tip2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		tip2.setAttribute('d', $.ibi.ibxDiagram.arrowShapeToPath(toTip));
		tip2.setAttribute('transform', 'translate(0, 0) rotate(180)');
		g.appendChild(tip2);
	}
	return $(g).ibxAddClass('ibx-diagram-connection');
};

$.widget('ibi.ibxDiagramNode', $.ibi.ibxWidget, {  // TODO: derive from base jquery ui widget ($.Widget)
	_widgetClass: 'ibx-diagram-node',
	options: {  // All optional; can also be set via the equivalent CSS properties
		left: null,
		top: null,  // TODO: remove these, but keep json api
		width: null,
		height: null,
		text: '',  // TODO: kill this
		data: null,  // TODO: kill or hide this
		annotations: [],
		selectable: true,  // If true, node can be clicked on to select it  // TODO: like delete, fire event, if shut down don't select
		moveable: true,    // If true, node cannot be dragged or moved around
		selected: false
	},
	_create: function() {
		this._super();
		if (this.options.className) {
			this.element.ibxAddClass(this.options.className);
		}
		if (this.options.text) {
			this.element.html($('<span class="ibx-diagram-node-text">' + this.options.text + '</span>'));
		}
	},
	_destroy: function() {
		this._super();
	},
	refresh: function() {
		this._super();
		this.element.css({
			left: this.options.left,
			top: this.options.top,
			width: this.options.width,
			height: this.options.height
		});
		this.element.ibxToggleClass('ibx-selectable', this.options.selectable);
		if (this.diagram) {
			this.element.draggable({disabled: !this.options.moveable});
			this.lockToGrid();
			this.diagram.updateConnections();
		}
	},
	init: function() {  // TODO: change to _init, so it's called automatically

		var diagram = this.diagram;
		var options = this.options;
		var nodeEl = this.element;
		var selectedNodes, offset;

		nodeEl.draggable({
			containment: 'parent',
			stack: '.ibx-diagram-node',
			disabled: !options.moveable,
			start: function() {  // TODO: move multi-select movement code to diagram
				selectedNodes = [];
				diagram._nodeContainer.children().each((function(idx, child) {
					child = $(child).ibxDiagramNode('instance');
					var el = child.element[0];
					if (child.options.selected && child.options.moveable && el !== this) {
						selectedNodes.push({
							node: el,
							offset: el.getBoundingClientRect()
						});
					}
				}).bind(this));
				if (selectedNodes.length) {
					selectedNodes.canvasSize = {
						width: diagram.element[0].clientWidth,
						height: diagram.element[0].clientHeight
					};
					offset = this.getBoundingClientRect();
				}
			},
			drag: function(e, ui) {
				if (selectedNodes.length) {
					var box = selectedNodes.canvasSize;
					var dx = ui.position.top - offset.top, dy = ui.position.left - offset.left;
					selectedNodes.forEach(function(el) {
						el.node.style.left = Math.max(0, Math.min(box.width - el.offset.width, el.offset.left + dy)) + 'px';
						el.node.style.top = Math.max(0, Math.min(box.height - el.offset.height, el.offset.top + dx)) + 'px';
					});
				}
			}
		}).css('position', '')  // draggable sets position to relative; undo that
			.on('drag', function(e) {
				diagram.convertToNode(e.target).updatePosition();
				diagram.updateConnections();
			});

		nodeEl.ibxToggleClass('ibx-selectable', options.selectable);
		nodeEl.attr('tabindex', diagram._nodeContainer.children().length);  // Need tabindex to make basic divs focusable and receive keyboard events
		nodeEl.keydown(function(e) {
			if (e.keyCode !== $.ui.keyCode.DELETE) {  // TODO: move function callback to prototype callback or similar
				return;
			}
			diagram.removeSelectedNodes();
		});
		nodeEl.click(function(e) {
			diagram.selectNode(e);
			e.stopPropagation();
		});

		// Force position to absolute, in case it's been set otherwise elsewhere
		nodeEl.css('position', 'absolute');

		// If position / size was set via CSS instead of options, copy those settings to options for consistency
		if (options.left == null || options.top == null) {
			this.updatePosition();
		}
		if (options.width == null || options.height == null) {
			var box = this.element[0].getBoundingClientRect();
			options.width = box.width;
			options.height = box.height;
		}
		this.children().each((function(idx, domNode) {
			var annotation = this.addAnnotation(domNode);
			if (annotation) {
				this.options.annotations.push(annotation);
			}
		}).bind(this));

		if (this.options.annotations.length) {
			this.options.annotations = this.options.annotations.map((function(annotation) {
				if (annotation && annotation.widgetName === 'ibxDiagramAnnotation') {
					return annotation;  // Node is already an ibxDiagramAnnotation
				}
				var classList = annotation.customClassList;
				annotation = $('<div>').ibxDiagramAnnotation(annotation);  // Assume 'annotation' is an ibxDiagramNode options object like {left, right, className, ...}.  Create a DOM node for it.
				annotation = this.addAnnotation(annotation);

				if (classList) {
					annotation.element.ibxAddClass(classList.join(' '));
				}
				return annotation;
			}).bind(this));
		}
	},
	addAnnotation: function(annotation) {
		annotation = $(annotation).ibxDiagramAnnotation('instance');
		if (annotation) {
			annotation.parent = this;
			if (annotation.element[0].parentElement !== this.element[0]) {
				this.element.append(annotation.element);
			}
			annotation.init();
		}
		return annotation;
	},
	updatePosition: function() {
		this.options.left = this.element[0].offsetLeft;
		this.options.top = this.element[0].offsetTop;
	},
	lockToGrid: function() {
		var gridSize = this.diagram.options.grid.size;
		if (this.options.moveable && gridSize != null) {
			var offset = this.diagram.options.grid.offset;
			var pos = this.element.position();
			this.element.css({
				left: (Math.floor(pos.left / gridSize) * gridSize) + offset.left,
				top: (Math.floor(pos.top / gridSize) * gridSize) + offset.top
			});
		}
	},
	getAnchorSize: function(side) {
		var annotations = this.options.annotations;
		for (var i = 0; i < annotations.length; i++) {
			var o = annotations[i].options;
			if (o.position === side) {
				return (side === 'top' || side === 'bottom') ? o.height : o.width;
			}
		}
		return 0;
	},
	setSelected: function(selected) {
		this.options.selected = selected;
		this.element.ibxToggleClass('ui-selected', selected);
	}
});

// TODO: get rid of this entirely; caller can just use ibxLabel.overlays
$.widget('ibi.ibxDiagramAnnotation', $.ibi.ibxWidget, {
	_widgetClass: 'ibx-diagram-annotation',
	options: {  // All optional; can also be set via the equivalent CSS properties
		position: null,  // Either ''top', 'right', 'bottom', left', or an object {left, top}
		width: null,
		height: null,
		offset: 0,
		text: ''
	},
	_create: function() {
		this._super();
		if (this.options.className) {
			this.element.ibxAddClass(this.options.className);
		}
		if (this.options.text) {
			this.element.html($('<span class="ibx-diagram-annotation-text">' + this.options.text + '</span>'));
		}
	},
	_destroy: function() {
		this._super();
	},
	refresh: function() {
		this._super();
	},
	init: function() {
		var options = this.options;
		var position = {left: null, top: null, width: null, height: null};
		if (options.position != null) {
			var pos = this.getPosition();
			position.left = pos.left;
			position.top = pos.top;
		}
		position.width = options.width;
		position.height = options.height;
		this.element.css(position);
	},
	getPosition: function() {
		var pos = this.options.position;
		if (pos.hasOwnProperty('left') && pos.hasOwnProperty('top')) {
			return pos;
		}
		if (!this.parent) {
			return {left: 0, top: 0};
		}
		var offset = this.options.offset || 0;
		var w = (this.options.width / 2) + offset;
		var h = (this.options.height / 2) + offset;
		var parentW = this.parent.options.width, parentH = this.parent.options.height;
		if (pos === 'top') {
			return {left: (parentW / 2) - w, top: -h};
		} else if (pos === 'right') {
			return {left: parentW - w, top: (parentH / 2) - h};
		} else if (pos === 'bottom') {
			return {left: (parentW / 2) - w, top: parentH - h};
		} else if (pos === 'left') {
			return {left: -w, top: (parentH / 2) - h};
		}
		return {left: 0, top: 0};
	}
});

//# sourceURL=diagram.ibx.js
]]></script-block><script-block src="c:/ibi/WebFOCUS82/webapps/webfocus/ibx/resources/./js/navmap.ibx.js"><![CDATA[/*Copyright 1996-2016 Information Builders, Inc. All rights reserved.*/
// $Revision: 1.8 $:

//sub classes of menu things to use for navigation mapping
$.widget("ibi.ibxNavMapItem", $.ibi.ibxMenuItem,{options:{navTarget:null, aria:{role:"listitem"}}, _widgetClass: "ibx-nav-map-item"});
$.widget("ibi.ibxNavMap", $.ibi.ibxMenu,
{
	options:
	{
		"navParent":null,
		"navTarget":null,
		"refocusLastActiveOnClose":false,
		"aria":
		{
			"role":"list",
			"label":ibx.resourceMgr.getString("IBX_NAV_MAP_LABEL")
		}
	},
	_widgetClass: "ibx-nav-map",
	_create:function()
	{
		this._super();
		this._sep = $("<div>").ibxMenuSeparator();
		this._navToParentItem = $("<div>").ibxNavMapItem({labelOptions:{text:ibx.resourceMgr.getString("IBX_NAV_MAP_UP_ON_LEVEL")}});
	},
	_onMenuItemClick:function(e)
	{
		if(this._navToParentItem.is(e.target))
			$(this.options.navParent).ibxWidget("open");
		else
		{
			var navTarget = $(e.target).ibxWidget("option", "navTarget");
			$(navTarget).focus();
		}
		this._super(e);
	},
	close:function(closeInfo)
	{
		this.options.refocusLastActiveOnClose = (closeInfo == "cancel");
		this._super(closeInfo);
	},
	_refresh:function()
	{
		var options = this.options;
		this._super();

		var navParent = options.navParent = $(options.navRoot).parents("[data-ibx-nav-map]").first().attr("data-ibx-nav-map");
		if(navParent)
			this._box.prepend(this._navToParentItem, this._sep);
		else
		{
			this._navToParentItem.detach();
			this._sep.detach();
		}
	}
});

//just listen for events to trigger the navigation management
function ibxNavManager()
{
	window.addEventListener("keydown", ibxNavManager._onKeyEvent.bind(this), true);
}
ibxNavManager.options =
{
	triggerKey:"CTRL+SHIFT+F10",
}
ibxNavManager._onKeyEvent = function(e)
{
	if(eventMatchesShortcut(ibxNavManager.options.triggerKey, e))
	{
		var target = $(e.target);
		var navRoot = target.closest("[data-ibx-nav-map]");
		$(navRoot.attr("data-ibx-nav-map")).ibxWidget("option", {"navRoot":navRoot}).ibxWidget("open");
	}
};
ibx.navManager = new ibxNavManager();

//# sourceURL=navmap.ibx.js
]]></script-block></scripts>

	<!--dependent resource bundles this bundle needs-->
	<res-bundles>
	</res-bundles>

	<!--RARELY USED - FORWARD REFERENCED BUNDLES - PROBABLY SHOULD BE A 'res-bundle'...default external bundles to be loaded AFTER this bundles is fully loaded and running-->
	<packages>
	</packages>

</ibx-res-bundle>
